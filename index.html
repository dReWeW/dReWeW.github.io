<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Dalong"><title>Dalong's Blog</title><meta name="description" content="随便写写"><meta name="keywords" content="Blog,博客"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="shortcut icon" type="image/x-icon" href="/images/favicon.webp"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/insight.css"><link rel="stylesheet" href="/css/search.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script src="/js/jquery.js"></script><meta name="generator" content="Hexo 6.1.0"></head><body><div class="page-top animated fadeInDown"><div class="nav"><li> <a class="current" href="/">首页</a></li><li> <a href="/archives">归档</a></li><li> <a href="/tags">标签</a></li></div><div class="information"><div class="nav_right_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)" style="display:none;"> </a></li><li><a class="fa fa-search" onclick="openWindow();"></a></li></div><div class="avatar"><img src="/images/avatar.webp"></div></div></div><div class="sidebar animated fadeInDown"><div class="sidebar-top"><div class="logo-title"><div class="title"><img src="/images/avatar.webp" style="width:200px;" alt="favicon"><h3 title=""><a href="/">Dalong's Blog</a></h3><div class="description"><p>随便写写</p></div></div><ul class="social-links"><li><a target="_blank" rel="noopener" href="https://github.com/dReWeW"><i class="fa fa-github"></i></a></li><li><a href="mailto:dalongzd@qq.com"><i class="fa fa-envelope"></i></a></li><li><a target="_blank" rel="noopener" href="http://sighttp.qq.com/authd?IDKEY=569775346"><i class="fa fa-qq"></i></a></li></ul></div></div><div class="footer"><div class="p"> <span> 全站CC-BY-SA-3.0 </span><i class="fa fa-star"></i><span> Dalong</span></div><div class="by_farbox"><span>Powered by </span><a href="https://hexo.io/zh-cn/" target="_blank">Hexo </a><span> & </span><span>Anatolo </span></div><div class="beian"></div></div></div><div class="main"><div class="autopagerize_page_element"><div class="content"><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/03/22/%E3%80%90Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%912039-%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B2%E7%9A%84%E6%97%B6%E5%88%BB/">【Leetcode刷题笔记】2039 网络空闲的时刻</a></h3></div><div class="post-content"><div class="card"><p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个有 <code>n</code> 个服务器的计算机网络，服务器编号为 <code>0</code> 到 <code>n - 1</code> 。同时给你一个二维整数数组 <code>edges</code> ，其中 <code>edges[i] = [ui, vi]</code> 表示服务器 <code>ui</code> 和 <code>vi</code> 之间有一条信息线路，在 <strong>一秒</strong> 内它们之间可以传输 <strong>任意</strong> 数目的信息。再给你一个长度为 <code>n</code> 且下标从 <strong>0</strong> 开始的整数数组 <code>patience</code> 。</p>
<p>题目保证所有服务器都是 <strong>相通</strong> 的，也就是说一个信息从任意服务器出发，都可以通过这些信息线路直接或间接地到达任何其他服务器。</p>
<p>编号为 <code>0</code> 的服务器是 <strong>主</strong> 服务器，其他服务器为 <strong>数据</strong> 服务器。每个数据服务器都要向主服务器发送信息，并等待回复。信息在服务器之间按 <strong>最优</strong> 线路传输，也就是说每个信息都会以 <strong>最少时间</strong> 到达主服务器。主服务器会处理 <strong>所有</strong> 新到达的信息并 <strong>立即</strong> 按照每条信息来时的路线 <strong>反方向</strong> 发送回复信息。</p>
<p>在 <code>0</code> 秒的开始，所有数据服务器都会发送各自需要处理的信息。从第 <code>1</code> 秒开始，<strong>每</strong> 一秒最 <strong>开始</strong> 时，每个数据服务器都会检查它是否收到了主服务器的回复信息（包括新发出信息的回复信息）：</p>
<ul>
<li>如果还没收到任何回复信息，那么该服务器会周期性 <strong>重发</strong> 信息。数据服务器 <code>i</code> 每 <code>patience[i]</code> 秒都会重发一条信息，也就是说，数据服务器 <code>i</code> 在上一次发送信息给主服务器后的 <code>patience[i]</code> 秒 <strong>后</strong> 会重发一条信息给主服务器。</li>
<li>否则，该数据服务器 <strong>不会重发</strong> 信息。</li>
</ul>
<p>当没有任何信息在线路上传输或者到达某服务器时，该计算机网络变为 <strong>空闲</strong> 状态。</p>
<p>请返回计算机网络变为 <strong>空闲</strong> 状态的 <strong>最早秒数</strong> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/09/22/quiet-place-example1.png" alt="example 1"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">输入：edges = [[0,1],[1,2]], patience = [0,2,1]</span><br><span class="line">输出：8</span><br><span class="line">解释：</span><br><span class="line">0 秒最开始时，</span><br><span class="line">- 数据服务器 1 给主服务器发出信息（用 1A 表示）。</span><br><span class="line">- 数据服务器 2 给主服务器发出信息（用 2A 表示）。</span><br><span class="line"></span><br><span class="line">1 秒时，</span><br><span class="line">- 信息 1A 到达主服务器，主服务器立刻处理信息 1A 并发出 1A 的回复信息。</span><br><span class="line">- 数据服务器 1 还没收到任何回复。距离上次发出信息过去了 1 秒（1 &lt; patience[1] = 2），所以不会重发信息。</span><br><span class="line">- 数据服务器 2 还没收到任何回复。距离上次发出信息过去了 1 秒（1 == patience[2] = 1），所以它重发一条信息（用 2B 表示）。</span><br><span class="line"></span><br><span class="line">2 秒时，</span><br><span class="line">- 回复信息 1A 到达服务器 1 ，服务器 1 不会再重发信息。</span><br><span class="line">- 信息 2A 到达主服务器，主服务器立刻处理信息 2A 并发出 2A 的回复信息。</span><br><span class="line">- 服务器 2 重发一条信息（用 2C 表示）。</span><br><span class="line">...</span><br><span class="line">4 秒时，</span><br><span class="line">- 回复信息 2A 到达服务器 2 ，服务器 2 不会再重发信息。</span><br><span class="line">...</span><br><span class="line">7 秒时，回复信息 2D 到达服务器 2 。</span><br><span class="line"></span><br><span class="line">从第 8 秒开始，不再有任何信息在服务器之间传输，也不再有信息到达服务器。</span><br><span class="line">所以第 8 秒是网络变空闲的最早时刻。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/09/04/network_a_quiet_place_2.png" alt="example 2"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：edges = [[0,1],[0,2],[1,2]], patience = [0,10,10]</span><br><span class="line">输出：3</span><br><span class="line">解释：数据服务器 1 和 2 第 2 秒初收到回复信息。</span><br><span class="line">从第 3 秒开始，网络变空闲。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>n == patience.length</code></li>
<li><code>2 &lt;= n &lt;= 105</code></li>
<li><code>patience[0] == 0</code></li>
<li>对于 <code>1 &lt;= i &lt; n</code> ，满足 <code>1 &lt;= patience[i] &lt;= 105</code></li>
<li><code>1 &lt;= edges.length &lt;= min(105, n * (n - 1) / 2)</code></li>
<li><code>edges[i].length == 2</code></li>
<li><code>0 &lt;= ui, vi &lt; n</code></li>
<li><code>ui != vi</code></li>
<li>不会有重边。</li>
<li>每个服务器都直接或间接与别的服务器相连。</li>
</ul>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><blockquote>
<p>刚看此题的时候，我寻思这才中等题？后来仔细一看，题中的情况其实非常简单</p>
</blockquote>
<p>分析题干可知，一个主机的数据包到达服务器的事件是固定不变的，不受其他影响。</p>
<p>那我们假设主机到服务器的最短路径为<code>x</code>，那么从开始到收到确认包，就需要<code>2x</code>的时间。</p>
<p>那么确认一台主机多久会进入空闲状态只需要知道它最后一个数据包被确认的时间了。</p>
<p>我们已知在<code>2x</code>时刻，第一个数据包的ack到达主机，此时主机不会再重复发数据包，那么最后一个可能重复发数据包的时刻就是<code>2x-1</code>。</p>
<p>很容易可以推知$$ (2x-1)\ mod\ patience[i]&#x3D;&#x3D;0$$时，该时刻需要发最后一个数据包。</p>
<p>那如果不等于0呢？那就是最后一个数据包的当前位置了。</p>
<p>我们把等于0的情况看做最后一个数据包位于发送方主机的位置。那么可以推知，此时最后一个数据包收到确认的时间为 $$2x-1-(2x-1)mod\ patience[i]$$</p>
<p>因而最后一个数据包到达的时间为$4x-1-(2x-1)mod\ patience[i]+1$</p>
<p>又因为到达的下一时刻才会进入空闲，那么进入空闲的时间为 $4x-(2x-1)mod\ patience[i]$</p>
<p><strong>单源最短路径</strong></p>
<p>那么现在只需要算出每个主机距离服务器的最短距离，然后遍历获取最大值即可。这里使用dijkstra算法完成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">node</span> &#123;</span><br><span class="line">        <span class="type">int</span> index;</span><br><span class="line">        <span class="type">int</span> length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">node</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.index = index;</span><br><span class="line">            <span class="built_in">this</span>.length = length;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">networkBecomesIdle</span><span class="params">(<span class="type">int</span>[][] edges, <span class="type">int</span>[] patience)</span> &#123;</span><br><span class="line">        <span class="comment">// 先用Dijkstra算法做一下</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> patience.length;</span><br><span class="line">        <span class="type">int</span>[][] map = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="comment">// 初始化map所有初始值为Inf</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            Arrays.fill(map[i], Integer.MAX_VALUE);</span><br><span class="line">            map[i][i]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] edge : edges) &#123;</span><br><span class="line">            map[edge[<span class="number">0</span>]][edge[<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] dist = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Arrays.fill(dist, Integer.MAX_VALUE);</span><br><span class="line">        dist[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        Queue&lt;node&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>();</span><br><span class="line">        queue.add(<span class="keyword">new</span> <span class="title class_">node</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">boolean</span>[] vis=<span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">        vis[<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">node</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (map[cur.index][i] == <span class="number">1</span> &amp;&amp; !vis[i]&amp;&amp; dist[i] &gt; dist[cur.index] + <span class="number">1</span>) &#123;</span><br><span class="line">                    dist[i] = dist[cur.index] + <span class="number">1</span>;</span><br><span class="line">                    queue.add(<span class="keyword">new</span> <span class="title class_">node</span>(i, dist[i]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count == n - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 到这里已经算出了最短路径</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> num=<span class="number">4</span>*dist[i]-(<span class="number">2</span>*dist[i]-<span class="number">1</span>)%patience[i];</span><br><span class="line">            <span class="keyword">if</span>(num&gt;max)</span><br><span class="line">                max=num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Comparator&lt;node&gt; com = <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;node&gt;() &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(node o1, node o2)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> o1.length - o2.length;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度</strong></p>
<p>时间复杂度 最坏为O(n^2),最好为O(n)</p>
<p>空间复杂度O(n)</p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-03-22</span><a class="tag" href="/categories/LeetCode/" title="LeetCode">LeetCode </a><i class="fa fa-tag"></i><a class="tag" href="/tags/刷题笔记/" title="刷题笔记">刷题笔记 </a><span class="leancloud_visitors"></span><span>大约1688个字, 5分钟37秒读完</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/03/21/%E3%80%90Java%E3%80%91Java%E6%9C%89%E5%93%AA%E4%BA%9B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/">【Java】Java有哪些类加载器</a></h3></div><div class="post-content"><div class="card"><p><h2 id="什么是classloader"><a href="#什么是classloader" class="headerlink" title="什么是classloader"></a>什么是classloader</h2><p>classloader顾名思义，即是类加载。虚拟机把描述类的数据从class字节码文件加载到内存，并对数据进行检验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。了解java的类加载机制，可以快速解决运行时的各种加载问题并快速定位其背后的本质原因，也是解决疑难杂症的利器。因此学好类加载原理也至关重要。</p>
<h2 id="classloader的加载过程"><a href="#classloader的加载过程" class="headerlink" title="classloader的加载过程"></a>classloader的加载过程</h2><p>类从被加载到<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:1739289578%7D">虚拟机内存</a>到被卸载，整个完整的生命周期包括：类加载、验证、准备、解析、初始化、使用和卸载七个阶段。其中验证，准备，解析三个部分统称为连接。接下来我们可以详细了解下类加载的各个过程。</p>
<p><img src="https://pic3.zhimg.com/50/v2-071d6fa5c0aefe61c363bc94b6b5b286_720w.jpg?source=1940ef5c" alt="img"><img src="https://pic3.zhimg.com/80/v2-071d6fa5c0aefe61c363bc94b6b5b286_720w.jpg?source=1940ef5c" alt="img"></p>
<p>classloader的整个加载过程还是非常复杂的，具体的细节可以参考《<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:1739289578%7D">深入理解java虚拟机</a>》进行深入了解。为了方便记忆，我们可以使用一句话来表达其加载的整个过程，“家宴准备了西式菜”，即家(加载)宴(验证)准备(准备)了西(解析)式(初始化)菜。保证你以后能够很快的想起来。<br>虽然classloader的加载过程有复杂的5步，但事实上除了加载之外的四步，其它都是由JVM虚拟机控制的，我们除了适应它的规范进行开发外，能够干预的空间并不多。而加载则是我们控制classloader实现特殊目的最重要的手段了。也是接下来我们介绍的重点了。</p>
<h2 id="classloader双亲委托机制"><a href="#classloader双亲委托机制" class="headerlink" title="classloader双亲委托机制"></a>classloader双亲委托机制</h2><p>classloader的双亲委托机制是指多个类加载器之间存在父子关系的时候，某个class类具体由哪个加载器进行加载的问题。其具体的过程表现为：当一个类加载的过程中，它首先不会去加载，而是委托给自己的父类去加载，父类又委托给自己的父类。因此所有的类加载都会委托给顶层的父类，即Bootstrap Classloader进行加载，然后父类自己无法完成这个加载请求，子加载器才会尝试自己去加载。使用双亲委派模型，Java类随着它的加载器一起具备了一种带有优先级的层次关系，通过这种<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E5%B1%82%E6%AC%A1%E6%A8%A1%E5%9E%8B&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:1739289578%7D">层次模型</a>，可以避免类的重复加载，也可以避免核心类被不同的类加载器加载到内存中造成冲突和混乱，从而保证了Java核心库的安全。</p>
<p><img src="https://pic1.zhimg.com/50/v2-eafe30b56d52cc526d6da75430807390_720w.jpg?source=1940ef5c" alt="img"><img src="https://pic1.zhimg.com/80/v2-eafe30b56d52cc526d6da75430807390_720w.jpg?source=1940ef5c" alt="img"></p>
<p>整个java虚拟机的类加载层次关系如上图所示，启动类加载器(Bootstrap Classloader)负责将<JAVA_HOME>&#x2F;lib目录下并且被虚拟机识别的类库加载到虚拟机内存中。我们常用基础库，例如java.util.**，java.io.**，java.lang.**等等都是由根加载器加载。</p>
<p>扩展类加载器(Extention Classloader)负责加载JVM扩展类，比如swing系列、内置的js引擎、xml解析器等，这些类库以javax开头，它们的jar包位于<JAVA_HOME>&#x2F;lib&#x2F;ext目录中。</p>
<p>应用程序加载器(Application Classloader)也叫系统类加载器，它负责加载用户路径(ClassPath)上所指定的类库。我们自己编写的代码以及使用的第三方的jar包都是由它来加载的自定义加载器(Custom Classloader)通常是我们为了某些特殊目的实现的自定义加载器，后面我们得会详细介绍到它的作用以及使用场景。</p>
<p>双亲委托机制看起来比较复杂，但是其本身的核心代码逻辑却是非常的清晰简单，我们着重抽取了类加载的双亲委托的核心代码如下，不过二十行左右。</p>
<p><img src="https://pic1.zhimg.com/50/v2-d2b2276905548a42a329ca52e4444dfc_720w.jpg?source=1940ef5c" alt="img"><img src="https://pic1.zhimg.com/80/v2-d2b2276905548a42a329ca52e4444dfc_720w.jpg?source=1940ef5c" alt="img"></p>
<h2 id="classloader的应用场景"><a href="#classloader的应用场景" class="headerlink" title="classloader的应用场景"></a>classloader的应用场景</h2><p>类加载器是java语言的一项创新，也是java语言流行的重要原因这一。通过灵活定义classloader的加载机制，我们可以完成很多事情，例如解决类冲突问题，实现热加载以及热部署，甚至可以实现jar包的加密保护。接下来，我们会针对这些特殊场景进行逐一介绍。</p>
<blockquote>
<p> 作者：阿里巴巴淘系技术<br>链接：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/46719811/answer/1739289578">https://www.zhihu.com/question/46719811/answer/1739289578</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-03-21</span><a class="tag" href="/categories/Java/" title="Java">Java </a><i class="fa fa-tag"></i><a class="tag" href="/tags/Java基础/" title="Java基础">Java基础 </a><span class="leancloud_visitors"></span><span>大约1256个字, 4分钟11秒读完</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/03/21/%E3%80%90Spring%E3%80%91Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/">【Spring】Spring源码分析（一）</a></h3></div><div class="post-content"><div class="card"><p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><p><strong>IOC与DI</strong></p>
<p>IOC 控制反转，一种思想。依赖注入，一种手段。</p>
<p><strong>IOC</strong>是控制反转的意思，这是一种面向对象编程的设计思想。在不采用这种思想的情况下，我们需要自己维护对象与对象之间的依赖关系，很容易造成对象之间的耦合度过高，在一个大型的项目中这十分的不利于代码的维护。IoC则可以解决这种问题，它可以帮我们维护对象与对象之间的依赖关系，降低对象之间的耦合度。</p>
<p><strong>DI</strong>是依赖注入的意思，它是IoC实现的实现方式，就是说IoC是通过DI来实现的。由于IoC这个词汇比较抽象而DI却更直观，所以很多时候我们就用DI来代替它，在很多时候我们简单地将IoC和DI划等号，这是一种习惯。而实现依赖注入的关键是IoC容器，它的本质就是一个工厂。</p>
<p><strong>xml里配置bean</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">?</span> <span class="attr">class</span>=<span class="string">?</span> <span class="attr">abstract</span> <span class="attr">init-method</span> <span class="attr">scope</span> <span class="attr">dependon...</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">?</span> <span class="attr">value</span>=<span class="string">?/</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">?</span> <span class="attr">value</span>=<span class="string">?/</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>Java里获取bean</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Application ac=<span class="keyword">new</span>;</span><br><span class="line">ClassPathXmlApplicationContext(<span class="string">&quot;applicationContent.xml&quot;</span>);</span><br><span class="line">XXX xxx=ac.getBean(XXX.class);</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 从xml配置到bean发生了什么？</p>
</blockquote>
<p>LoadXml-&gt;ParseXml-&gt;封装BeanDefinition-&gt;实例化(使用反射而非<code>new</code>)-&gt;放入容器中-&gt;从容器中获取</p>
<ul>
<li>不只xml可以配置bean,如properties groovy也可以配置bean</li>
<li>从配置文件到生成beanDefinition,解析器需要实现<code>BeanDefinitionReader</code> 接口。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanDefinitionReader</span></span><br></pre></td></tr></table></figure>

<ul>
<li>理解实例化的过程需要先了解反射，这里简单复习一下Java反射机制</li>
</ul>
<p><strong>反射获取类对象的几种方式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class.forName();</span><br><span class="line">对象.getClass();</span><br><span class="line">类名.class();</span><br></pre></td></tr></table></figure>
<p>一些示例代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;TreeNode&quot;</span>);</span><br><span class="line">       Constructor[] constructors= clazz.getConstructors();</span><br><span class="line">       <span class="keyword">for</span> (Constructor constructor : constructors) &#123;</span><br><span class="line">           System.out.println(constructor);</span><br><span class="line">       &#125;</span><br><span class="line">       constructors=clazz.getDeclaredConstructors();</span><br><span class="line">       <span class="keyword">for</span> (Constructor constructor : constructors) &#123;</span><br><span class="line">           System.out.println(constructor);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 由于无参构造函数是私有的，而getConstructor只能获取公有的，所以会抛出异常</span></span><br><span class="line">       <span class="comment">// Constructor con=clazz.getConstructor(null);</span></span><br><span class="line">       <span class="comment">// System.out.println(con);</span></span><br><span class="line">       Constructor con=clazz.getConstructor(<span class="type">int</span>.class);</span><br><span class="line">       System.out.println(con);</span><br><span class="line"></span><br><span class="line">       TreeNode root= (TreeNode) con.newInstance(<span class="number">1</span>);</span><br><span class="line">       Field field=clazz.getDeclaredField(<span class="string">&quot;val&quot;</span>);</span><br><span class="line">       field.set(root, <span class="number">2</span>);</span><br><span class="line">       System.out.println(root.val);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 输出object mark word</span></span><br><span class="line">       </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>PostProcessor</strong></p>
<ul>
<li><code>BeanFactorPostProcessor</code> BeanDefinition增强器接口，自定义的PostProcessor需要实现它</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">myBeanFactoryPoProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanFactoryPostProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;myBeanFactoryPoProcessor&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>BeanProcessor</code>Bean的增强器接口，自定义的PostProcessor需要实现它</li>
<li></li>
</ul>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-03-21</span><a class="tag" href="/categories/Spring/" title="Spring">Spring </a><i class="fa fa-tag"></i><a class="tag" href="/tags/源码分析/" title="源码分析">源码分析 </a><span class="leancloud_visitors"></span><span>大约647个字, 2分钟9秒读完</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/03/21/%E3%80%90%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/">【并发编程】高并发秒杀系统架构设计</a></h3></div><div class="post-content"><div class="card"><p><blockquote>
<p>以下内容为马士兵老师的Java并发编程中高并发秒杀系统架构实战的听课笔记</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1aS4y1R7UW?p=7">【马士兵教育】首次深入计算机底层原理透彻解析Java并发编程，JUC并发编程，多线程，高并发秒杀方案全套教程（合集）_哔哩哔哩_bilibili</a></p>
</blockquote>
<h3 id="CAP定理"><a href="#CAP定理" class="headerlink" title="CAP定理"></a>CAP定理</h3><p>CAP原则又称CAP定理，指的是在一个分布式系统中， Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可得兼。</p>
<ul>
<li><strong>一致性（C）</strong>：在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本）</li>
<li><strong>可用性（A）</strong>：保证每个请求不管成功或者失败都有响应。</li>
<li><strong>分区容忍性（P）</strong>：系统中任意信息的丢失或失败不会影响系统的继续运作。</li>
</ul>
<p><strong>关于分区容忍性的理解：</strong> 分区容忍性是指当系统发生故障时，是否可以继续正常运作。如，两台服务器之间的网线断开了，无法进行信息交换，如果这时系统能够容忍这样的故障发生并且继续运行，则叫分区容忍性。</p>
<p><strong>为什么不能同时满足的通俗理解</strong></p>
<ol>
<li>满足C和A，那么P能不能满足呢？</li>
</ol>
<p>满足C需要所有的服务器的数据要一样，也就是说要实现数据的同步，那么同步要不要时间？肯定是要的，并且机器越多，同步的时间肯定越慢，这里问题就来了，我们同时也满足了A，也就是说，我要同步时间短才行。这样的话，机器就不能太多了，也就是说P是满足不了的</p>
<ol start="2">
<li>满足C和P，那么A能不能满足呢？</li>
</ol>
<p>满足P需要很多服务器，假设有1000台服务器，同时满足了C，也就是说要保证每台机器的数据都一样，那么同步的时间可就很大，在这种情况下，我们肯定是不能保证用户随时访问每台服务器获取到的数据都是最新的，想要获取最新的，可以，你就等吧，等全部同步完了，你就可以获取到了，但是我们的A要求短时间就可以拿到想要的数据啊，这不就是矛盾了，所以说这里A是满足不了了</p>
<ol start="3">
<li>满足A和P，那么C能不能满足呢？</li>
</ol>
<p>满足P的话，需要多台服务器，而满足C的话，只有一台服务器才可以满足，这和P矛盾。</p>
<h3 id="12306的问题"><a href="#12306的问题" class="headerlink" title="12306的问题"></a>12306的问题</h3><ol>
<li>强一致性带来的难题 - 递归循环锁<ul>
<li>解决： 分布式一致性哈希环，防止一个节点存全量数据，只存和处理一部分数据。</li>
<li>降低一致性增强可用性</li>
<li>异步通讯，慢慢完成数据一致性。（前端一致，后端不一致）</li>
<li></li>
</ul>
</li>
</ol>
<h3 id="Base理论"><a href="#Base理论" class="headerlink" title="Base理论"></a>Base理论</h3><p>BASE理论是Basically Available(基本可用)，Soft State（软状态）和Eventually Consistent（最终一致性）三个短语的缩写。</p>
<p>核心思想：</p>
<blockquote>
<p>既是无法做到强一致性（Strong consistency），但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）。</p>
</blockquote>
<h4 id="基本可用"><a href="#基本可用" class="headerlink" title="基本可用"></a>基本可用</h4><p>什么是基本可用呢？假设系统，出现了不可预知的故障，但还是能用，相比较正常的系统而言：</p>
<p><strong>响应时间上的损失</strong>：正常情况下的搜索引擎0.5秒即返回给用户结果，而基本可用的搜索引擎可以在2秒作用返回结果。</p>
<p><strong>功能上的损失</strong>：在一个电商网站上，正常情况下，用户可以顺利完成每一笔订单。但是到了大促期间，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面。3.2. 软状态</p>
<h4 id="软状态"><a href="#软状态" class="headerlink" title="软状态"></a>软状态</h4><p>什么是软状态呢？相对于原子性而言，要求多个节点的数据副本都是一致的，这是一种“硬状态”。</p>
<p>软状态指的是：允许系统中的数据存在中间状态，并认为该状态不影响系统的整体可用性，即允许系统在多个不同节点的数据副本存在数据延时。</p>
<h4 id="最终一致性"><a href="#最终一致性" class="headerlink" title="最终一致性"></a>最终一致性</h4><p>上面说软状态，然后不可能一直是软状态，必须有个时间期限。在期限过后，应当保证所有副本保持数据一致性，从而达到数据的最终一致性。这个时间期限取决于网络延时、系统负载、数据复制方案设计等等因素。</p>
<h3 id="TPS和QPS区别"><a href="#TPS和QPS区别" class="headerlink" title="TPS和QPS区别"></a>TPS和QPS区别</h3><h5 id="TPS"><a href="#TPS" class="headerlink" title="TPS"></a><strong>TPS</strong></h5><p>TPS：Transactions Per Second，意思是每秒事务数，具体事务的定义，都是人为的，可以一个接口、多个接口、一个业务流程等等。一个事务是指事务内第一个请求发送到接收到最后一个请求的响应的过程，以此来计算使用的时间和完成的事务个数。</p>
<p>以单接口定义为事务为例，每个事务包括了如下3个过程：</p>
<p>　　a.向服务器发请求</p>
<p>　　b.服务器自己的内部处理（包含应用服务器、数据库服务器等）</p>
<p>　　c.服务器返回结果给客户端</p>
<p>　　如果每秒能够完成N次这三个过程，tps就是N；</p>
<p>如果多个接口定义为一个事务，那么，会重复执行abc，完成一次这几个请求，算做一个tps。</p>
<h5 id="QPS"><a href="#QPS" class="headerlink" title="QPS"></a>QPS</h5><p>QPS：Queries Per Second，意思是每秒查询率，是一台服务器每秒能够响应的查询次数（数据库中的每秒执行查询sql的次数），显然，这个不够全面，不能描述增删改，所以，不建议用qps来作为系统性能指标。</p>
<ul>
<li>qps包含tps</li>
</ul>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-03-21</span><a class="tag" href="/categories/实战/" title="实战">实战 </a><i class="fa fa-tag"></i><a class="tag" href="/tags/实战/" title="实战">实战 </a><span class="leancloud_visitors"></span><span>大约1668个字, 5分钟33秒读完</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/03/21/%E3%80%90Java%E3%80%91Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">【Java】Java并发编程</a></h3></div><div class="post-content"><div class="card"><p><h3 id="操作系统补充"><a href="#操作系统补充" class="headerlink" title="操作系统补充"></a>操作系统补充</h3><p><strong>缓存行（cache line)</strong></p>
<p>缓存行一般是64字节大小，且在缓存中支持一致性协议。</p>
<h3 id="Volite-关键字"><a href="#Volite-关键字" class="headerlink" title="Volite 关键字"></a>Volite 关键字</h3><h4 id="字节码层面"><a href="#字节码层面" class="headerlink" title="字节码层面"></a>字节码层面</h4><ul>
<li>volite修饰的关键字，会在<strong>字节码</strong>里多出一个ACC_VOLITE标志</li>
</ul>
<h4 id="JVM层面"><a href="#JVM层面" class="headerlink" title="JVM层面"></a>JVM层面</h4><ul>
<li><p><strong>JVM层面</strong>会增加一个内存屏障，为了禁止指令乱序执行。</p>
</li>
<li><p>使用volite修饰的变量，线程不会从缓存读取它，而是从主存读它</p>
<ul>
<li>关于缓存 CPU与主存之间往往由三级缓存，其中L1,L2在CPU内，L3在主板上</li>
</ul>
</li>
<li><p>JVM要求所有的JVM实现以下屏障</p>
<ul>
<li>Loadload&#x2F;StoreLoad&#x2F;StoreStore&#x2F;storeLoad 屏障</li>
<li>因而volatile在JVM下有以下屏障来禁止指令乱序执行</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">---- LoadLoad barrier------ <span class="comment">// 前面一条写num操作执行完才能之下下面这条</span></span><br><span class="line">read(num)</span><br><span class="line">---- LoadStore barrier ----- <span class="comment">// 这条写Num操作执行完才能进行下面的读操作</span></span><br><span class="line"></span><br><span class="line">----storestore barrier----</span><br><span class="line">read(num)</span><br><span class="line">----loadstore barrier----</span><br></pre></td></tr></table></figure>

<h4 id="CPU层面"><a href="#CPU层面" class="headerlink" title="CPU层面"></a>CPU层面</h4><ul>
<li>sfence(storefence) lfence(loadfence) mfence(multi-fence全屏障)</li>
<li>MESI 缓存行一致性协议</li>
<li>Lock 锁总线</li>
</ul>
<h3 id="线程和锁"><a href="#线程和锁" class="headerlink" title="线程和锁"></a>线程和锁</h3><ul>
<li>go的协程很像java的线程池之间的关系<ul>
<li>go和java都是事先分配一些内核线程来处理任务队列</li>
<li>java不能任务同步 但go可以</li>
<li>go通过模拟了cpu的执行。（cpu时钟周期）</li>
</ul>
</li>
</ul>
<h2 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h2><p>内置锁在Java中被抽象为监视器锁（monitor）。在JDK 1.6之前，监视器锁可以认为直接对应底层操作系统中的互斥量（mutex）。这种同步方式的成本非常高，包括系统调用引起的内核态与用户态切换、线程阻塞造成的线程切换等。因此，后来称这种锁为“重量级锁”。</p>
<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>首先，内核态与用户态的切换上不容易优化。但<strong>通过自旋锁，可以减少线程阻塞造成的线程切换</strong>（包括挂起线程和恢复线程）。</p>
<p>如果锁的粒度小，那么<strong>锁的持有时间比较短</strong>（尽管具体的持有时间无法得知，但可以认为，通常有一部分锁能满足上述性质）。那么，对于竞争这些锁的而言，因为锁阻塞造成线程切换的时间与锁持有的时间相当，减少线程阻塞造成的线程切换，能得到较大的性能提升。具体如下：</p>
<ul>
<li>当前线程竞争锁失败时，打算阻塞自己</li>
<li>不直接阻塞自己，而是自旋（空等待，比如一个空的有限for循环）一会</li>
<li>在自旋的同时重新竞争锁</li>
<li>如果自旋结束前获得了锁，那么锁获取成功；否则，自旋结束后阻塞自己</li>
</ul>
<p><em>如果在自旋的时间内，锁就被旧owner释放了，那么当前线程就不需要阻塞自己</em>（也不需要在未来锁释放时恢复），减少了一次线程切换。</p>
<p>“锁的持有时间比较短”这一条件可以放宽。实际上，只要锁竞争的时间比较短（比如线程1快释放锁的时候，线程2才会来竞争锁），就能够提高自旋获得锁的概率。这通常发生在<strong>锁持有时间长，但竞争不激烈</strong>的场景中。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>单核处理器上，不存在实际的并行，当前线程不阻塞自己的话，旧owner就不能执行，锁永远不会释放，此时不管自旋多久都是浪费；进而，如果线程多而处理器少，自旋也会造成不少无谓的浪费。</li>
<li>自旋锁要占用CPU，如果是计算密集型任务，这一优化通常得不偿失，减少锁的使用是更好的选择。</li>
<li>如果锁竞争的时间比较长，那么自旋通常不能获得锁，白白浪费了自旋占用的CPU时间。这通常发生在<em>锁持有时间长，且竞争激烈</em>的场景中，此时应主动禁用自旋锁。</li>
</ul>
<blockquote>
<p>使用-XX:-UseSpinning参数关闭自旋锁优化；-XX:PreBlockSpin参数修改默认的自旋次数。</p>
</blockquote>
<h3 id="自适应自旋锁"><a href="#自适应自旋锁" class="headerlink" title="自适应自旋锁"></a>自适应自旋锁</h3><p>自适应意味着自旋的时间不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定：</p>
<ul>
<li>如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长的时间，比如100个循环。</li>
<li>相反的，如果对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能减少自旋时间甚至省略自旋过程，以避免浪费处理器资源。</li>
</ul>
<p><strong>自适应自旋解决的是“锁竞争时间不确定”的问题</strong>。JVM很难感知到确切的锁竞争时间，而交给用户分析就违反了JVM的设计初衷。<em>自适应自旋假定不同线程持有同一个锁对象的时间基本相当，竞争程度趋于稳定，因此，可以根据上一次自旋的时间与结果调整下一次自旋的时间</em>。</p>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><p>然而，自适应自旋也没能彻底解决该问题，<em>如果默认的自旋次数设置不合理（过高或过低），那么自适应的过程将很难收敛到合适的值</em>。</p>
<h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><p>自旋锁的目标是降低线程切换的成本。如果锁竞争激烈，我们不得不依赖于重量级锁，让竞争失败的线程阻塞；如果完全没有实际的锁竞争，那么申请重量级锁都是浪费的。<strong>轻量级锁的目标是，减少无实际竞争情况下，使用重量级锁产生的性能消耗</strong>，包括系统调用引起的内核态与用户态切换、线程阻塞造成的线程切换等。</p>
<p>顾名思义，轻量级锁是相对于重量级锁而言的。使用轻量级锁时，不需要申请互斥量，仅仅<em>将Mark Word中的部分字节CAS更新指向线程栈中的Lock Record，如果更新成功，则轻量级锁获取成功</em>，记录锁状态为轻量级锁；<em>否则，说明已经有线程获得了轻量级锁，目前发生了锁竞争（不适合继续使用轻量级锁），接下来膨胀为重量级锁</em>。</p>
<blockquote>
<p>Mark Word是对象头的一部分；每个线程都拥有自己的线程栈（虚拟机栈），记录线程和函数调用的基本信息。二者属于JVM的基础内容，此处不做介绍。</p>
</blockquote>
<p>当然，由于轻量级锁天然瞄准不存在锁竞争的场景，如果存在锁竞争但不激烈，仍然可以用自旋锁优化，<em>自旋失败后再膨胀为重量级锁</em>。</p>
<h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><p>同自旋锁相似：</p>
<ul>
<li>如果<em>锁竞争激烈</em>，那么轻量级将很快膨胀为重量级锁，那么维持轻量级锁的过程就成了浪费。</li>
</ul>
<h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><p>在没有实际竞争的情况下，还能够针对部分场景继续优化。如果不仅仅没有实际竞争，自始至终，使用锁的线程都只有一个，那么，维护轻量级锁都是浪费的。<strong>偏向锁的目标是，减少无竞争且只有一个线程使用锁的情况下，使用轻量级锁产生的性能消耗</strong>。轻量级锁每次申请、释放锁都至少需要一次CAS，但偏向锁只有初始化时需要一次CAS。</p>
<p>“偏向”的意思是，<em>偏向锁假定将来只有第一个申请锁的线程会使用锁</em>（不会有任何线程再来申请锁），因此，<em>只需要在Mark Word中CAS记录owner（本质上也是更新，但初始值为空），如果记录成功，则偏向锁获取成功</em>，记录锁状态为偏向锁，<em>以后当前线程等于owner就可以零成本的直接获得锁；否则，说明有其他线程竞争，膨胀为轻量级锁</em>。</p>
<p>偏向锁无法使用自旋锁优化，因为一旦有其他线程申请锁，就破坏了偏向锁的假定。</p>
<h3 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h3><p>同样的，如果明显存在其他线程申请锁，那么偏向锁将很快膨胀为轻量级锁。</p>
<blockquote>
<p>不过这个副作用已经小的多。</p>
<p>如果需要，使用参数-XX:-UseBiasedLocking禁止偏向锁优化（默认打开）。</p>
</blockquote>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-03-21</span><a class="tag" href="/categories/Java/" title="Java">Java </a><i class="fa fa-tag"></i><a class="tag" href="/tags/Java基础/" title="Java基础">Java基础 </a><span class="leancloud_visitors"></span><span>大约2377个字, 7分钟55秒读完</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/03/19/%E3%80%90Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%91606-%E6%A0%B9%E6%8D%AE%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%9B%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2/">【Leetcode刷题笔记】606 根据二叉树创建字符串</a></h3></div><div class="post-content"><div class="card"><p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>你需要采用前序遍历的方式，将一个二叉树转换成一个由括号和整数组成的字符串。</p>
<p>空节点则用一对空括号 “()” 表示。而且你需要省略所有不影响字符串与原始二叉树之间的一对一映射关系的空括号对。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入: 二叉树: [1,2,3,4]</span><br><span class="line">       1</span><br><span class="line">     /   \</span><br><span class="line">    2     3</span><br><span class="line">   /    </span><br><span class="line">  4     </span><br><span class="line"></span><br><span class="line">输出: &quot;1(2(4))(3)&quot;</span><br><span class="line"></span><br><span class="line">解释: 原本将是“1(2(4)())(3())”，</span><br><span class="line">在你省略所有不必要的空括号对之后，</span><br><span class="line">它将是“1(2(4))(3)”。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入: 二叉树: [1,2,3,null,4]</span><br><span class="line">       1</span><br><span class="line">     /   \</span><br><span class="line">    2     3</span><br><span class="line">     \  </span><br><span class="line">      4 </span><br><span class="line"></span><br><span class="line">输出: &quot;1(2()(4))(3)&quot;</span><br><span class="line"></span><br><span class="line">解释: 和第一个示例相似，</span><br><span class="line">除了我们不能省略第一个对括号来中断输入和输出之间的一对一映射关系。</span><br></pre></td></tr></table></figure>

<p>Related Topics</p>
<ul>
<li><p>树</p>
</li>
<li><p>深度优先搜索</p>
</li>
<li><p>字符串</p>
</li>
<li><p>二叉树</p>
</li>
</ul>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先要弄清楚不省略括号的情况是什么：</p>
<blockquote>
<p>当遍历到的空间点属于左节点，且其父节点的右节点不空，那这个空括号不可被省略</p>
</blockquote>
<p>搞清楚这一点就很好办了。但是有个问题出现了，题目要求采用前序遍历，先遍历左节点，后遍历右节点。是否添加空括号需要提前知道右节点是否为空这个信息。这样应该有多种解决方法。</p>
<p>我的解决方法是，把所有的空括号都添加进来，最后统一处理删除不必要的括号。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;String&gt; res;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">tree2str</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// 空括号存在的情况：左空右不空</span></span><br><span class="line">        <span class="comment">// 由于我们会先遍历左节点，所以加上一个标识符来判断左节点为空且右节点不为空</span></span><br><span class="line">        res=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        preTraversebTree(root);</span><br><span class="line">        StringBuilder ret=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">int</span> n=res.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>((res.get(i).equals(<span class="string">&quot;()&quot;</span>)&amp;&amp;i+<span class="number">1</span>&lt;n&amp;&amp;i+<span class="number">2</span>&lt;n&amp;&amp;res.get(i+<span class="number">1</span>).equals(<span class="string">&quot;(&quot;</span>)&amp;&amp;!res.get(i+<span class="number">1</span>).equals(<span class="string">&quot;)&quot;</span>))||!res.get(i).equals(<span class="string">&quot;()&quot;</span>))&#123;</span><br><span class="line">                ret.append(res.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">preTraversebTree</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            res.add(<span class="string">&quot;()&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">        res.add(String.valueOf(root.val));</span><br><span class="line">        preTraversebTree(root.left);</span><br><span class="line">        preTraversebTree(root.right);</span><br><span class="line">        res.add(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度：</strong></p>
<p>时间 O(n)</p>
<p>空间O(n)</p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-03-19</span><a class="tag" href="/categories/LeetCode/" title="LeetCode">LeetCode </a><i class="fa fa-tag"></i><a class="tag" href="/tags/刷题笔记/" title="刷题笔记">刷题笔记 </a><span class="leancloud_visitors"></span><span>大约566个字, 1分钟53秒读完</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/03/18/%E3%80%90Redis%E3%80%91%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">【Redis】源码分析（二） 数据类型源码分析</a></h3></div><div class="post-content"><div class="card"><p><h2 id="Redis-Rehashing过程"><a href="#Redis-Rehashing过程" class="headerlink" title="Redis Rehashing过程"></a>Redis Rehashing过程</h2><p>分析过程请看注释</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">dictRehash</span><span class="params">(dict *d, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// 空访问阈值</span></span><br><span class="line">    <span class="type">int</span> empty_visits = n*<span class="number">10</span>; <span class="comment">/* Max number of empty buckets to visit. */</span></span><br><span class="line">    <span class="comment">// 如果 rehashidx==-1 则没有在rehash，那就停止rehash</span></span><br><span class="line">    <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 如果rehash个数达到或者table[0]已经rehash完就结束while循环</span></span><br><span class="line">    <span class="keyword">while</span>(n-- &amp;&amp; d-&gt;ht_used[<span class="number">0</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">        dictEntry *de, *nextde;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Note that rehashidx can&#x27;t overflow as we are sure there are more</span></span><br><span class="line"><span class="comment">         * elements because ht[0].used != 0 */</span></span><br><span class="line">        assert(DICTHT_SIZE(d-&gt;ht_size_exp[<span class="number">0</span>]) &gt; (<span class="type">unsigned</span> <span class="type">long</span>)d-&gt;rehashidx);</span><br><span class="line">        <span class="comment">// 跳过空的dictEntry，如果空的个数达到阈值，则放弃rehashing</span></span><br><span class="line">        <span class="keyword">while</span>(d-&gt;ht_table[<span class="number">0</span>][d-&gt;rehashidx] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            d-&gt;rehashidx++;</span><br><span class="line">            <span class="keyword">if</span> (--empty_visits == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从非空rehash开始</span></span><br><span class="line">        de = d-&gt;ht_table[<span class="number">0</span>][d-&gt;rehashidx];</span><br><span class="line">        <span class="comment">/* Move all the keys in this bucket from the old to the new hash HT */</span></span><br><span class="line">        <span class="comment">// 如果de非空</span></span><br><span class="line">        <span class="keyword">while</span>(de) &#123;</span><br><span class="line">            <span class="type">uint64_t</span> h;</span><br><span class="line"></span><br><span class="line">            nextde = de-&gt;next;</span><br><span class="line">            <span class="comment">/* Get the index in the new hash table */</span></span><br><span class="line">            <span class="comment">// 计算新的hashkey</span></span><br><span class="line">            h = dictHashKey(d, de-&gt;key) &amp; DICTHT_SIZE_MASK(d-&gt;ht_size_exp[<span class="number">1</span>]);</span><br><span class="line">            <span class="comment">// de转移到新的table[1]上</span></span><br><span class="line">            de-&gt;next = d-&gt;ht_table[<span class="number">1</span>][h];</span><br><span class="line">            d-&gt;ht_table[<span class="number">1</span>][h] = de;</span><br><span class="line">            <span class="comment">// 旧表已用减少</span></span><br><span class="line">            d-&gt;ht_used[<span class="number">0</span>]--;</span><br><span class="line">            <span class="comment">// 新表医用增多</span></span><br><span class="line">            d-&gt;ht_used[<span class="number">1</span>]++;</span><br><span class="line">            de = nextde;</span><br><span class="line">        &#125;</span><br><span class="line">        d-&gt;ht_table[<span class="number">0</span>][d-&gt;rehashidx] = <span class="literal">NULL</span>;</span><br><span class="line">        d-&gt;rehashidx++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if we already rehashed the whole table... */</span></span><br><span class="line">    <span class="comment">// 如果已经rehash完所有，则释放table[0]的空间，并将table[1]移到tabke[0]</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht_used[<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">        zfree(d-&gt;ht_table[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">/* Copy the new ht onto the old one */</span></span><br><span class="line">        d-&gt;ht_table[<span class="number">0</span>] = d-&gt;ht_table[<span class="number">1</span>];</span><br><span class="line">        d-&gt;ht_used[<span class="number">0</span>] = d-&gt;ht_used[<span class="number">1</span>];</span><br><span class="line">        d-&gt;ht_size_exp[<span class="number">0</span>] = d-&gt;ht_size_exp[<span class="number">1</span>];</span><br><span class="line">        _dictReset(d, <span class="number">1</span>);</span><br><span class="line">        d-&gt;rehashidx = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* More to rehash... */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="List底层实现原理分析"><a href="#List底层实现原理分析" class="headerlink" title="List底层实现原理分析"></a>List底层实现原理分析</h2><p>List是一个有序的数据结构（按加入时序），Redis采用quicklist(双端链表)和ziplist(压缩列表)作为list的底层实现。其中ziplist作为节点存储在quicklist上，因而list的encoding是quicklist</p>
<p>可以通过设置每个Ziplist的最大容量，quickList(双端链表)的数据压缩范围，提升数据存储效率。</p>
<p><img src="/..%5Cimages%5Cziplist.png" alt="ziplist"></p>
<p><img src="/..%5Cimages%5Cquicklist.png" alt="quicklist"></p>
<blockquote>
<p>图片原作者：爱写代码的大曾（B站）</p>
</blockquote>
<h3 id="quickList"><a href="#quickList" class="headerlink" title="quickList"></a>quickList</h3><p>quickList是一个ziplist组成的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8&spm=1001.2101.3001.7020">双向链表</a>。每个节点使用ziplist来保存数据。本质上来说，quicklist里面保存着一个一个小的ziplist。</p>
<p><strong>结构</strong></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/32eeab930caa1aaa6faf4610a00bcdd2.png" alt="img"></p>
<p><strong>源码</strong></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> quicklistNode &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> quicklistNode *prev; <span class="comment">//上一个node节点</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> quicklistNode *next; <span class="comment">//下一个node</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *zl;            <span class="comment">//保存的数据 压缩前ziplist 压缩后压缩的数据</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> sz;             <span class="comment">/* ziplist size in bytes */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count : <span class="number">16</span>;     <span class="comment">/* count of items in ziplist */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> encoding : <span class="number">2</span>;   <span class="comment">/* RAW==1 or LZF==2 */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> container : <span class="number">2</span>;  <span class="comment">/* NONE==1 or ZIPLIST==2 */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> recompress : <span class="number">1</span>; <span class="comment">/* was this node previous compressed? */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> attempted_compress : <span class="number">1</span>; <span class="comment">/* node can&#x27;t compress; too small */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> extra : <span class="number">10</span>; <span class="comment">/* more bits to steal for future usage */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125; quicklistNode;</span><br></pre></td></tr></table></figure>

<ul>
<li>quickList就是一个标准的双向链表的配置，有head 有tail;</li>
<li>每一个节点是一个quicklistNode，包含prev和next指针。</li>
<li>每一个quicklistNode 包含 一个ziplist，*zp 压缩链表里存储键值。</li>
<li>所以quicklist是对ziplist进行一次封装，使用小块的ziplist来既保证了少使用内存，也保证了性能。</li>
</ul>
<p><strong>为什么不全部使用 ziplist呢？</strong></p>
<p>因为：ziplist存储在一段连续的内存上，所以存储效率很高。但是，它不利于修改操作，插入和删除操作需要频繁的申请和释放内存。特别是当ziplist长度很长的时候，一次realloc可能会导致大批量的数据拷贝。</p>
<h3 id="ziplist"><a href="#ziplist" class="headerlink" title="ziplist"></a>ziplist</h3><p>压缩列表 ziplist 是为 Redis 节约内存而开发的。ziplist 是由一系列特殊编码的内存块构成的列表(像内存连续的数组，但每个元素长度不同)， 一个 ziplist 可以包含多个节点（entry）。ziplist 将表中每一项存放在前后连续的地址空间内，每一项因占用的空间不同，而采用变长编码。</p>
<p>ziplist的主要优点是节省内存，但它上面的查找操作只能按顺序查找（可以是从前往后、也可以从后往前）。<br>ziplist将数据按照一定规则编码在一块连续的内存区域，目的是节省内存，这种结构并不擅长做修改操作。一旦数据发生改动，就会引发内存realloc，可能导致内存拷贝。</p>
<p><strong>ziplist 是一个特殊的双向链表</strong><br>特殊之处在于：没有维护双向指针:prev next；而是存储上一个 entry的长度和 当前entry的长度，通过长度推算下一个元素在什么地方。<br>牺牲读取的性能，获得高效的存储空间，因为(简短字符串的情况)存储指针比存储entry长度 更费内存。这是典型的“时间换空间”。</p>
<p><strong>ziplist使用局限性</strong><br>字段、值比较小，才会用ziplist。</p>
<p><strong>源码</strong></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> zlentry &#123;    <span class="comment">// 压缩列表节点</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> prevrawlensize, prevrawlen;    <span class="comment">// prevrawlen是前一个节点的长度，prevrawlensize是指prevrawlen的大小，有1字节和5字节两种</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> lensize, len;  <span class="comment">// len为当前节点长度 lensize为编码len所需的字节大小</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> headersize;    <span class="comment">// 当前节点的header大小</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> encoding; <span class="comment">// 节点的编码方式</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *p;   <span class="comment">// 指向节点的指针</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125; zlentry;</span><br></pre></td></tr></table></figure>

<p><strong>如何通过一个节点向前跳转到另一个节点？</strong><br>用指向当前节点的指针 e ， 减去 前一个 entry的长度， 得出的结果就是指向前一个节点的地址 p 。</p>
<p><strong>ziplist连锁更新问题</strong></p>
<p>因为在ziplist中，每个zlentry都存储着前一个节点所占的字节数，而这个数值又是<strong>变长编码</strong>的。假设存在一个压缩列表，其包含e1、e2、e3、e4…..，e1节点的大小为253字节，那么e2.prevrawlen的大小为1字节，如果此时在e2与e1之间插入了一个新节点e_new，e_new编码后的整体长度（包含e1的长度）为<strong>254字节</strong>，此时e2.prevrawlen就需要扩充为<strong>5字节</strong>；如果e2的整体长度变化又引起了e3.prevrawlen的存储长度变化，那么e3也需要扩…….如此递归直到表尾节点或者某一个节点的prevrawlen本身长度可以容纳前一个节点的变化。<strong>其中每一次扩充都需要进行空间再分配操作</strong>。删除节点亦是如此，只要引起了操作节点之后的节点的prevrawlen的变化，都可能引起连锁更新。</p>
<p>连锁更新在最坏情况下需要进行N次空间再分配，而每次空间再分配的最坏时间复杂度为O(N)，因此连锁更新的总体时间复杂度是O(N^2)。即使涉及连锁更新的时间复杂度这么高，但它能引起的性能问题的概率是极低的：需要列表中存在大量的节点长度接近254的zlentry。</p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-03-18</span><a class="tag" href="/categories/Redis/" title="Redis">Redis </a><i class="fa fa-tag"></i><a class="tag" href="/tags/源码分析/" title="源码分析">源码分析 </a><span class="leancloud_visitors"></span><span>大约1743个字, 5分钟48秒读完</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/03/18/%E3%80%90Redis%E3%80%91%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%E4%B8%BB%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/">【Redis】源码分析（一）主数据结构分析</a></h3></div><div class="post-content"><div class="card"><p><h2 id="Redis-String底层数据结构分析"><a href="#Redis-String底层数据结构分析" class="headerlink" title="Redis String底层数据结构分析"></a>Redis String底层数据结构分析</h2><p>Redis的String的数据类型可谓包罗万象，它既可以是一个简单的String，也可以是一个int型，还可以是float型，还可以是一张很大的图片，一首歌曲等。事实上所有的key都会在redis内部转换成一串不定长的字符串。当然，如果单纯用一串字符串来保存String那是不是效率太低了呢？试想一下，我有一个key长度为5，而另一个String长度为100000，那这两个String我应该怎么去分配他的空间呢？如果都用一个很大的空间去存储一个String，那效率就太低了。实际上，redis定义了一个名为<code>sds</code>的数据结构作为key的类型，先来看看他的源码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> *sds;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Note: sdshdr5 is never used, we just access the flags byte directly.</span></span><br><span class="line"><span class="comment"> * However is here to document the layout of type 5 SDS strings. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr5</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, and 5 msb of string length */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="type">uint8_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr16</span> &#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="type">uint16_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr32</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="type">uint32_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr64</span> &#123;</span></span><br><span class="line">    <span class="type">uint64_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="type">uint64_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>先从<code>sdshdr5</code>开始分析，<code>sdshdr5</code>中有两个变量，一个是flags，一个是buf。从注解中我们很容易可以看出，redis使用一个字节长度的<code>unsigned char</code>存储key的类型和长度，其中前三位为key的类型，即该key的数据结构是属于<code>sdshdr</code>中的哪一种，后五位为key的长度。而buf就是存储key的区域。</p>
<p>我们可以很容易推导出，sdshdr5可以存储$2^5-1&#x3D;31$位的数据。</p>
<p>当然，31位的长度显然是不够的，因而redis的设计者还设计了<code>sdshdr8,sdshdr16,sdshdr32,sdshdr64</code>这四种更长的sds类型。</p>
<p><strong>与sdshdr5不同的是</strong>，在后续的sds类型中，flag只表示类型（后5位不再使用）,而是使用一个符合长度需求的len来表示。</p>
<p>以下是sds中各个变量含义</p>
<table>
<thead>
<tr>
<th>变量名</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>len</td>
<td>sdshdr8以上使用len表示buf的长度</td>
</tr>
<tr>
<td>alloc</td>
<td>剩余可分配的buf长度</td>
</tr>
<tr>
<td>flag</td>
<td>sdshdr5使用flag来表示类型和长度，sdshdr8以上只表示类型</td>
</tr>
<tr>
<td>buf</td>
<td>实际存储key</td>
</tr>
</tbody></table>
<p><strong>ps:flag前五位的类型判断</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SDS_TYPE_5  0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SDS_TYPE_8  1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SDS_TYPE_16 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SDS_TYPE_32 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SDS_TYPE_64 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SDS_TYPE_MASK 7</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">size_t</span> <span class="title function_">sdslen</span><span class="params">(<span class="type">const</span> sds s)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags = s[<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">switch</span>(flags&amp;SDS_TYPE_MASK) &#123;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_5:</span><br><span class="line">            <span class="keyword">return</span> SDS_TYPE_5_LEN(flags);</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_8:</span><br><span class="line">            <span class="keyword">return</span> SDS_HDR(<span class="number">8</span>,s)-&gt;len;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_16:</span><br><span class="line">            <span class="keyword">return</span> SDS_HDR(<span class="number">16</span>,s)-&gt;len;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_32:</span><br><span class="line">            <span class="keyword">return</span> SDS_HDR(<span class="number">32</span>,s)-&gt;len;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_64:</span><br><span class="line">            <span class="keyword">return</span> SDS_HDR(<span class="number">64</span>,s)-&gt;len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Redis作者为了节省空间和提高性能所采取的办法和思想非常值得学习！</strong></p>
<h2 id="Redis-数据库源码分析"><a href="#Redis-数据库源码分析" class="headerlink" title="Redis 数据库源码分析"></a>Redis 数据库源码分析</h2><h3 id="数据库数据结构分析"><a href="#数据库数据结构分析" class="headerlink" title="数据库数据结构分析"></a>数据库数据结构分析</h3><p><img src="/..%5Cimages%5CRedisDB%E4%B8%BB%E4%BD%93%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="RedisDB主体数据结构"></p>
<blockquote>
<p>图片原作者：爱写代码的大曾（B站）</p>
</blockquote>
<h2 id="Redis-String-int-编码底层原理"><a href="#Redis-String-int-编码底层原理" class="headerlink" title="Redis String int 编码底层原理"></a>Redis String int 编码底层原理</h2><p>要分析Redis String和int的编码，需要把存储value的对象拿出来分析。以下是redis中存储value的对象-<code>redisObject</code>的源代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> type:<span class="number">4</span>; <span class="comment">// 数据类型 string,list,set,zset,hash...</span></span><br><span class="line">    <span class="type">unsigned</span> encoding:<span class="number">4</span>; <span class="comment">// 编码类型 </span></span><br><span class="line">    <span class="type">unsigned</span> lru:LRU_BITS; <span class="comment">/* LRU time (relative to global lru_clock) or</span></span><br><span class="line"><span class="comment">                            * LFU data (least significant 8 bits frequency</span></span><br><span class="line"><span class="comment">                            * and most significant 16 bits access time). */</span></span><br><span class="line">    <span class="type">int</span> refcount; <span class="comment">// 引用计数</span></span><br><span class="line">    <span class="type">void</span> *ptr;<span class="comment">// 指向存储value的指针</span></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>

<p>注意看源代码中的encoding变量，本节的主要任务就是分析它的作用。</p>
<p>首先来看redis中决定value编码的源代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">robj *<span class="title function_">tryObjectEncoding</span><span class="params">(robj *o)</span> &#123;</span><br><span class="line">	...</span><br><span class="line">        </span><br><span class="line">     <span class="comment">/* Check if we can represent this string as a long integer.</span></span><br><span class="line"><span class="comment">     * Note that we are sure that a string larger than 20 chars is not</span></span><br><span class="line"><span class="comment">     * representable as a 32 nor 64 bit integer. */</span></span><br><span class="line">    len = sdslen(s);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果value长度小于等于20以内，则有可能转换为整型值</span></span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">20</span> &amp;&amp; string2l(s,len,&amp;value)) &#123;</span><br><span class="line">        <span class="comment">/* This object is encodable as a long. Try to use a shared object.</span></span><br><span class="line"><span class="comment">         * Note that we avoid using shared integers when maxmemory is used</span></span><br><span class="line"><span class="comment">         * because every object needs to have a private LRU field for the LRU</span></span><br><span class="line"><span class="comment">         * algorithm to work well. */</span></span><br><span class="line">        <span class="keyword">if</span> ((server.maxmemory == <span class="number">0</span> ||</span><br><span class="line">            !(server.maxmemory_policy &amp; MAXMEMORY_FLAG_NO_SHARED_INTEGERS)) &amp;&amp;</span><br><span class="line">            value &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">            value &lt; OBJ_SHARED_INTEGERS)</span><br><span class="line">        &#123;</span><br><span class="line">            decrRefCount(o);</span><br><span class="line">            incrRefCount(shared.integers[value]);</span><br><span class="line">            <span class="keyword">return</span> shared.integers[value];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_RAW) &#123;</span><br><span class="line">                sdsfree(o-&gt;ptr);</span><br><span class="line">                o-&gt;encoding = OBJ_ENCODING_INT;</span><br><span class="line">                <span class="comment">// 将值本身赋给指针。</span></span><br><span class="line">                o-&gt;ptr = (<span class="type">void</span>*) value;</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_EMBSTR) &#123;</span><br><span class="line">                decrRefCount(o);</span><br><span class="line">                <span class="keyword">return</span> createStringObjectFromLongLongForValue(value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	....</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，redis对于String和int的处理是，<strong>如果String小于20</strong>，则可能可以用一个long类型来表示这个String。因而这时可以直接把指针的值作为value。因而我们在读这种数据时，直接读指针的值即可，不用再做一次IO去读取指针所指向的值。这样就又节省了空间和时间，提高了性能。</p>
<p>妙！</p>
<h2 id="Redis-EmdString"><a href="#Redis-EmdString" class="headerlink" title="Redis EmdString"></a>Redis EmdString</h2><p>在了解 <code>EmdStr</code>之前，我们需要先了解redisObject的大小。</p>
<ul>
<li>type:4 bit</li>
<li>encoding:4bit</li>
<li>lru:24bit</li>
<li>countRef:4 byte</li>
<li>void* 8byte</li>
</ul>
<p><strong>加起来16Bytes</strong></p>
<p>从前面贴出的源代码可知，一个redisObject的大小为16bytes，然而CPU从内存中取数据一次最少要取64bytes，那我取一个redisObject的话，相当于剩下的48byte都没用。这就产生了浪费。</p>
<p>redis作者为了把这一部分字节用起来，又设置了一种数据类型叫emdstr。顾名思义，这种string类型是嵌入到redisObject里面的。</p>
<p>接下来我们来看这段决定编码是不是EmdStr的代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_EMBSTR_SIZE_LIMIT 44</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* If the string is small and is still RAW encoded,</span></span><br><span class="line"><span class="comment"> * try the EMBSTR encoding which is more efficient.</span></span><br><span class="line"><span class="comment"> * In this representation the object and the SDS string are allocated</span></span><br><span class="line"><span class="comment"> * in the same chunk of memory to save space and cache misses. */</span></span><br><span class="line"><span class="keyword">if</span> (len &lt;= OBJ_ENCODING_EMBSTR_SIZE_LIMIT) &#123;</span><br><span class="line">    robj *emb;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_EMBSTR) <span class="keyword">return</span> o;</span><br><span class="line">    emb = createEmbeddedStringObject(s,sdslen(s));</span><br><span class="line">    decrRefCount(o);</span><br><span class="line">    <span class="keyword">return</span> emb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，当len&lt;&#x3D;44的时候，就采用emdstr去编码这个value。那为什么是44呢。因为这个时候value的数据结构是sdshdr5或者sdshdr8。而sdshdr5或者8的最大大小是4byte。那么除去者4byte，只剩下44byte了。这也就是为什么是44的原因。</p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-03-18</span><a class="tag" href="/categories/Redis/" title="Redis">Redis </a><i class="fa fa-tag"></i><a class="tag" href="/tags/源码分析/" title="源码分析">源码分析 </a><span class="leancloud_visitors"></span><span>大约1622个字, 5分钟24秒读完</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/03/17/%E3%80%90Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%91720%20%E8%AF%8D%E5%85%B8%E4%B8%AD%E6%9C%80%E9%95%BF%E7%9A%84%E5%8D%95%E8%AF%8D/">【Leetcode刷题笔记】720 词典中最长的单词</a></h3></div><div class="post-content"><div class="card"><p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul>
<li><p>给出一个字符串数组 <code>words</code> 组成的一本英语词典。返回 <code>words</code> 中最长的一个单词，该单词是由 <code>words</code> 词典中其他单词逐步添加一个字母组成。</p>
<p>若其中有多个可行的答案，则返回答案中字典序最小的单词。若无答案，则返回空字符串。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：words = [&quot;w&quot;,&quot;wo&quot;,&quot;wor&quot;,&quot;worl&quot;, &quot;world&quot;]</span><br><span class="line">输出：&quot;world&quot;</span><br><span class="line">解释： 单词&quot;world&quot;可由&quot;w&quot;, &quot;wo&quot;, &quot;wor&quot;, 和 &quot;worl&quot;逐步添加一个字母组成。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：words = [&quot;a&quot;, &quot;banana&quot;, &quot;app&quot;, &quot;appl&quot;, &quot;ap&quot;, &quot;apply&quot;, &quot;apple&quot;]</span><br><span class="line">输出：&quot;apple&quot;</span><br><span class="line">解释：&quot;apply&quot; 和 &quot;apple&quot; 都能由词典中的单词组成。但是 &quot;apple&quot; 的字典序小于 &quot;apply&quot; </span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= words.length &lt;= 1000</code></li>
<li><code>1 &lt;= words[i].length &lt;= 30</code></li>
<li>所有输入的字符串 <code>words[i]</code> 都只包含小写字母。</li>
</ul>
<p>Related Topics</p>
<p>字典树</p>
<p>数组</p>
<p>哈希表</p>
<p>字符串</p>
<p>排序</p>
</li>
</ul>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p><strong>前缀树</strong></p>
<p>前缀树：以空串为根节点，出现新的前缀则增加新的子节点。本题因为是针对单词，因而可以把children设置为长度为26的字符数组。更复杂的情况可能需要使用HashMap来处理。</p>
<p>注意题中要求，如果一个单词不是在已有前缀上增添一个新字母而产生的，则无效。因而我们在节点中增加一个新的值word，来代表是否有单词的终点为此节点。</p>
<p>这样做的好处是<strong>在搜索时，如果发现搜索的子节点的word属性为Null，说明该单词不是从已有的派生出来的</strong>，此时搜索可以直接返回false。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    String res;</span><br><span class="line">    TrieNode root;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestWord</span><span class="params">(String[] words)</span> &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">        root.word=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        res=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            <span class="type">TrieNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node.children[c - <span class="string">&#x27;a&#x27;</span>] == <span class="literal">null</span>) &#123;</span><br><span class="line">                    node.children[c - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                node = node.children[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            node.word=word;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(String word:words)&#123;</span><br><span class="line">            <span class="keyword">if</span>(search(word))&#123;</span><br><span class="line">                <span class="keyword">if</span>(word.length()&gt;res.length()||(word.length()==res.length())&amp;&amp;word.compareTo(res)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                    res=word;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        TrieNode node=root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c:prefix.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(node.children[c-<span class="string">&#x27;a&#x27;</span>].word==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node=node.children[c-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line">        TrieNode[] children = <span class="keyword">new</span> <span class="title class_">TrieNode</span>[<span class="number">26</span>];</span><br><span class="line">        String word;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度</strong></p>
<p>空间复杂度O(n) </p>
<p>时间复杂度O($\sum_{0}^{n-1}len(words[i]) $)</p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-03-17</span><a class="tag" href="/categories/LeetCode/" title="LeetCode">LeetCode </a><i class="fa fa-tag"></i><a class="tag" href="/tags/刷题笔记/" title="刷题笔记">刷题笔记 </a><span class="leancloud_visitors"></span><span>大约635个字, 2分钟7秒读完</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/03/15/%E3%80%90Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%912044%20%E7%BB%9F%E8%AE%A1%E6%8C%89%E4%BD%8D%E6%88%96%E8%83%BD%E5%BE%97%E5%88%B0%E6%9C%80%E5%A4%A7%E5%80%BC%E7%9A%84%E5%AD%90%E9%9B%86%E6%95%B0%E7%9B%AE/">【Leetcode刷题笔记】2044 统计按位或能得到最大值的子集数目</a></h3></div><div class="post-content"><div class="card"><p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul>
<li><p>给你一个整数数组 <code>nums</code> ，请你找出 <code>nums</code> 子集 <strong>按位或</strong> 可能得到的 <strong>最大值</strong> ，并返回按位或能得到最大值的 <strong>不同非空子集的数目</strong> 。</p>
<p>如果数组 <code>a</code> 可以由数组 <code>b</code> 删除一些元素（或不删除）得到，则认为数组 <code>a</code> 是数组 <code>b</code> 的一个 <strong>子集</strong> 。如果选中的元素下标位置不一样，则认为两个子集 <strong>不同</strong> 。</p>
<p>对数组 <code>a</code> 执行 <strong>按位或</strong> ，结果等于 <code>a[0] **OR** a[1] **OR** ... **OR** a[a.length - 1]</code>（下标从 <strong>0</strong> 开始）。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,1]</span><br><span class="line">输出：2</span><br><span class="line">解释：子集按位或能得到的最大值是 3 。有 2 个子集按位或可以得到 3 ：</span><br><span class="line">- [3]</span><br><span class="line">- [3,1]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,2,2]</span><br><span class="line">输出：7</span><br><span class="line">解释：[2,2,2] 的所有非空子集的按位或都可以得到 2 。总共有 23 - 1 = 7 个子集。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,1,5]</span><br><span class="line">输出：6</span><br><span class="line">解释：子集按位或可能的最大值是 7 。有 6 个子集按位或可以得到 7 ：</span><br><span class="line">- [3,5]</span><br><span class="line">- [3,1,5]</span><br><span class="line">- [3,2,5]</span><br><span class="line">- [3,2,1,5]</span><br><span class="line">- [2,5]</span><br><span class="line">- [2,1,5]</span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 16</code></li>
<li><code>1 &lt;= nums[i] &lt;= 105</code></li>
</ul>
</li>
</ul>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>解决此题需要解决两个主要问题：</p>
<ol>
<li>如何保证遍历到nums的所有子集</li>
<li>如何保证不重复</li>
</ol>
<p>我们知道，对于一个集合的所有子集，当集合添加了新的元素，其新子集等于在原子集上增添新的元素。然后对新子集依次按位或，统计和更新最大值和个数即可。这样做的时间复杂度是$O(2^n*n)$，这是第一种暴力解法。</p>
<p>分析可以发现，新子集的按位或结果，是原子集按位或结果再与新元素按位或后的结果。这个操作是$O(1)$的复杂度，因而总的时间复杂度可以优化到$O(2^n)$，对应法二的回溯法</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><strong>法一： 暴力</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> max;</span><br><span class="line">    <span class="type">int</span> res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countMaxOrSubsets</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 生成nums的所有子集</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; subsets = getSubsets(nums);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">getSubsets</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; allSubSets = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 空集</span></span><br><span class="line">        allSubSets.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        <span class="comment">// 每个元素可以与现有子集组合，生成res.size()个新子集</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> allSubSets.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                List&lt;Integer&gt; subset = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(allSubSets.get(i));</span><br><span class="line">                subset.add(num);</span><br><span class="line">                <span class="type">int</span> <span class="variable">or</span> <span class="operator">=</span> subset.stream().reduce(<span class="number">0</span>, (a, b) -&gt; a | b);</span><br><span class="line">                <span class="comment">// 如果or大于max，则更新max，重置res</span></span><br><span class="line">                <span class="comment">// 如果or等于max，则res++</span></span><br><span class="line">                <span class="keyword">if</span> (or &gt; max) &#123;</span><br><span class="line">                    max = or;</span><br><span class="line">                    res = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (or == max) &#123;</span><br><span class="line">                    res++;</span><br><span class="line">                &#125;</span><br><span class="line">                allSubSets.add(subset);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> allSubSets;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>法二：回溯</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> max;</span><br><span class="line">    <span class="type">int</span> res;</span><br><span class="line">    <span class="type">int</span>[] nums;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countMaxOrSubsets</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 生成nums的所有子集</span></span><br><span class="line">        <span class="built_in">this</span>.nums=nums;</span><br><span class="line">        backtrack(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 回溯</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> val,<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="comment">// 如果index等于nums.length时，则比较val与max的值</span></span><br><span class="line">        <span class="comment">// 二叉树保证不会产生重复的结果，但必须要遍历到最后一个节点</span></span><br><span class="line">        <span class="keyword">if</span>(nums.length==index)&#123;</span><br><span class="line">            <span class="keyword">if</span>(val&gt;max)&#123;</span><br><span class="line">                max=val;</span><br><span class="line">                res=<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(val==max)&#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        backtrack(val|nums[index],index+<span class="number">1</span>);</span><br><span class="line">        backtrack(val,index+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-03-15</span><a class="tag" href="/categories/LeetCode/" title="LeetCode">LeetCode </a><i class="fa fa-tag"></i><a class="tag" href="/tags/刷题笔记/" title="刷题笔记">刷题笔记 </a><span class="leancloud_visitors"></span><span>大约803个字, 2分钟40秒读完</span></div></div></div></div><div class="pagination"><ul class="clearfix"><li class="next pagbuttons"><a class="btn" role="navigation" href="/page/2/">下一页</a></li></ul></div></div></div></div><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/add-bookmark.js"></script><script>(function(window){var INSIGHT_CONFIG={TRANSLATION:{POSTS:"文章",PAGES:"页面",CATEGORIES:"分类",TAGS:"标签",UNTITLED:"(无标题)",},CONTENT_URL:"/content.json",};window.INSIGHT_CONFIG=INSIGHT_CONFIG})(window);</script><script src="/js/insight.js" defer></script><div class="searchbox ins-search"><div class="searchbox-container ins-search-container"><div class="searchbox-input-wrapper"><input class="searchbox-input ins-search-input" type="text" placeholder="想要查找什么..."><span class="searchbox-close"><a class="fa fa-times-circle" onclick="closeWindow();"></a></span></div><div class="searchbox-result-wrapper ins-section-wrapper"><div class="ins-section-container"><p>Seraching...</p></div></div></div></div><script src="/js/baidu-tongji.js"></script></body></html>