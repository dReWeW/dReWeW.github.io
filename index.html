<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Dalong"><title>Dalong's Blog</title><meta name="description" content="随便写写"><meta name="keywords" content="Blog,博客"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="shortcut icon" type="image/x-icon" href="/images/favicon.webp"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/insight.css"><link rel="stylesheet" href="/css/search.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script src="/js/jquery.js"></script><meta name="generator" content="Hexo 6.1.0"></head><body><div class="page-top animated fadeInDown"><div class="nav"><li> <a class="current" href="/">Home</a></li><li> <a href="/archives">Archives</a></li><li> <a href="/tags">Tags</a></li></div><div class="information"><div class="nav_right_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)" style="display:none;"> </a></li><li><a class="fa fa-search" onclick="openWindow();"></a></li></div><div class="avatar"><img src="/images/avatar.webp"></div></div></div><div class="sidebar animated fadeInDown"><div class="sidebar-top"><div class="logo-title"><div class="title"><img src="/images/avatar.webp" style="width:200px;" alt="favicon"><h3 title=""><a href="/">Dalong's Blog</a></h3><div class="description"><p>随便写写</p></div></div><ul class="social-links"><li><a target="_blank" rel="noopener" href="https://github.com/dReWeW"><i class="fa fa-github"></i></a></li><li><a href="mailto:dalongzd@qq.com"><i class="fa fa-envelope"></i></a></li><li><a target="_blank" rel="noopener" href="http://sighttp.qq.com/authd?IDKEY=569775346"><i class="fa fa-qq"></i></a></li></ul></div></div><div class="footer"><div class="p"> <span> 全站CC-BY-SA-3.0 </span><i class="fa fa-star"></i><span> Dalong</span></div><div class="by_farbox"><span>Powered by </span><a href="https://hexo.io/zh-cn/" target="_blank">Hexo </a><span> & </span><span>Anatolo </span></div><div class="beian"></div></div></div><div class="main"><div class="autopagerize_page_element"><div class="content"><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/03/22/%E3%80%90Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%912038-%E5%A6%82%E6%9E%9C%E7%9B%B8%E9%82%BB%E4%B8%A4%E4%B8%AA%E9%A2%9C%E8%89%B2%E5%9D%87%E7%9B%B8%E5%90%8C%E5%88%99%E5%88%A0%E9%99%A4%E5%BD%93%E5%89%8D%E9%A2%9C%E8%89%B2/">【Leetcode刷题笔记】2038 如果相邻两个颜色均相同则删除当前颜色</a></h3></div><div class="post-content"><div class="card"><p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>总共有 <code>n</code> 个颜色片段排成一列，每个颜色片段要么是 <code>&#39;A&#39;</code> 要么是 <code>&#39;B&#39;</code> 。给你一个长度为 <code>n</code> 的字符串 <code>colors</code> ，其中 <code>colors[i]</code> 表示第 <code>i</code> 个颜色片段的颜色。</p>
<p>Alice 和 Bob 在玩一个游戏，他们 <strong>轮流</strong> 从这个字符串中删除颜色。Alice <strong>先手</strong> 。</p>
<ul>
<li>如果一个颜色片段为 <code>&#39;A&#39;</code> 且 <strong>相邻两个颜色</strong> 都是颜色 <code>&#39;A&#39;</code> ，那么 Alice 可以删除该颜色片段。Alice <strong>不可以</strong> 删除任何颜色 <code>&#39;B&#39;</code> 片段。</li>
<li>如果一个颜色片段为 <code>&#39;B&#39;</code> 且 <strong>相邻两个颜色</strong> 都是颜色 <code>&#39;B&#39;</code> ，那么 Bob 可以删除该颜色片段。Bob <strong>不可以</strong> 删除任何颜色 <code>&#39;A&#39;</code> 片段。</li>
<li>Alice 和 Bob <strong>不能</strong> 从字符串两端删除颜色片段。</li>
<li>如果其中一人无法继续操作，则该玩家 <strong>输</strong> 掉游戏且另一玩家 <strong>获胜</strong> 。</li>
</ul>
<p>假设 Alice 和 Bob 都采用最优策略，如果 Alice 获胜，请返回 <code>true</code>，否则 Bob 获胜，返回 <code>false</code>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：colors = &quot;AAABABB&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">AAABABB -&gt; AABABB</span><br><span class="line">Alice 先操作。</span><br><span class="line">她删除从左数第二个 &#x27;A&#x27; ，这也是唯一一个相邻颜色片段都是 &#x27;A&#x27; 的 &#x27;A&#x27; 。</span><br><span class="line"></span><br><span class="line">现在轮到 Bob 操作。</span><br><span class="line">Bob 无法执行任何操作，因为没有相邻位置都是 &#x27;B&#x27; 的颜色片段 &#x27;B&#x27; 。</span><br><span class="line">因此，Alice 获胜，返回 true 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：colors = &quot;AA&quot;</span><br><span class="line">输出：false</span><br><span class="line">解释：</span><br><span class="line">Alice 先操作。</span><br><span class="line">只有 2 个 &#x27;A&#x27; 且它们都在字符串的两端，所以她无法执行任何操作。</span><br><span class="line">因此，Bob 获胜，返回 false 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：colors = &quot;ABBBBBBBAAA&quot;</span><br><span class="line">输出：false</span><br><span class="line">解释：</span><br><span class="line">ABBBBBBBAAA -&gt; ABBBBBBBAA</span><br><span class="line">Alice 先操作。</span><br><span class="line">她唯一的选择是删除从右数起第二个 &#x27;A&#x27; 。</span><br><span class="line"></span><br><span class="line">ABBBBBBBAA -&gt; ABBBBBBAA</span><br><span class="line">接下来轮到 Bob 操作。</span><br><span class="line">他有许多选择，他可以选择任何一个 &#x27;B&#x27; 删除。</span><br><span class="line"></span><br><span class="line">然后轮到 Alice 操作，她无法删除任何片段。</span><br><span class="line">所以 Bob 获胜，返回 false 。</span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= colors.length &lt;= 105</code></li>
<li><code>colors</code> 只包含字母 <code>&#39;A&#39;</code> 和 <code>&#39;B&#39;</code></li>
</ul>
<p>Related Topics</p>
<p>贪心</p>
<p>数学</p>
<p>字符串</p>
<p>博弈</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>遍历字符串，找出<code>Alice</code>和<code>Bob</code>分别长度大于3的子串，计算操作数即可。</p>
<p>写这么长纯粹为了降低执行耗时。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">winnerOfGame</span><span class="params">(String colors)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> colors.length();</span><br><span class="line">        <span class="type">char</span>[] array=colors.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">scoreA</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">// Alice&#x27;s score</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">scoreB</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">// Bob&#x27;s score</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> array[<span class="number">0</span>] == <span class="string">&#x27;A&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>;<span class="comment">// 0 - alice 1 - bob</span></span><br><span class="line">        <span class="type">int</span> tmpA=<span class="number">0</span>;<span class="comment">// accmulation of alice</span></span><br><span class="line">        <span class="type">int</span> tmpB=<span class="number">0</span>;<span class="comment">// accmulation of bob</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i]==<span class="string">&#x27;A&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(flag==<span class="number">0</span>)&#123;</span><br><span class="line">                    tmpA++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    tmpB=<span class="number">0</span>;</span><br><span class="line">                    tmpA=<span class="number">1</span>;</span><br><span class="line">                    flag=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(flag==<span class="number">1</span>)&#123;</span><br><span class="line">                    tmpB++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    tmpA=<span class="number">0</span>;</span><br><span class="line">                    tmpB=<span class="number">1</span>;</span><br><span class="line">                    flag=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tmpA&gt;=<span class="number">3</span>)&#123;</span><br><span class="line">                scoreA+=tmpA-<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tmpB&gt;=<span class="number">3</span>)&#123;</span><br><span class="line">                scoreB+=tmpB-<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> scoreA&gt;scoreB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n)</p>
<p>空间复杂度O(1&#x2F;n)</p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-03-22</span><a class="tag" href="/categories/LeetCode/" title="LeetCode">LeetCode </a><i class="fa fa-tag"></i><a class="tag" href="/tags/刷题笔记/" title="刷题笔记">刷题笔记 </a><span class="leancloud_visitors"></span><span>About731words, 2min26secread</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/03/22/%E3%80%90Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%912039-%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B2%E7%9A%84%E6%97%B6%E5%88%BB/">【Leetcode刷题笔记】2039 网络空闲的时刻</a></h3></div><div class="post-content"><div class="card"><p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个有 <code>n</code> 个服务器的计算机网络，服务器编号为 <code>0</code> 到 <code>n - 1</code> 。同时给你一个二维整数数组 <code>edges</code> ，其中 <code>edges[i] = [ui, vi]</code> 表示服务器 <code>ui</code> 和 <code>vi</code> 之间有一条信息线路，在 <strong>一秒</strong> 内它们之间可以传输 <strong>任意</strong> 数目的信息。再给你一个长度为 <code>n</code> 且下标从 <strong>0</strong> 开始的整数数组 <code>patience</code> 。</p>
<p>题目保证所有服务器都是 <strong>相通</strong> 的，也就是说一个信息从任意服务器出发，都可以通过这些信息线路直接或间接地到达任何其他服务器。</p>
<p>编号为 <code>0</code> 的服务器是 <strong>主</strong> 服务器，其他服务器为 <strong>数据</strong> 服务器。每个数据服务器都要向主服务器发送信息，并等待回复。信息在服务器之间按 <strong>最优</strong> 线路传输，也就是说每个信息都会以 <strong>最少时间</strong> 到达主服务器。主服务器会处理 <strong>所有</strong> 新到达的信息并 <strong>立即</strong> 按照每条信息来时的路线 <strong>反方向</strong> 发送回复信息。</p>
<p>在 <code>0</code> 秒的开始，所有数据服务器都会发送各自需要处理的信息。从第 <code>1</code> 秒开始，<strong>每</strong> 一秒最 <strong>开始</strong> 时，每个数据服务器都会检查它是否收到了主服务器的回复信息（包括新发出信息的回复信息）：</p>
<ul>
<li>如果还没收到任何回复信息，那么该服务器会周期性 <strong>重发</strong> 信息。数据服务器 <code>i</code> 每 <code>patience[i]</code> 秒都会重发一条信息，也就是说，数据服务器 <code>i</code> 在上一次发送信息给主服务器后的 <code>patience[i]</code> 秒 <strong>后</strong> 会重发一条信息给主服务器。</li>
<li>否则，该数据服务器 <strong>不会重发</strong> 信息。</li>
</ul>
<p>当没有任何信息在线路上传输或者到达某服务器时，该计算机网络变为 <strong>空闲</strong> 状态。</p>
<p>请返回计算机网络变为 <strong>空闲</strong> 状态的 <strong>最早秒数</strong> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/09/22/quiet-place-example1.png" alt="example 1"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">输入：edges = [[0,1],[1,2]], patience = [0,2,1]</span><br><span class="line">输出：8</span><br><span class="line">解释：</span><br><span class="line">0 秒最开始时，</span><br><span class="line">- 数据服务器 1 给主服务器发出信息（用 1A 表示）。</span><br><span class="line">- 数据服务器 2 给主服务器发出信息（用 2A 表示）。</span><br><span class="line"></span><br><span class="line">1 秒时，</span><br><span class="line">- 信息 1A 到达主服务器，主服务器立刻处理信息 1A 并发出 1A 的回复信息。</span><br><span class="line">- 数据服务器 1 还没收到任何回复。距离上次发出信息过去了 1 秒（1 &lt; patience[1] = 2），所以不会重发信息。</span><br><span class="line">- 数据服务器 2 还没收到任何回复。距离上次发出信息过去了 1 秒（1 == patience[2] = 1），所以它重发一条信息（用 2B 表示）。</span><br><span class="line"></span><br><span class="line">2 秒时，</span><br><span class="line">- 回复信息 1A 到达服务器 1 ，服务器 1 不会再重发信息。</span><br><span class="line">- 信息 2A 到达主服务器，主服务器立刻处理信息 2A 并发出 2A 的回复信息。</span><br><span class="line">- 服务器 2 重发一条信息（用 2C 表示）。</span><br><span class="line">...</span><br><span class="line">4 秒时，</span><br><span class="line">- 回复信息 2A 到达服务器 2 ，服务器 2 不会再重发信息。</span><br><span class="line">...</span><br><span class="line">7 秒时，回复信息 2D 到达服务器 2 。</span><br><span class="line"></span><br><span class="line">从第 8 秒开始，不再有任何信息在服务器之间传输，也不再有信息到达服务器。</span><br><span class="line">所以第 8 秒是网络变空闲的最早时刻。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/09/04/network_a_quiet_place_2.png" alt="example 2"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：edges = [[0,1],[0,2],[1,2]], patience = [0,10,10]</span><br><span class="line">输出：3</span><br><span class="line">解释：数据服务器 1 和 2 第 2 秒初收到回复信息。</span><br><span class="line">从第 3 秒开始，网络变空闲。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>n == patience.length</code></li>
<li><code>2 &lt;= n &lt;= 105</code></li>
<li><code>patience[0] == 0</code></li>
<li>对于 <code>1 &lt;= i &lt; n</code> ，满足 <code>1 &lt;= patience[i] &lt;= 105</code></li>
<li><code>1 &lt;= edges.length &lt;= min(105, n * (n - 1) / 2)</code></li>
<li><code>edges[i].length == 2</code></li>
<li><code>0 &lt;= ui, vi &lt; n</code></li>
<li><code>ui != vi</code></li>
<li>不会有重边。</li>
<li>每个服务器都直接或间接与别的服务器相连。</li>
</ul>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><blockquote>
<p>刚看此题的时候，我寻思这才中等题？后来仔细一看，题中的情况其实非常简单</p>
</blockquote>
<p>分析题干可知，一个主机的数据包到达服务器的事件是固定不变的，不受其他影响。</p>
<p>那我们假设主机到服务器的最短路径为<code>x</code>，那么从开始到收到确认包，就需要<code>2x</code>的时间。</p>
<p>那么确认一台主机多久会进入空闲状态只需要知道它最后一个数据包被确认的时间了。</p>
<p>我们已知在<code>2x</code>时刻，第一个数据包的ack到达主机，此时主机不会再重复发数据包，那么最后一个可能重复发数据包的时刻就是<code>2x-1</code>。</p>
<p>很容易可以推知$$ (2x-1)\ mod\ patience[i]&#x3D;&#x3D;0$$时，该时刻需要发最后一个数据包。</p>
<p>那如果不等于0呢？那就是最后一个数据包的当前位置了。</p>
<p>我们把等于0的情况看做最后一个数据包位于发送方主机的位置。那么可以推知，此时最后一个数据包收到确认的时间为 $$2x-1-(2x-1)mod\ patience[i]$$</p>
<p>因而最后一个数据包到达的时间为$4x-1-(2x-1)mod\ patience[i]+1$</p>
<p>又因为到达的下一时刻才会进入空闲，那么进入空闲的时间为 $4x-(2x-1)mod\ patience[i]$</p>
<p><strong>单源最短路径</strong></p>
<p>那么现在只需要算出每个主机距离服务器的最短距离，然后遍历获取最大值即可。这里使用dijkstra算法完成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">node</span> &#123;</span><br><span class="line">        <span class="type">int</span> index;</span><br><span class="line">        <span class="type">int</span> length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">node</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.index = index;</span><br><span class="line">            <span class="built_in">this</span>.length = length;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">networkBecomesIdle</span><span class="params">(<span class="type">int</span>[][] edges, <span class="type">int</span>[] patience)</span> &#123;</span><br><span class="line">        <span class="comment">// 先用Dijkstra算法做一下</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> patience.length;</span><br><span class="line">        <span class="type">int</span>[][] map = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="comment">// 初始化map所有初始值为Inf</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            Arrays.fill(map[i], Integer.MAX_VALUE);</span><br><span class="line">            map[i][i]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] edge : edges) &#123;</span><br><span class="line">            map[edge[<span class="number">0</span>]][edge[<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] dist = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Arrays.fill(dist, Integer.MAX_VALUE);</span><br><span class="line">        dist[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        Queue&lt;node&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>();</span><br><span class="line">        queue.add(<span class="keyword">new</span> <span class="title class_">node</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">boolean</span>[] vis=<span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">        vis[<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">node</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (map[cur.index][i] == <span class="number">1</span> &amp;&amp; !vis[i]&amp;&amp; dist[i] &gt; dist[cur.index] + <span class="number">1</span>) &#123;</span><br><span class="line">                    dist[i] = dist[cur.index] + <span class="number">1</span>;</span><br><span class="line">                    queue.add(<span class="keyword">new</span> <span class="title class_">node</span>(i, dist[i]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count == n - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 到这里已经算出了最短路径</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> num=<span class="number">4</span>*dist[i]-(<span class="number">2</span>*dist[i]-<span class="number">1</span>)%patience[i];</span><br><span class="line">            <span class="keyword">if</span>(num&gt;max)</span><br><span class="line">                max=num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Comparator&lt;node&gt; com = <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;node&gt;() &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(node o1, node o2)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> o1.length - o2.length;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度</strong></p>
<p>时间复杂度 最坏为O(n^2),最好为O(n)</p>
<p>空间复杂度O(n)</p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-03-22</span><a class="tag" href="/categories/LeetCode/" title="LeetCode">LeetCode </a><i class="fa fa-tag"></i><a class="tag" href="/tags/刷题笔记/" title="刷题笔记">刷题笔记 </a><span class="leancloud_visitors"></span><span>About1688words, 5min37secread</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/03/22/%E3%80%90Mysql%E3%80%91Mysql%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/">【Mysql】Mysql面试题整理</a></h3></div><div class="post-content"><div class="card"><p><h2 id="InnoDB中的B-树怎么产生的"><a href="#InnoDB中的B-树怎么产生的" class="headerlink" title="InnoDB中的B+树怎么产生的"></a>InnoDB中的B+树怎么产生的</h2><h3 id="page结构"><a href="#page结构" class="headerlink" title="page结构"></a>page结构</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9sZ05xVm50bHM3T2liaWFYSlBMSHl6aGVUc3B6QUFTVXhSUmgySXFJa2Rkb2JDUUc4WmdQRW1jb1lWNnpxMFRqVXV1TTJvWHZ2eVBDcVlpYjd3S2huNDRCUS82NDA?x-oss-process=image/format,png" alt="img"></p>
<p>InnoDB Page结构图</p>
<h4 id="1、File-Header结构，记录了page页的一些头信息，一共38字节"><a href="#1、File-Header结构，记录了page页的一些头信息，一共38字节" class="headerlink" title="1、File Header结构，记录了page页的一些头信息，一共38字节"></a>1、File Header结构，记录了page页的一些头信息，一共38字节</h4><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9sZ05xVm50bHM3T2liaWFYSlBMSHl6aGVUc3B6QUFTVXhSY2c5WHlkdG9GTk5VdEpsR29veGNURm5hR1JnZzJvN1FvOEU3aWJiRU9YZGRsazJ0QnQ4ZklpYWcvNjQw?x-oss-process=image/format,png" alt="img"></p>
<h5 id="innodb存储页类型"><a href="#innodb存储页类型" class="headerlink" title="innodb存储页类型"></a>innodb存储页类型</h5><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9sZ05xVm50bHM3T2liaWFYSlBMSHl6aGVUc3B6QUFTVXhSRTBaNWQ4ZVFjN2FlMDloVG5BcnRHeDhFOUZsZGdZM1kxVVhzQzl0ZGMzaWNxaGFYOFN5cVpjQS82NDA?x-oss-process=image/format,png" alt="img"></p>
<h4 id="2、page-header，记录页的状态信息，共56字节"><a href="#2、page-header，记录页的状态信息，共56字节" class="headerlink" title="2、page header，记录页的状态信息，共56字节"></a>2、page header，记录页的状态信息，共56字节</h4><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9sZ05xVm50bHM3T2liaWFYSlBMSHl6aGVUc3B6QUFTVXhSczBZTjBmWVFFZzB5REFqd1pyeHN6VXhZZTlSZUVHaGN0UGpRNm82cmI5QU5kVHNFWXBFQmx3LzY0MA?x-oss-process=image/format,png" alt="img"></p>
<h4 id="3、虚拟最大最小记录-Infimum-and-Supremum-Records"><a href="#3、虚拟最大最小记录-Infimum-and-Supremum-Records" class="headerlink" title="3、虚拟最大最小记录(Infimum and Supremum Records)"></a>3、虚拟最大最小记录(Infimum and Supremum Records)</h4><p>最大记录是这个数据页中逻辑上最大的记录，所有用户的记录都小于它。最小记录是数据页上最小的记录，所有用户记录都大于它。他们在数据页被创建的时候创建，而且不能被删除。引入他们主要是方便页内操作。</p>
<h4 id="4、用户记录"><a href="#4、用户记录" class="headerlink" title="4、用户记录"></a>4、用户记录</h4><p>用户所有插入的记录都存放在这里，默认情况下记录跟记录之间没有间隙，但是如果重用了已删除记录的空间，就会导致空间碎片。每个记录都有指向下一个记录的指针，但是没有指向上一个记录的指针。记录按照主键顺序排序。即，用户可以从数据页最小记录开始遍历，直到最大的记录，这包括了所有正常的记录和所有被delete-marked记录，但是不会访问到被删除的记录(PAGE_FREE)。</p>
<h4 id="5、Free-Space"><a href="#5、Free-Space" class="headerlink" title="5、Free Space"></a>5、Free Space</h4><p>从PAGEHEAPTOP开始，到最后一个数据目录，这之间的空间就是空闲空间，都被重置为0，当用户需要插入记录时候，首先在被删除的记录的空间中查找，如果没有找到合适的空间，就从这里分配。空间分配给记录后，需要递增PAGENRECS和PAGENHEAP。</p>
<h4 id="6、Page-Directory"><a href="#6、Page-Directory" class="headerlink" title="6、Page Directory"></a>6、Page Directory</h4><p>用户的记录是从低地址向高地址扩展，而数据目录则相反。在数据页被初始化的时候，就会在数据页最后(当然在checksum之前)创建两个数据目录，分别指向最大和最小记录。之后插入新的数据的时候，需要维护这个目录，例如必要的时候增加目录的个数。每个数据目录占用两个字节，存储对应记录的页内偏移量。假设目录N，这个目录N管理目录N-1(不包括)和目录N之间的记录，我们称目录N own 这些记录。在目录N指向的记录中，会有字段记录own记录的数量。由此可见，目录own的记录不能太多，因为太多的话，即意味着目录太过稀疏，不能很好的提高查询效率，但同时也不能own太少，这会导致目录数量变多，占用过多的空间。在InnoDB的实现中，目录own的记录数量在4-8之间，包括4和8，平均是6个记录。如果超过这个数量，就需要重新均衡目录的数量。目录的增加和删除可能需要进行内存拷贝，但是由于目录占用的总体空间很小，开销可以忽略不计。</p>
<h4 id="7、File-Trailer"><a href="#7、File-Trailer" class="headerlink" title="7、File Trailer"></a>7、File Trailer</h4><p>这个部分处于数据页最后的位置，只有8个字节。低地址的四个字节存储checksum的值，高地址的四个字节存储FILPAGELSN的低位四字节。注意这里的checksum的值不一定与FILPAGESPACEORCHKSUM的相同，这个依赖不同的checksum计算方法。</p>
<p>找到一张比较不错的page结构图</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9sZ05xVm50bHM3T2liaWFYSlBMSHl6aGVUc3B6QUFTVXhSalZYM0gwSk95ZktpYkNlYmNyS05rVGpUbzAyeElNdVhZamZMZEc3TDByRmVBZUxrajZUaWFpYmliZy82NDA?x-oss-process=image/format,png" alt="img"></p>
<h2 id="高度为3的B-树能存多少数据？"><a href="#高度为3的B-树能存多少数据？" class="headerlink" title="高度为3的B+树能存多少数据？"></a>高度为3的B+树能存多少数据？</h2><p>非叶子节点(4+6)&#x3D;10b</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line">    <span class="type">int</span>*children;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非叶子节点每页可以存16kb&#x2F;10b&#x3D;1638个节点</p>
<p>第二层可以有1638页，每页1638个节点</p>
<p>第三层为叶子节点，一页可以存16kb&#x2F;1kb&#x3D;16个</p>
<p>最终$1638<em>1638</em>16$个</p>
<h2 id="Innodb是如何支持范围查找能走索引的？"><a href="#Innodb是如何支持范围查找能走索引的？" class="headerlink" title="Innodb是如何支持范围查找能走索引的？"></a>Innodb是如何支持范围查找能走索引的？</h2><p>举个例子</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">index(a)</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> a<span class="operator">&gt;</span><span class="number">6</span>;</span><br></pre></td></tr></table></figure>

<p>内部执行过程是：先执行a&#x3D;6 找到6对应的值，然后返回后面的结果即可。</p>
<h2 id="为什么要遵守最左前缀才能利用到索引？"><a href="#为什么要遵守最左前缀才能利用到索引？" class="headerlink" title="为什么要遵守最左前缀才能利用到索引？"></a>为什么要遵守最左前缀才能利用到索引？</h2><p>最左前缀原则指的是，如果查询的时候查询条件精确匹配索引的左边连续一列或几列，则此列就可以被用到</p>
<p>如User表的name和city加联合索引就是(name,city)</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name<span class="operator">=</span>xx <span class="keyword">and</span> city<span class="operator">=</span>xx ; ／／可以命中索引</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name<span class="operator">=</span>xx ; <span class="operator">/</span><span class="operator">/</span> 可以命中索引</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> city<span class="operator">=</span>xx ; <span class="operator">/</span><span class="operator">/</span> 无法命中索引  </span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> city<span class="operator">=</span>xx <span class="keyword">and</span> name<span class="operator">=</span>xx ; ／／可以命中索引  </span><br><span class="line"> </span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> name <span class="keyword">is</span>  <span class="keyword">null</span>;<span class="operator">/</span><span class="operator">/</span>可以命中索引，使用<span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span> 会失效 </span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;zs&#x27;</span> <span class="keyword">and</span> address<span class="operator">=</span><span class="string">&#x27;beijing&#x27;</span>; <span class="operator">/</span><span class="operator">/</span>name用到了索引     </span><br></pre></td></tr></table></figure>

<h2 id="范围查找导致索引失效原理"><a href="#范围查找导致索引失效原理" class="headerlink" title="范围查找导致索引失效原理"></a>范围查找导致索引失效原理</h2><p>这种情况出现在辅助索引上。</p>
<p>考虑以下</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index(b,c,d) <span class="keyword">on</span> table1;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> table1 <span class="keyword">where</span> b<span class="operator">&gt;</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>这时候执行explain语句会发现mysql走了全表扫描。</p>
<p>这是因为mysql的辅助索引存储的具体的索引字段信息，而叶子节点存储主键索引+数据，为了要找到b&gt;1的数据，需要先在非聚集索引中找到对应的主键，再根据主键索引，查找对应的行数据，等于走了两遍B+树进行搜索，如果数据量接近全表数据量的话，比全表扫描还低，这时mysql就会走全表扫描。</p>
<h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><p>如果查询的字段，是已有的索引，且符合最左前缀原则，则可以直接走索引，这叫覆盖索引。</p>
<h2 id="索引扫描底层原则"><a href="#索引扫描底层原则" class="headerlink" title="索引扫描底层原则"></a>索引扫描底层原则</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">考虑如下</span><br><span class="line"><span class="keyword">create</span> index(b) <span class="keyword">on</span> table1;</span><br><span class="line"><span class="keyword">select</span> b <span class="keyword">from</span> table1;</span><br></pre></td></tr></table></figure>

<p>这时候主键索引会扫描更多数据，就会走索引。</p>
<h2 id="Order-By导致索引失效"><a href="#Order-By导致索引失效" class="headerlink" title="Order By导致索引失效"></a>Order By导致索引失效</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index(b,c,d) <span class="keyword">on</span> table1;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> table1 <span class="keyword">order</span> <span class="keyword">by</span> (a,b,c);</span><br></pre></td></tr></table></figure>

<p>此时如果数据量比较少的话，排序时间短，全表扫描快。如果数据量大，走索引会更快，虽然会回表，但比排序快。</p>
<h2 id="Mysql-数据类型转换有哪些需要注意"><a href="#Mysql-数据类型转换有哪些需要注意" class="headerlink" title="Mysql 数据类型转换有哪些需要注意"></a>Mysql 数据类型转换有哪些需要注意</h2><p>charset:字符集</p>
<p>collation:对应国家字符集的排序规则</p>
<p> mysql只把字符转成数字</p>
<h2 id="对字符进行操作索引失效的原理"><a href="#对字符进行操作索引失效的原理" class="headerlink" title="对字符进行操作索引失效的原理"></a>对字符进行操作索引失效的原理</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index(e) <span class="keyword">on</span> table1;<span class="operator">/</span><span class="operator">/</span> e为字符</span><br><span class="line"><span class="keyword">select</span> e <span class="keyword">from</span> <span class="keyword">where</span> e<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样会走全表扫描。因为mysql需要先把e字段所有数据转换成数字，然后比较。这样走全表扫描更方便。</p>
<h2 id="Mysql有哪些存储引擎"><a href="#Mysql有哪些存储引擎" class="headerlink" title="Mysql有哪些存储引擎"></a>Mysql有哪些存储引擎</h2><p><strong>InnoDB</strong>默认存储引擎，事务型存储引擎。设计用来处理大量短期事务。</p>
<p><strong>MyISAM</strong>5.1之前默认存储引擎，但不支持事务和行级锁，且崩溃后无法安全回复。</p>
<p><strong>Memory存储引擎</strong>比MyISAM快一个数量级。数据文件存在内存中，表结构在重启后保留，数据会丢失。一般保存中间数据。</p>
<p><strong>Archive引擎</strong>只支持INSERT和Select，会缓存所有的写并利用zlib对插入的行进行压缩。但每次SELECT都需要全表扫描。适合日志和数据采集。</p>
<p><strong>CSV引擎</strong>可以将普通的CSV文件作为Mysql表处理，但不支持索引。常作为数据交换。</p>
<h2 id="MyISAM和InnoDB区别（前innodb后myisam"><a href="#MyISAM和InnoDB区别（前innodb后myisam" class="headerlink" title="MyISAM和InnoDB区别（前innodb后myisam)"></a>MyISAM和InnoDB区别（前innodb后myisam)</h2><p>一个支持事务，一个不支持事务</p>
<p>一个锁最小粒度是行锁，一个是表锁</p>
<p>innodb不保存具体行数，而myisam保存，所以进行全表查询，myisam更快。</p>
<p>一个是聚集索引，一个是非聚集索引。myisam主键索引和辅助索引独立，但innodb是在一起的。</p>
<p>innodb支持外键，myisam不支持。</p>
<h2 id="字段优先级"><a href="#字段优先级" class="headerlink" title="字段优先级"></a>字段优先级</h2><p>优先使用长度短，定长的数值型字段。避免使用ZEROFILL</p>
<p>整形&gt;date,time&gt;enum char&gt;varchar&gt;blob,text</p>
<h2 id="Varchar-M-最多存储多少数据"><a href="#Varchar-M-最多存储多少数据" class="headerlink" title="Varchar(M)最多存储多少数据"></a>Varchar(M)最多存储多少数据</h2><p>最多存储65535字节(2^16-1)个字节</p>
<h2 id="事务并发引发的问题"><a href="#事务并发引发的问题" class="headerlink" title="事务并发引发的问题"></a>事务并发引发的问题</h2><p><strong>脏读</strong>事务A读取到事务B未提交的数据</p>
<p><strong>不可重复读</strong>事务A读了两次a，但两次读之间事务B修改了数据a，导致事务B在两次读取出来的数据不一致。</p>
<p><strong>幻读</strong>与不可重复读类似，但第二次读到了事务A增加出来的新数据，而不是修改了的数据a</p>
<h2 id="简单描述Mysql索引"><a href="#简单描述Mysql索引" class="headerlink" title="简单描述Mysql索引"></a>简单描述Mysql索引</h2><p>按字段 主键，唯一索引，普通，前缀索引</p>
<p>其中前缀索引是对二进制类型字段或者字符串类型的前几个字符简历索引。</p>
<h2 id="三星索引"><a href="#三星索引" class="headerlink" title="三星索引"></a>三星索引</h2><p> 一个查询相关的索引行是相邻的或者至少相距足够靠近，则一星</p>
<p>如果索引中数据顺序和查找中排列顺序一直，则二星</p>
<p>如果索引中的列包含了查询需要的全部列则三星。</p>
<h2 id="Mysql存放多少行"><a href="#Mysql存放多少行" class="headerlink" title="Mysql存放多少行"></a>Mysql存放多少行</h2><p>2千多万行</p>
<h2 id="提高Insert性能"><a href="#提高Insert性能" class="headerlink" title="提高Insert性能"></a>提高Insert性能</h2><p>多条合并为一条 </p>
<p>调大大批量插入的缓存大小</p>
<p>手动使用事务 默认一次提交一条，可以手动设置为1000条提交一次事务</p>
<h2 id="全局锁、共享锁、排它锁"><a href="#全局锁、共享锁、排它锁" class="headerlink" title="全局锁、共享锁、排它锁"></a>全局锁、共享锁、排它锁</h2><p>全局锁，全局被锁，数据库只读</p>
<p><strong>共享锁</strong>其他事务可并发读。如果事务多读锁进行修改，容易死锁</p>
<p><strong>排它锁</strong>只能事务A读写数据，其他事务只能读。排它锁会阻塞所有排它锁和共享锁。</p>
<h2 id="Mysql-读写分离"><a href="#Mysql-读写分离" class="headerlink" title="Mysql 读写分离"></a>Mysql 读写分离</h2><p>主库写，从库读</p>
<p>关于主从库数据同步，依赖于binlog日志文件，只记录修改操作。</p>
<p>主从结构中，从库会复制一份binlog，然后写一份relay log（中继日志）。启动一个sql线程，执行binlog里的insert和update，这样主从库数据同步。</p>
<h2 id="Mysql分库分表"><a href="#Mysql分库分表" class="headerlink" title="Mysql分库分表"></a>Mysql分库分表</h2><p>水平拆分 - hash原理 （uid%size)&#x3D;hashcode</p>
<p>根据时间拆分 </p>
<h2 id="聚簇索引和非聚簇索引"><a href="#聚簇索引和非聚簇索引" class="headerlink" title="聚簇索引和非聚簇索引"></a>聚簇索引和非聚簇索引</h2><p>聚簇索引：数据和索引放一块儿，找到索引就找到数据，且数据的物理存放顺序和索引顺序一直</p>
<p>非聚簇索引：叶子节点不存储数据，存储的数据行的地址。</p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-03-22</span><a class="tag" href="/categories/面试/" title="面试">面试 </a><i class="fa fa-tag"></i><a class="tag" href="/tags/mysql/" title="mysql">mysql </a><span class="leancloud_visitors"></span><span>About2682words, 8min56secread</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/03/21/%E3%80%90Java%E3%80%91Java%E6%9C%89%E5%93%AA%E4%BA%9B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/">【Java】Java有哪些类加载器</a></h3></div><div class="post-content"><div class="card"><p><h2 id="什么是classloader"><a href="#什么是classloader" class="headerlink" title="什么是classloader"></a>什么是classloader</h2><p>classloader顾名思义，即是类加载。虚拟机把描述类的数据从class字节码文件加载到内存，并对数据进行检验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。了解java的类加载机制，可以快速解决运行时的各种加载问题并快速定位其背后的本质原因，也是解决疑难杂症的利器。因此学好类加载原理也至关重要。</p>
<h2 id="classloader的加载过程"><a href="#classloader的加载过程" class="headerlink" title="classloader的加载过程"></a>classloader的加载过程</h2><p>类从被加载到<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:1739289578%7D">虚拟机内存</a>到被卸载，整个完整的生命周期包括：类加载、验证、准备、解析、初始化、使用和卸载七个阶段。其中验证，准备，解析三个部分统称为连接。接下来我们可以详细了解下类加载的各个过程。</p>
<p><img src="https://pic3.zhimg.com/50/v2-071d6fa5c0aefe61c363bc94b6b5b286_720w.jpg?source=1940ef5c" alt="img"><img src="https://pic3.zhimg.com/80/v2-071d6fa5c0aefe61c363bc94b6b5b286_720w.jpg?source=1940ef5c" alt="img"></p>
<p>classloader的整个加载过程还是非常复杂的，具体的细节可以参考《<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:1739289578%7D">深入理解java虚拟机</a>》进行深入了解。为了方便记忆，我们可以使用一句话来表达其加载的整个过程，“家宴准备了西式菜”，即家(加载)宴(验证)准备(准备)了西(解析)式(初始化)菜。保证你以后能够很快的想起来。<br>虽然classloader的加载过程有复杂的5步，但事实上除了加载之外的四步，其它都是由JVM虚拟机控制的，我们除了适应它的规范进行开发外，能够干预的空间并不多。而加载则是我们控制classloader实现特殊目的最重要的手段了。也是接下来我们介绍的重点了。</p>
<h2 id="classloader双亲委托机制"><a href="#classloader双亲委托机制" class="headerlink" title="classloader双亲委托机制"></a>classloader双亲委托机制</h2><p>classloader的双亲委托机制是指多个类加载器之间存在父子关系的时候，某个class类具体由哪个加载器进行加载的问题。其具体的过程表现为：当一个类加载的过程中，它首先不会去加载，而是委托给自己的父类去加载，父类又委托给自己的父类。因此所有的类加载都会委托给顶层的父类，即Bootstrap Classloader进行加载，然后父类自己无法完成这个加载请求，子加载器才会尝试自己去加载。使用双亲委派模型，Java类随着它的加载器一起具备了一种带有优先级的层次关系，通过这种<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E5%B1%82%E6%AC%A1%E6%A8%A1%E5%9E%8B&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:1739289578%7D">层次模型</a>，可以避免类的重复加载，也可以避免核心类被不同的类加载器加载到内存中造成冲突和混乱，从而保证了Java核心库的安全。</p>
<p><img src="https://pic1.zhimg.com/50/v2-eafe30b56d52cc526d6da75430807390_720w.jpg?source=1940ef5c" alt="img"><img src="https://pic1.zhimg.com/80/v2-eafe30b56d52cc526d6da75430807390_720w.jpg?source=1940ef5c" alt="img"></p>
<p>整个java虚拟机的类加载层次关系如上图所示，启动类加载器(Bootstrap Classloader)负责将<JAVA_HOME>&#x2F;lib目录下并且被虚拟机识别的类库加载到虚拟机内存中。我们常用基础库，例如java.util.**，java.io.**，java.lang.**等等都是由根加载器加载。</p>
<p>扩展类加载器(Extention Classloader)负责加载JVM扩展类，比如swing系列、内置的js引擎、xml解析器等，这些类库以javax开头，它们的jar包位于<JAVA_HOME>&#x2F;lib&#x2F;ext目录中。</p>
<p>应用程序加载器(Application Classloader)也叫系统类加载器，它负责加载用户路径(ClassPath)上所指定的类库。我们自己编写的代码以及使用的第三方的jar包都是由它来加载的自定义加载器(Custom Classloader)通常是我们为了某些特殊目的实现的自定义加载器，后面我们得会详细介绍到它的作用以及使用场景。</p>
<p>双亲委托机制看起来比较复杂，但是其本身的核心代码逻辑却是非常的清晰简单，我们着重抽取了类加载的双亲委托的核心代码如下，不过二十行左右。</p>
<p><img src="https://pic1.zhimg.com/50/v2-d2b2276905548a42a329ca52e4444dfc_720w.jpg?source=1940ef5c" alt="img"><img src="https://pic1.zhimg.com/80/v2-d2b2276905548a42a329ca52e4444dfc_720w.jpg?source=1940ef5c" alt="img"></p>
<h2 id="classloader的应用场景"><a href="#classloader的应用场景" class="headerlink" title="classloader的应用场景"></a>classloader的应用场景</h2><p>类加载器是java语言的一项创新，也是java语言流行的重要原因这一。通过灵活定义classloader的加载机制，我们可以完成很多事情，例如解决类冲突问题，实现热加载以及热部署，甚至可以实现jar包的加密保护。接下来，我们会针对这些特殊场景进行逐一介绍。</p>
<blockquote>
<p> 作者：阿里巴巴淘系技术<br>链接：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/46719811/answer/1739289578">https://www.zhihu.com/question/46719811/answer/1739289578</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-03-21</span><a class="tag" href="/categories/Java/" title="Java">Java </a><i class="fa fa-tag"></i><a class="tag" href="/tags/Java基础/" title="Java基础">Java基础 </a><span class="leancloud_visitors"></span><span>About1256words, 4min11secread</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/03/21/%E3%80%90Spring%E3%80%91Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/">【Spring】Spring源码分析（一）</a></h3></div><div class="post-content"><div class="card"><p><h4 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h4><p><strong>IOC与DI</strong></p>
<p>IOC 控制反转，一种思想。依赖注入，一种手段。</p>
<p><strong>IOC</strong>是控制反转的意思，这是一种面向对象编程的设计思想。在不采用这种思想的情况下，我们需要自己维护对象与对象之间的依赖关系，很容易造成对象之间的耦合度过高，在一个大型的项目中这十分的不利于代码的维护。IoC则可以解决这种问题，它可以帮我们维护对象与对象之间的依赖关系，降低对象之间的耦合度。</p>
<p><strong>DI</strong>是依赖注入的意思，它是IoC实现的实现方式，就是说IoC是通过DI来实现的。由于IoC这个词汇比较抽象而DI却更直观，所以很多时候我们就用DI来代替它，在很多时候我们简单地将IoC和DI划等号，这是一种习惯。而实现依赖注入的关键是IoC容器，它的本质就是一个工厂。</p>
<p><strong>xml里配置bean</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">?</span> <span class="attr">class</span>=<span class="string">?</span> <span class="attr">abstract</span> <span class="attr">init-method</span> <span class="attr">scope</span> <span class="attr">dependon...</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">?</span> <span class="attr">value</span>=<span class="string">?/</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">?</span> <span class="attr">value</span>=<span class="string">?/</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>Java里获取bean</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Application ac=<span class="keyword">new</span>;</span><br><span class="line">ClassPathXmlApplicationContext(<span class="string">&quot;applicationContent.xml&quot;</span>);</span><br><span class="line">XXX xxx=ac.getBean(XXX.class);</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 从xml配置到bean发生了什么？</p>
</blockquote>
<p>LoadXml-&gt;ParseXml-&gt;封装BeanDefinition-&gt;实例化(使用反射而非<code>new</code>)-&gt;放入容器中-&gt;从容器中获取</p>
<ul>
<li>不只xml可以配置bean,如properties groovy也可以配置bean</li>
<li>从配置文件到生成beanDefinition,解析器需要实现<code>BeanDefinitionReader</code> 接口。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanDefinitionReader</span></span><br></pre></td></tr></table></figure>

<ul>
<li>理解实例化的过程需要先了解反射，这里简单复习一下Java反射机制</li>
</ul>
<p><strong>反射获取类对象的几种方式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class.forName();</span><br><span class="line">对象.getClass();</span><br><span class="line">类名.class();</span><br></pre></td></tr></table></figure>
<p>一些示例代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;TreeNode&quot;</span>);</span><br><span class="line">       Constructor[] constructors= clazz.getConstructors();</span><br><span class="line">       <span class="keyword">for</span> (Constructor constructor : constructors) &#123;</span><br><span class="line">           System.out.println(constructor);</span><br><span class="line">       &#125;</span><br><span class="line">       constructors=clazz.getDeclaredConstructors();</span><br><span class="line">       <span class="keyword">for</span> (Constructor constructor : constructors) &#123;</span><br><span class="line">           System.out.println(constructor);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 由于无参构造函数是私有的，而getConstructor只能获取公有的，所以会抛出异常</span></span><br><span class="line">       <span class="comment">// Constructor con=clazz.getConstructor(null);</span></span><br><span class="line">       <span class="comment">// System.out.println(con);</span></span><br><span class="line">       Constructor con=clazz.getConstructor(<span class="type">int</span>.class);</span><br><span class="line">       System.out.println(con);</span><br><span class="line"></span><br><span class="line">       TreeNode root= (TreeNode) con.newInstance(<span class="number">1</span>);</span><br><span class="line">       Field field=clazz.getDeclaredField(<span class="string">&quot;val&quot;</span>);</span><br><span class="line">       field.set(root, <span class="number">2</span>);</span><br><span class="line">       System.out.println(root.val);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 输出object mark word</span></span><br><span class="line">       </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>实例化的过程包括实例化和初始化<ul>
<li>注意 实例化和初始化不能等同来看</li>
<li><strong>实例化</strong>是给对象在堆中开辟一块空间，对象属性值都是默认值</li>
<li>而<strong>初始化</strong>是填充属性，设置Aware接口的属性，并执行init-method</li>
</ul>
</li>
</ul>
<h4 id="关于Bean的生命周期"><a href="#关于Bean的生命周期" class="headerlink" title="关于Bean的生命周期"></a><strong>关于Bean的生命周期</strong></h4><p>Spring容器管理Bean，涉及对Bean的创建、初始化、调用、销毁等一系列的流程，这个流程就是Bean的生命周期。整个流程参考下图：</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20220224/4107856_1645694380479/7EF8F66C3DFA7434E4CA11B47CF8F1F7" alt="img"></p>
<ol>
<li>在Bean 先要调用构造器完成实例化。</li>
<li>接下来是初始化的过程</li>
</ol>
<p>注意，这里的<code>postProcessorAfterInitialization和postProcessorBeforeInitialization</code>使用了AOP</p>
<p><strong>AOP实现的两种方法</strong></p>
<ul>
<li>DK动态代理：这是Java提供的动态代理技术，可以在运行时创建接口的代理实例。Spring AOP默认采用这种方式，在接口的代理实例中织入代码。</li>
<li>CGLib动态代理：采用底层的字节码技术，在运行时创建子类代理的实例。当目标对象不存在接口时，Spring AOP就会采用这种方式，在子类实例中织入代码。</li>
</ul>
<h5 id="Spring-Aware"><a href="#Spring-Aware" class="headerlink" title="Spring Aware"></a>Spring Aware</h5><blockquote>
<p>顾名思义，Spring Bean Aware 就是帮助bean感知Spring容器的存在。这会增加Bean与IOC容器的耦合。</p>
</blockquote>
<p>常见的 Spring Aware 接口</p>
<table>
<thead>
<tr>
<th align="left">Aware子接口</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">BeanNameAware</td>
<td align="left">获取容器中 Bean 的名称</td>
</tr>
<tr>
<td align="left">BeanFactoryAware</td>
<td align="left">获取当前 BeanFactory ，这样可以调用容器的服务</td>
</tr>
<tr>
<td align="left">ApplicationContextAware</td>
<td align="left">同上，在<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/YVl20QqUHTXMubr68wXR1A">BeanFactory 和 ApplicationContext 的区别</a> 中已明确说明</td>
</tr>
<tr>
<td align="left">MessageSourceAware</td>
<td align="left">获取 Message Source 相关文本信息</td>
</tr>
<tr>
<td align="left">ApplicationEventPublisherAware</td>
<td align="left">发布事件</td>
</tr>
<tr>
<td align="left">ResourceLoaderAware</td>
<td align="left">获取资源加载器，这样获取外部资源文件</td>
</tr>
</tbody></table>
<p>来看类关系图：<br><img src="http://rgyb.sunluomeng.top/%E5%85%AC%E4%BC%97%E8%B4%A6%E5%8F%B7%E6%96%87%E7%AB%A0/%E5%BA%94%E7%94%A8%E7%B1%BB%E6%96%87%E7%AB%A0/_image/2019-07-03/Xnip2019-07-03_14-39-56.jpg" alt="img"></p>
<p>当然不止以上这些 Aware， 通常使用 Spring Aware 的目的是为了让 Bean 获得 Spring 容器的服务。比如，通过Aware，可以通过当前对象，获取容器中其他所有对象。(有点反射那种思想)</p>
<h4 id="Spring中的观察者模式"><a href="#Spring中的观察者模式" class="headerlink" title="Spring中的观察者模式"></a>Spring中的观察者模式</h4><p>观察者模式的应用：监听器，监听事件，多播器</p>
<p>如监听Spring容器创建完成的观察者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">onRefresh();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">registerListeners();</span><br></pre></td></tr></table></figure>

<p><strong>BeanFactory和FactoryBean的区别</strong></p>
<p>都是用来创建对象的，当使用BeanFactory的时候必须要遵循完整的创建过程，这个过程是由spring来管理控制的。而使用FactoryBean只需要调用getObject就可以返回具体的对象，整个对象的创建过程是由用户自己来控制的，更加灵活。</p>
<p><strong>PostProcessor</strong></p>
<ul>
<li><code>BeanFactorPostProcessor</code> BeanDefinition增强器接口，自定义的PostProcessor需要实现它</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">myBeanFactoryPoProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanFactoryPostProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;myBeanFactoryPoProcessor&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>BeanProcessor</code>Bean的增强器接口，自定义的PostProcessor需要实现它</li>
</ul>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-03-21</span><a class="tag" href="/categories/Spring/" title="Spring">Spring </a><i class="fa fa-tag"></i><a class="tag" href="/tags/源码分析/" title="源码分析">源码分析 </a><span class="leancloud_visitors"></span><span>About1330words, 4min26secread</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/03/21/%E3%80%90%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/">【并发编程】高并发秒杀系统架构设计</a></h3></div><div class="post-content"><div class="card"><p><blockquote>
<p>以下内容为马士兵老师的Java并发编程中高并发秒杀系统架构实战的听课笔记</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1aS4y1R7UW?p=7">【马士兵教育】首次深入计算机底层原理透彻解析Java并发编程，JUC并发编程，多线程，高并发秒杀方案全套教程（合集）_哔哩哔哩_bilibili</a></p>
</blockquote>
<h3 id="CAP定理"><a href="#CAP定理" class="headerlink" title="CAP定理"></a>CAP定理</h3><p>CAP原则又称CAP定理，指的是在一个分布式系统中， Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可得兼。</p>
<ul>
<li><strong>一致性（C）</strong>：在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本）</li>
<li><strong>可用性（A）</strong>：保证每个请求不管成功或者失败都有响应。</li>
<li><strong>分区容忍性（P）</strong>：系统中任意信息的丢失或失败不会影响系统的继续运作。</li>
</ul>
<p><strong>关于分区容忍性的理解：</strong> 分区容忍性是指当系统发生故障时，是否可以继续正常运作。如，两台服务器之间的网线断开了，无法进行信息交换，如果这时系统能够容忍这样的故障发生并且继续运行，则叫分区容忍性。</p>
<p><strong>为什么不能同时满足的通俗理解</strong></p>
<ol>
<li>满足C和A，那么P能不能满足呢？</li>
</ol>
<p>满足C需要所有的服务器的数据要一样，也就是说要实现数据的同步，那么同步要不要时间？肯定是要的，并且机器越多，同步的时间肯定越慢，这里问题就来了，我们同时也满足了A，也就是说，我要同步时间短才行。这样的话，机器就不能太多了，也就是说P是满足不了的</p>
<ol start="2">
<li>满足C和P，那么A能不能满足呢？</li>
</ol>
<p>满足P需要很多服务器，假设有1000台服务器，同时满足了C，也就是说要保证每台机器的数据都一样，那么同步的时间可就很大，在这种情况下，我们肯定是不能保证用户随时访问每台服务器获取到的数据都是最新的，想要获取最新的，可以，你就等吧，等全部同步完了，你就可以获取到了，但是我们的A要求短时间就可以拿到想要的数据啊，这不就是矛盾了，所以说这里A是满足不了了</p>
<ol start="3">
<li>满足A和P，那么C能不能满足呢？</li>
</ol>
<p>满足P的话，需要多台服务器，而满足C的话，只有一台服务器才可以满足，这和P矛盾。</p>
<h3 id="12306的问题"><a href="#12306的问题" class="headerlink" title="12306的问题"></a>12306的问题</h3><ol>
<li>强一致性带来的难题 - 递归循环锁<ul>
<li>解决： 分布式一致性哈希环，防止一个节点存全量数据，只存和处理一部分数据。</li>
<li>降低一致性增强可用性</li>
<li>异步通讯，慢慢完成数据一致性。（前端一致，后端不一致）</li>
<li></li>
</ul>
</li>
</ol>
<h3 id="Base理论"><a href="#Base理论" class="headerlink" title="Base理论"></a>Base理论</h3><p>BASE理论是Basically Available(基本可用)，Soft State（软状态）和Eventually Consistent（最终一致性）三个短语的缩写。</p>
<p>核心思想：</p>
<blockquote>
<p>既是无法做到强一致性（Strong consistency），但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）。</p>
</blockquote>
<h4 id="基本可用"><a href="#基本可用" class="headerlink" title="基本可用"></a>基本可用</h4><p>什么是基本可用呢？假设系统，出现了不可预知的故障，但还是能用，相比较正常的系统而言：</p>
<p><strong>响应时间上的损失</strong>：正常情况下的搜索引擎0.5秒即返回给用户结果，而基本可用的搜索引擎可以在2秒作用返回结果。</p>
<p><strong>功能上的损失</strong>：在一个电商网站上，正常情况下，用户可以顺利完成每一笔订单。但是到了大促期间，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面。3.2. 软状态</p>
<h4 id="软状态"><a href="#软状态" class="headerlink" title="软状态"></a>软状态</h4><p>什么是软状态呢？相对于原子性而言，要求多个节点的数据副本都是一致的，这是一种“硬状态”。</p>
<p>软状态指的是：允许系统中的数据存在中间状态，并认为该状态不影响系统的整体可用性，即允许系统在多个不同节点的数据副本存在数据延时。</p>
<h4 id="最终一致性"><a href="#最终一致性" class="headerlink" title="最终一致性"></a>最终一致性</h4><p>上面说软状态，然后不可能一直是软状态，必须有个时间期限。在期限过后，应当保证所有副本保持数据一致性，从而达到数据的最终一致性。这个时间期限取决于网络延时、系统负载、数据复制方案设计等等因素。</p>
<h3 id="TPS和QPS区别"><a href="#TPS和QPS区别" class="headerlink" title="TPS和QPS区别"></a>TPS和QPS区别</h3><h5 id="TPS"><a href="#TPS" class="headerlink" title="TPS"></a><strong>TPS</strong></h5><p>TPS：Transactions Per Second，意思是每秒事务数，具体事务的定义，都是人为的，可以一个接口、多个接口、一个业务流程等等。一个事务是指事务内第一个请求发送到接收到最后一个请求的响应的过程，以此来计算使用的时间和完成的事务个数。</p>
<p>以单接口定义为事务为例，每个事务包括了如下3个过程：</p>
<p>　　a.向服务器发请求</p>
<p>　　b.服务器自己的内部处理（包含应用服务器、数据库服务器等）</p>
<p>　　c.服务器返回结果给客户端</p>
<p>　　如果每秒能够完成N次这三个过程，tps就是N；</p>
<p>如果多个接口定义为一个事务，那么，会重复执行abc，完成一次这几个请求，算做一个tps。</p>
<h5 id="QPS"><a href="#QPS" class="headerlink" title="QPS"></a>QPS</h5><p>QPS：Queries Per Second，意思是每秒查询率，是一台服务器每秒能够响应的查询次数（数据库中的每秒执行查询sql的次数），显然，这个不够全面，不能描述增删改，所以，不建议用qps来作为系统性能指标。</p>
<ul>
<li>qps包含tps</li>
</ul>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-03-21</span><a class="tag" href="/categories/实战/" title="实战">实战 </a><i class="fa fa-tag"></i><a class="tag" href="/tags/实战/" title="实战">实战 </a><span class="leancloud_visitors"></span><span>About1668words, 5min33secread</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/03/21/%E3%80%90Java%E3%80%91Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">【Java】Java并发编程</a></h3></div><div class="post-content"><div class="card"><p><h3 id="操作系统补充"><a href="#操作系统补充" class="headerlink" title="操作系统补充"></a>操作系统补充</h3><p><strong>缓存行（cache line)</strong></p>
<p>缓存行一般是64字节大小，且在缓存中支持一致性协议。</p>
<h3 id="Volite-关键字"><a href="#Volite-关键字" class="headerlink" title="Volite 关键字"></a>Volite 关键字</h3><h4 id="字节码层面"><a href="#字节码层面" class="headerlink" title="字节码层面"></a>字节码层面</h4><ul>
<li>volite修饰的关键字，会在<strong>字节码</strong>里多出一个ACC_VOLITE标志</li>
</ul>
<h4 id="JVM层面"><a href="#JVM层面" class="headerlink" title="JVM层面"></a>JVM层面</h4><ul>
<li><p><strong>JVM层面</strong>会增加一个内存屏障，为了禁止指令乱序执行。</p>
</li>
<li><p>使用volite修饰的变量，线程不会从缓存读取它，而是从主存读它</p>
<ul>
<li>关于缓存 CPU与主存之间往往由三级缓存，其中L1,L2在CPU内，L3在主板上</li>
</ul>
</li>
<li><p>JVM要求所有的JVM实现以下屏障</p>
<ul>
<li>Loadload&#x2F;StoreLoad&#x2F;StoreStore&#x2F;storeLoad 屏障</li>
<li>因而volatile在JVM下有以下屏障来禁止指令乱序执行</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">---- LoadLoad barrier------ <span class="comment">// 前面一条写num操作执行完才能之下下面这条</span></span><br><span class="line">read(num)</span><br><span class="line">---- LoadStore barrier ----- <span class="comment">// 这条写Num操作执行完才能进行下面的读操作</span></span><br><span class="line"></span><br><span class="line">----storestore barrier----</span><br><span class="line">read(num)</span><br><span class="line">----loadstore barrier----</span><br></pre></td></tr></table></figure>

<h4 id="CPU层面"><a href="#CPU层面" class="headerlink" title="CPU层面"></a>CPU层面</h4><ul>
<li>sfence(storefence) lfence(loadfence) mfence(multi-fence全屏障)</li>
<li>MESI 缓存行一致性协议</li>
<li>Lock 锁总线</li>
</ul>
<h3 id="线程和锁"><a href="#线程和锁" class="headerlink" title="线程和锁"></a>线程和锁</h3><ul>
<li>go的协程很像java的线程池之间的关系<ul>
<li>go和java都是事先分配一些内核线程来处理任务队列</li>
<li>java不能任务同步 但go可以</li>
<li>go通过模拟了cpu的执行。（cpu时钟周期）</li>
</ul>
</li>
</ul>
<h2 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h2><p>内置锁在Java中被抽象为监视器锁（monitor）。在JDK 1.6之前，监视器锁可以认为直接对应底层操作系统中的互斥量（mutex）。这种同步方式的成本非常高，包括系统调用引起的内核态与用户态切换、线程阻塞造成的线程切换等。因此，后来称这种锁为“重量级锁”。</p>
<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>首先，内核态与用户态的切换上不容易优化。但<strong>通过自旋锁，可以减少线程阻塞造成的线程切换</strong>（包括挂起线程和恢复线程）。</p>
<p>如果锁的粒度小，那么<strong>锁的持有时间比较短</strong>（尽管具体的持有时间无法得知，但可以认为，通常有一部分锁能满足上述性质）。那么，对于竞争这些锁的而言，因为锁阻塞造成线程切换的时间与锁持有的时间相当，减少线程阻塞造成的线程切换，能得到较大的性能提升。具体如下：</p>
<ul>
<li>当前线程竞争锁失败时，打算阻塞自己</li>
<li>不直接阻塞自己，而是自旋（空等待，比如一个空的有限for循环）一会</li>
<li>在自旋的同时重新竞争锁</li>
<li>如果自旋结束前获得了锁，那么锁获取成功；否则，自旋结束后阻塞自己</li>
</ul>
<p><em>如果在自旋的时间内，锁就被旧owner释放了，那么当前线程就不需要阻塞自己</em>（也不需要在未来锁释放时恢复），减少了一次线程切换。</p>
<p>“锁的持有时间比较短”这一条件可以放宽。实际上，只要锁竞争的时间比较短（比如线程1快释放锁的时候，线程2才会来竞争锁），就能够提高自旋获得锁的概率。这通常发生在<strong>锁持有时间长，但竞争不激烈</strong>的场景中。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>单核处理器上，不存在实际的并行，当前线程不阻塞自己的话，旧owner就不能执行，锁永远不会释放，此时不管自旋多久都是浪费；进而，如果线程多而处理器少，自旋也会造成不少无谓的浪费。</li>
<li>自旋锁要占用CPU，如果是计算密集型任务，这一优化通常得不偿失，减少锁的使用是更好的选择。</li>
<li>如果锁竞争的时间比较长，那么自旋通常不能获得锁，白白浪费了自旋占用的CPU时间。这通常发生在<em>锁持有时间长，且竞争激烈</em>的场景中，此时应主动禁用自旋锁。</li>
</ul>
<blockquote>
<p>使用-XX:-UseSpinning参数关闭自旋锁优化；-XX:PreBlockSpin参数修改默认的自旋次数。</p>
</blockquote>
<h3 id="自适应自旋锁"><a href="#自适应自旋锁" class="headerlink" title="自适应自旋锁"></a>自适应自旋锁</h3><p>自适应意味着自旋的时间不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定：</p>
<ul>
<li>如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长的时间，比如100个循环。</li>
<li>相反的，如果对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能减少自旋时间甚至省略自旋过程，以避免浪费处理器资源。</li>
</ul>
<p><strong>自适应自旋解决的是“锁竞争时间不确定”的问题</strong>。JVM很难感知到确切的锁竞争时间，而交给用户分析就违反了JVM的设计初衷。<em>自适应自旋假定不同线程持有同一个锁对象的时间基本相当，竞争程度趋于稳定，因此，可以根据上一次自旋的时间与结果调整下一次自旋的时间</em>。</p>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><p>然而，自适应自旋也没能彻底解决该问题，<em>如果默认的自旋次数设置不合理（过高或过低），那么自适应的过程将很难收敛到合适的值</em>。</p>
<h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><p>自旋锁的目标是降低线程切换的成本。如果锁竞争激烈，我们不得不依赖于重量级锁，让竞争失败的线程阻塞；如果完全没有实际的锁竞争，那么申请重量级锁都是浪费的。<strong>轻量级锁的目标是，减少无实际竞争情况下，使用重量级锁产生的性能消耗</strong>，包括系统调用引起的内核态与用户态切换、线程阻塞造成的线程切换等。</p>
<p>顾名思义，轻量级锁是相对于重量级锁而言的。使用轻量级锁时，不需要申请互斥量，仅仅<em>将Mark Word中的部分字节CAS更新指向线程栈中的Lock Record，如果更新成功，则轻量级锁获取成功</em>，记录锁状态为轻量级锁；<em>否则，说明已经有线程获得了轻量级锁，目前发生了锁竞争（不适合继续使用轻量级锁），接下来膨胀为重量级锁</em>。</p>
<blockquote>
<p>Mark Word是对象头的一部分；每个线程都拥有自己的线程栈（虚拟机栈），记录线程和函数调用的基本信息。二者属于JVM的基础内容，此处不做介绍。</p>
</blockquote>
<p>当然，由于轻量级锁天然瞄准不存在锁竞争的场景，如果存在锁竞争但不激烈，仍然可以用自旋锁优化，<em>自旋失败后再膨胀为重量级锁</em>。</p>
<h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><p>同自旋锁相似：</p>
<ul>
<li>如果<em>锁竞争激烈</em>，那么轻量级将很快膨胀为重量级锁，那么维持轻量级锁的过程就成了浪费。</li>
</ul>
<h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><p>在没有实际竞争的情况下，还能够针对部分场景继续优化。如果不仅仅没有实际竞争，自始至终，使用锁的线程都只有一个，那么，维护轻量级锁都是浪费的。<strong>偏向锁的目标是，减少无竞争且只有一个线程使用锁的情况下，使用轻量级锁产生的性能消耗</strong>。轻量级锁每次申请、释放锁都至少需要一次CAS，但偏向锁只有初始化时需要一次CAS。</p>
<p>“偏向”的意思是，<em>偏向锁假定将来只有第一个申请锁的线程会使用锁</em>（不会有任何线程再来申请锁），因此，<em>只需要在Mark Word中CAS记录owner（本质上也是更新，但初始值为空），如果记录成功，则偏向锁获取成功</em>，记录锁状态为偏向锁，<em>以后当前线程等于owner就可以零成本的直接获得锁；否则，说明有其他线程竞争，膨胀为轻量级锁</em>。</p>
<p>偏向锁无法使用自旋锁优化，因为一旦有其他线程申请锁，就破坏了偏向锁的假定。</p>
<h3 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h3><p>同样的，如果明显存在其他线程申请锁，那么偏向锁将很快膨胀为轻量级锁。</p>
<blockquote>
<p>不过这个副作用已经小的多。</p>
<p>如果需要，使用参数-XX:-UseBiasedLocking禁止偏向锁优化（默认打开）。</p>
</blockquote>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-03-21</span><a class="tag" href="/categories/Java/" title="Java">Java </a><i class="fa fa-tag"></i><a class="tag" href="/tags/Java基础/" title="Java基础">Java基础 </a><span class="leancloud_visitors"></span><span>About2377words, 7min55secread</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/03/21/%E3%80%90Spring%E3%80%91Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/">【Spring】Spring源码分析（二）</a></h3></div><div class="post-content"><div class="card"><p><h2 id="Spring启动流程"><a href="#Spring启动流程" class="headerlink" title="Spring启动流程"></a>Spring启动流程</h2><ol>
<li>首先，对于一个<code>web应用</code>，其部署在<code>web容器(tomcat)</code>中，web容器提供其一个<code>全局的上下文环境</code>，这个上下文就是<code>ServletContext</code>，其<code>为后面的spring IoC容器提供宿主环境</code>；</li>
<li>spring容器启动流程<ol>
<li>定位<br>在spring中，使用统一的资源表现方式Resource，定位到spring配置文件。</li>
<li>加载<br>在加载这个过程中，主要工作是<code>读取spring配置文件</code>，<code>解析配置文件中的内容</code>，将这些信息转换成为Spring内容可以理解、使用的<code>BeanDefinition</code>。</li>
<li>注册<br>加载过配置文件后，就将<code>BeanDefinition</code>信息注册到<code>BeanDefinitionRegistry接口</code>中，通常情况下<code>Spring容器</code>的实现类都实现这个接口。<code>注册</code>其实就是把<code>beanName</code>和<code>beanDefinition</code>作为键值对放到beanFactory对象的<code>map</code>。</li>
</ol>
</li>
</ol>
<p>其次，在<code>web.xml</code>中会提供有<code>contextLoaderListener</code>。在<code>web容器启动时</code>，<code>会触发容器初始化事件</code>，此时 <code>contextLoaderListener会监听到这个事件</code>，其<code>contextInitialized方法会被调用</code>，在这个方法中，<code>spring会初始化一个启动上下文</code>，这个上下文被称为<code>根上下文</code>，即<code>WebApplicationContext</code>，这是一个接口类，确切的说，其实际的<code>实现类是 XmlWebApplicationContext</code>：<code>spring的IoC容器</code>，（<strong>定位</strong>）其对应的<code>Bean定义</code>的配置由web.xml中的 <code>context-param</code>标签指定，（<strong>加载</strong>）<code>读取并解析</code>spring配置文件，将这些信息<code>转换成为Spring内容可以理解、使用的BeanDefinition</code>。在这个<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=IoC&spm=1001.2101.3001.7020">IoC</a>容器初始化完毕后，spring以WebApplicationContext.ROOTWEBAPPLICATIONCONTEXTATTRIBUTE为属性Key，将其存储到ServletContext中，便于获取；（<strong>注册</strong>）加载过配置文件后，就<code>将BeanDefinition信息注册到BeanDefinitionRegistry接口中</code>，通常情况下<code>Spring容器的实现类</code>都实现这个接口。在加载完所有Bean Class后，开始有序的通过BeanDefinition实例化Bean。</p>
<p><img src="https://img-blog.csdnimg.cn/2019031915533150.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzZG5saWppbmdyYW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ol start="3">
<li>再次，<code>contextLoaderListener监听器初始化完毕后</code>，<code>开始初始化web.xml中配置的Servlet</code>，这里是<code>DispatcherServlet</code>，这个servlet实际上是一个<code>标准的前端控制器</code>，<code>用以转发、匹配、处理每个servlet请求</code>。DispatcherServlet上下文<code>在初始化的时候会建立自己的IoC上下文</code>，<code>用以持有spring mvc相关的bean</code>。在<code>建立DispatcherServlet自己的IoC上下文时</code>，会利用WebApplicationContext.ROOTWEBAPPLICATIONCONTEXTATTRIBUTE 先从ServletContext中<code>获取之前的根上下文</code>(即WebApplicationContext)作为自己上下文的parent上下文。<code>有了这个 parent上下文之后</code>，<code>再初始化自己持有的上下文</code>。这个DispatcherServlet初始化自己上下文的工作在其initStrategies方法中可以看到，<strong>大概的工作就是</strong> <code>初始化处理器映射、视图解析等</code>。这个servlet自己持有的上下文默认实现类也是 mlWebApplicationContext。初始化完毕后，spring以与servlet的名字相关(此处不是简单的以servlet名为 Key，而是通过一些转换，具体可自行查看源码)的属性为属性Key，<code>也将其存到ServletContext中</code>，以便后续使用。这样每个servlet 就持有自己的上下文，即拥有自己独立的bean空间，同时各个servlet共享相同的bean，即根上下文(第2步中初始化的上下文)定义的那些 bean。</li>
</ol>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/moshenglv/article/details/53517343">(44条消息) 【Spring启动过程分析】（1）启动流程简介_程序员面试经验分享的博客-CSDN博客_spring启动流程</a></p>
</blockquote>
<h3 id="Refresh流程"><a href="#Refresh流程" class="headerlink" title="Refresh流程"></a>Refresh流程</h3><p>refresh源代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123;</span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="built_in">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">      <span class="type">StartupStep</span> <span class="variable">contextRefresh</span> <span class="operator">=</span> <span class="built_in">this</span>.applicationStartup.start(<span class="string">&quot;spring.context.refresh&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">      prepareRefresh();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">      <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">      prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">         postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="type">StartupStep</span> <span class="variable">beanPostProcess</span> <span class="operator">=</span> <span class="built_in">this</span>.applicationStartup.start(<span class="string">&quot;spring.context.beans.post-process&quot;</span>);</span><br><span class="line">         <span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">         invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">         registerBeanPostProcessors(beanFactory);</span><br><span class="line">         beanPostProcess.end();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Initialize message source for this context.</span></span><br><span class="line">         initMessageSource();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">         initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">         onRefresh();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">         registerListeners();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">         finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">         finishRefresh();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">         <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">         destroyBeans();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">         cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Propagate exception to caller.</span></span><br><span class="line">         <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line">         <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">         resetCommonCaches();</span><br><span class="line">         contextRefresh.end();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>SpringMVC是Spring的后续产品，融合在Srping Web Flow里面。Spring 框架提供了构件Web应用程序的全功能MVC模块，使用Spring可插入的MVC架构，从而在使用Spring进行Web开发时，可以选择使用SpringMVC或者其他MVC框架进行开发。</p>
<ul>
<li>SringMVC通过一套注解，让普通Java类称为Servlet controller,实现了控制层与Servlet的解耦。传统servlet需要一个请求对应一个Servlet对象。当有多种请求存在时，将会创建大量的servlet对象。而springmvc可以一个controller对应多个servlet请求</li>
<li>支持Rest风格的Url写法</li>
<li>采用松耦合</li>
</ul>
<p><strong>MVC</strong>设计理念</p>
<ul>
<li>M- model  模型层 DAO封装(MyBatis,JPA)</li>
<li>V- view 视图层 前端</li>
<li>C- controller 控制层 Servlet封装</li>
</ul>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><img src="http://m.qpic.cn/psc?/V51tJwXe303oBN0L3hL04alyjr4AX6ez/45NBuzDIW489QBoVep5mcYTHjTBC4MftBTApiv4RYrFU6Mh.1qDXKuCfPWfy9ozTpCi4IigSgVJ3FI6gp1z4MktHmxpwmzJ2frCh5GykmtM!/b&bo=pQM2AgAAAAADN4A!&rf=viewer_4" alt="image-20220322152827960"></p>
<p><strong>DispatcherServlet</strong></p>
<p>用户请求到达前端控制器，是整个流程控制的中心，由它调用其他组件处理用户的请求，降低组件之间的耦合性。</p>
<p><strong>HandlerMapping</strong></p>
<p>HandlerMapping负责根据用户请求找到Handler即对应的处理器。SpringMVC提供了不同映射器的实现不同的映射方式。例如配置文件，注解，实现接口等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">AbstractDetectingUrlHandlerMapping</span><br><span class="line">AbstractHandlerMapping</span><br><span class="line">AbstractHandlerMethodMapping</span><br><span class="line">AbstractUrlHandlerMapping</span><br><span class="line">BeanNameUrlHandlerMapping</span><br><span class="line">MatchableHandlerMapping</span><br><span class="line">PathPatternMatchableHandlerMapping</span><br><span class="line">PathSettingHandlerMapping in HandlerMappingIntrospector</span><br><span class="line">RequestMappingHandlerMapping</span><br><span class="line">RequestMappingInfoHandlerMapping</span><br><span class="line">RouterFunctionMapping</span><br><span class="line">SimpleUrlHandlerMapping</span><br><span class="line">WebMvcPropertySourcedRequestMappingHandlerMapping</span><br><span class="line">WelcomePageHandlerMapping</span><br></pre></td></tr></table></figure>

<p><strong>HandlerAdapter</strong></p>
<p>处理器适配器。通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器执行。</p>
<p><strong>Handler</strong></p>
<p>它就是我们开发中要编写的具体业务控制器。由<code>DispatcherServlet</code>把用户请求转发到<code>Handler</code>。</p>
<p><strong>View Resolver</strong></p>
<p>负责将处理结果生成View视图，View Resolver首先根据逻辑视图名解析成物理师徒名，即具体的页面地址，再生成view视图对象，最后对View进行渲染将处理结果通过页面展示返回给用户</p>
<p><strong>View</strong></p>
<p>SpringMVC框架提供了很多View视图类型的支持。包括<code>JstlView,freemakerView,pdfView</code>,最常用jsp</p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-03-21</span><a class="tag" href="/categories/Spring/" title="Spring">Spring </a><i class="fa fa-tag"></i><a class="tag" href="/tags/源码分析/" title="源码分析">源码分析 </a><span class="leancloud_visitors"></span><span>About1647words, 5min29secread</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/03/19/%E3%80%90Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%91606-%E6%A0%B9%E6%8D%AE%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%9B%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2/">【Leetcode刷题笔记】606 根据二叉树创建字符串</a></h3></div><div class="post-content"><div class="card"><p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>你需要采用前序遍历的方式，将一个二叉树转换成一个由括号和整数组成的字符串。</p>
<p>空节点则用一对空括号 “()” 表示。而且你需要省略所有不影响字符串与原始二叉树之间的一对一映射关系的空括号对。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入: 二叉树: [1,2,3,4]</span><br><span class="line">       1</span><br><span class="line">     /   \</span><br><span class="line">    2     3</span><br><span class="line">   /    </span><br><span class="line">  4     </span><br><span class="line"></span><br><span class="line">输出: &quot;1(2(4))(3)&quot;</span><br><span class="line"></span><br><span class="line">解释: 原本将是“1(2(4)())(3())”，</span><br><span class="line">在你省略所有不必要的空括号对之后，</span><br><span class="line">它将是“1(2(4))(3)”。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入: 二叉树: [1,2,3,null,4]</span><br><span class="line">       1</span><br><span class="line">     /   \</span><br><span class="line">    2     3</span><br><span class="line">     \  </span><br><span class="line">      4 </span><br><span class="line"></span><br><span class="line">输出: &quot;1(2()(4))(3)&quot;</span><br><span class="line"></span><br><span class="line">解释: 和第一个示例相似，</span><br><span class="line">除了我们不能省略第一个对括号来中断输入和输出之间的一对一映射关系。</span><br></pre></td></tr></table></figure>

<p>Related Topics</p>
<ul>
<li><p>树</p>
</li>
<li><p>深度优先搜索</p>
</li>
<li><p>字符串</p>
</li>
<li><p>二叉树</p>
</li>
</ul>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先要弄清楚不省略括号的情况是什么：</p>
<blockquote>
<p>当遍历到的空间点属于左节点，且其父节点的右节点不空，那这个空括号不可被省略</p>
</blockquote>
<p>搞清楚这一点就很好办了。但是有个问题出现了，题目要求采用前序遍历，先遍历左节点，后遍历右节点。是否添加空括号需要提前知道右节点是否为空这个信息。这样应该有多种解决方法。</p>
<p>我的解决方法是，把所有的空括号都添加进来，最后统一处理删除不必要的括号。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;String&gt; res;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">tree2str</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// 空括号存在的情况：左空右不空</span></span><br><span class="line">        <span class="comment">// 由于我们会先遍历左节点，所以加上一个标识符来判断左节点为空且右节点不为空</span></span><br><span class="line">        res=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        preTraversebTree(root);</span><br><span class="line">        StringBuilder ret=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">int</span> n=res.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>((res.get(i).equals(<span class="string">&quot;()&quot;</span>)&amp;&amp;i+<span class="number">1</span>&lt;n&amp;&amp;i+<span class="number">2</span>&lt;n&amp;&amp;res.get(i+<span class="number">1</span>).equals(<span class="string">&quot;(&quot;</span>)&amp;&amp;!res.get(i+<span class="number">1</span>).equals(<span class="string">&quot;)&quot;</span>))||!res.get(i).equals(<span class="string">&quot;()&quot;</span>))&#123;</span><br><span class="line">                ret.append(res.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">preTraversebTree</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            res.add(<span class="string">&quot;()&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">        res.add(String.valueOf(root.val));</span><br><span class="line">        preTraversebTree(root.left);</span><br><span class="line">        preTraversebTree(root.right);</span><br><span class="line">        res.add(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度：</strong></p>
<p>时间 O(n)</p>
<p>空间O(n)</p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-03-19</span><a class="tag" href="/categories/LeetCode/" title="LeetCode">LeetCode </a><i class="fa fa-tag"></i><a class="tag" href="/tags/刷题笔记/" title="刷题笔记">刷题笔记 </a><span class="leancloud_visitors"></span><span>About566words, 1min53secread</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/03/18/%E3%80%90Redis%E3%80%91%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">【Redis】源码分析（二） 数据类型源码分析</a></h3></div><div class="post-content"><div class="card"><p><h2 id="Redis-Rehashing过程"><a href="#Redis-Rehashing过程" class="headerlink" title="Redis Rehashing过程"></a>Redis Rehashing过程</h2><p>分析过程请看注释</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">dictRehash</span><span class="params">(dict *d, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// 空访问阈值</span></span><br><span class="line">    <span class="type">int</span> empty_visits = n*<span class="number">10</span>; <span class="comment">/* Max number of empty buckets to visit. */</span></span><br><span class="line">    <span class="comment">// 如果 rehashidx==-1 则没有在rehash，那就停止rehash</span></span><br><span class="line">    <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 如果rehash个数达到或者table[0]已经rehash完就结束while循环</span></span><br><span class="line">    <span class="keyword">while</span>(n-- &amp;&amp; d-&gt;ht_used[<span class="number">0</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">        dictEntry *de, *nextde;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Note that rehashidx can&#x27;t overflow as we are sure there are more</span></span><br><span class="line"><span class="comment">         * elements because ht[0].used != 0 */</span></span><br><span class="line">        assert(DICTHT_SIZE(d-&gt;ht_size_exp[<span class="number">0</span>]) &gt; (<span class="type">unsigned</span> <span class="type">long</span>)d-&gt;rehashidx);</span><br><span class="line">        <span class="comment">// 跳过空的dictEntry，如果空的个数达到阈值，则放弃rehashing</span></span><br><span class="line">        <span class="keyword">while</span>(d-&gt;ht_table[<span class="number">0</span>][d-&gt;rehashidx] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            d-&gt;rehashidx++;</span><br><span class="line">            <span class="keyword">if</span> (--empty_visits == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从非空rehash开始</span></span><br><span class="line">        de = d-&gt;ht_table[<span class="number">0</span>][d-&gt;rehashidx];</span><br><span class="line">        <span class="comment">/* Move all the keys in this bucket from the old to the new hash HT */</span></span><br><span class="line">        <span class="comment">// 如果de非空</span></span><br><span class="line">        <span class="keyword">while</span>(de) &#123;</span><br><span class="line">            <span class="type">uint64_t</span> h;</span><br><span class="line"></span><br><span class="line">            nextde = de-&gt;next;</span><br><span class="line">            <span class="comment">/* Get the index in the new hash table */</span></span><br><span class="line">            <span class="comment">// 计算新的hashkey</span></span><br><span class="line">            h = dictHashKey(d, de-&gt;key) &amp; DICTHT_SIZE_MASK(d-&gt;ht_size_exp[<span class="number">1</span>]);</span><br><span class="line">            <span class="comment">// de转移到新的table[1]上</span></span><br><span class="line">            de-&gt;next = d-&gt;ht_table[<span class="number">1</span>][h];</span><br><span class="line">            d-&gt;ht_table[<span class="number">1</span>][h] = de;</span><br><span class="line">            <span class="comment">// 旧表已用减少</span></span><br><span class="line">            d-&gt;ht_used[<span class="number">0</span>]--;</span><br><span class="line">            <span class="comment">// 新表医用增多</span></span><br><span class="line">            d-&gt;ht_used[<span class="number">1</span>]++;</span><br><span class="line">            de = nextde;</span><br><span class="line">        &#125;</span><br><span class="line">        d-&gt;ht_table[<span class="number">0</span>][d-&gt;rehashidx] = <span class="literal">NULL</span>;</span><br><span class="line">        d-&gt;rehashidx++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if we already rehashed the whole table... */</span></span><br><span class="line">    <span class="comment">// 如果已经rehash完所有，则释放table[0]的空间，并将table[1]移到tabke[0]</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht_used[<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">        zfree(d-&gt;ht_table[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">/* Copy the new ht onto the old one */</span></span><br><span class="line">        d-&gt;ht_table[<span class="number">0</span>] = d-&gt;ht_table[<span class="number">1</span>];</span><br><span class="line">        d-&gt;ht_used[<span class="number">0</span>] = d-&gt;ht_used[<span class="number">1</span>];</span><br><span class="line">        d-&gt;ht_size_exp[<span class="number">0</span>] = d-&gt;ht_size_exp[<span class="number">1</span>];</span><br><span class="line">        _dictReset(d, <span class="number">1</span>);</span><br><span class="line">        d-&gt;rehashidx = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* More to rehash... */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="List底层实现原理分析"><a href="#List底层实现原理分析" class="headerlink" title="List底层实现原理分析"></a>List底层实现原理分析</h2><p>List是一个有序的数据结构（按加入时序），Redis采用quicklist(双端链表)和ziplist(压缩列表)作为list的底层实现。其中ziplist作为节点存储在quicklist上，因而list的encoding是quicklist</p>
<p>可以通过设置每个Ziplist的最大容量，quickList(双端链表)的数据压缩范围，提升数据存储效率。</p>
<p><img src="/..%5Cimages%5Cziplist.png" alt="ziplist"></p>
<p><img src="/..%5Cimages%5Cquicklist.png" alt="quicklist"></p>
<blockquote>
<p>图片原作者：爱写代码的大曾（B站）</p>
</blockquote>
<h3 id="quickList"><a href="#quickList" class="headerlink" title="quickList"></a>quickList</h3><p>quickList是一个ziplist组成的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8&spm=1001.2101.3001.7020">双向链表</a>。每个节点使用ziplist来保存数据。本质上来说，quicklist里面保存着一个一个小的ziplist。</p>
<p><strong>结构</strong></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/32eeab930caa1aaa6faf4610a00bcdd2.png" alt="img"></p>
<p><strong>源码</strong></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> quicklistNode &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> quicklistNode *prev; <span class="comment">//上一个node节点</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> quicklistNode *next; <span class="comment">//下一个node</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *zl;            <span class="comment">//保存的数据 压缩前ziplist 压缩后压缩的数据</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> sz;             <span class="comment">/* ziplist size in bytes */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count : <span class="number">16</span>;     <span class="comment">/* count of items in ziplist */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> encoding : <span class="number">2</span>;   <span class="comment">/* RAW==1 or LZF==2 */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> container : <span class="number">2</span>;  <span class="comment">/* NONE==1 or ZIPLIST==2 */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> recompress : <span class="number">1</span>; <span class="comment">/* was this node previous compressed? */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> attempted_compress : <span class="number">1</span>; <span class="comment">/* node can&#x27;t compress; too small */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> extra : <span class="number">10</span>; <span class="comment">/* more bits to steal for future usage */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125; quicklistNode;</span><br></pre></td></tr></table></figure>

<ul>
<li>quickList就是一个标准的双向链表的配置，有head 有tail;</li>
<li>每一个节点是一个quicklistNode，包含prev和next指针。</li>
<li>每一个quicklistNode 包含 一个ziplist，*zp 压缩链表里存储键值。</li>
<li>所以quicklist是对ziplist进行一次封装，使用小块的ziplist来既保证了少使用内存，也保证了性能。</li>
</ul>
<p><strong>为什么不全部使用 ziplist呢？</strong></p>
<p>因为：ziplist存储在一段连续的内存上，所以存储效率很高。但是，它不利于修改操作，插入和删除操作需要频繁的申请和释放内存。特别是当ziplist长度很长的时候，一次realloc可能会导致大批量的数据拷贝。</p>
<h3 id="ziplist"><a href="#ziplist" class="headerlink" title="ziplist"></a>ziplist</h3><p>压缩列表 ziplist 是为 Redis 节约内存而开发的。ziplist 是由一系列特殊编码的内存块构成的列表(像内存连续的数组，但每个元素长度不同)， 一个 ziplist 可以包含多个节点（entry）。ziplist 将表中每一项存放在前后连续的地址空间内，每一项因占用的空间不同，而采用变长编码。</p>
<p>ziplist的主要优点是节省内存，但它上面的查找操作只能按顺序查找（可以是从前往后、也可以从后往前）。<br>ziplist将数据按照一定规则编码在一块连续的内存区域，目的是节省内存，这种结构并不擅长做修改操作。一旦数据发生改动，就会引发内存realloc，可能导致内存拷贝。</p>
<p><strong>ziplist 是一个特殊的双向链表</strong><br>特殊之处在于：没有维护双向指针:prev next；而是存储上一个 entry的长度和 当前entry的长度，通过长度推算下一个元素在什么地方。<br>牺牲读取的性能，获得高效的存储空间，因为(简短字符串的情况)存储指针比存储entry长度 更费内存。这是典型的“时间换空间”。</p>
<p><strong>ziplist使用局限性</strong><br>字段、值比较小，才会用ziplist。</p>
<p><strong>源码</strong></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> zlentry &#123;    <span class="comment">// 压缩列表节点</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> prevrawlensize, prevrawlen;    <span class="comment">// prevrawlen是前一个节点的长度，prevrawlensize是指prevrawlen的大小，有1字节和5字节两种</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> lensize, len;  <span class="comment">// len为当前节点长度 lensize为编码len所需的字节大小</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> headersize;    <span class="comment">// 当前节点的header大小</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> encoding; <span class="comment">// 节点的编码方式</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *p;   <span class="comment">// 指向节点的指针</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125; zlentry;</span><br></pre></td></tr></table></figure>

<p><strong>如何通过一个节点向前跳转到另一个节点？</strong><br>用指向当前节点的指针 e ， 减去 前一个 entry的长度， 得出的结果就是指向前一个节点的地址 p 。</p>
<p><strong>ziplist连锁更新问题</strong></p>
<p>因为在ziplist中，每个zlentry都存储着前一个节点所占的字节数，而这个数值又是<strong>变长编码</strong>的。假设存在一个压缩列表，其包含e1、e2、e3、e4…..，e1节点的大小为253字节，那么e2.prevrawlen的大小为1字节，如果此时在e2与e1之间插入了一个新节点e_new，e_new编码后的整体长度（包含e1的长度）为<strong>254字节</strong>，此时e2.prevrawlen就需要扩充为<strong>5字节</strong>；如果e2的整体长度变化又引起了e3.prevrawlen的存储长度变化，那么e3也需要扩…….如此递归直到表尾节点或者某一个节点的prevrawlen本身长度可以容纳前一个节点的变化。<strong>其中每一次扩充都需要进行空间再分配操作</strong>。删除节点亦是如此，只要引起了操作节点之后的节点的prevrawlen的变化，都可能引起连锁更新。</p>
<p>连锁更新在最坏情况下需要进行N次空间再分配，而每次空间再分配的最坏时间复杂度为O(N)，因此连锁更新的总体时间复杂度是O(N^2)。即使涉及连锁更新的时间复杂度这么高，但它能引起的性能问题的概率是极低的：需要列表中存在大量的节点长度接近254的zlentry。</p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-03-18</span><a class="tag" href="/categories/Redis/" title="Redis">Redis </a><i class="fa fa-tag"></i><a class="tag" href="/tags/源码分析/" title="源码分析">源码分析 </a><span class="leancloud_visitors"></span><span>About1743words, 5min48secread</span></div></div></div></div><div class="pagination"><ul class="clearfix"><li class="next pagbuttons"><a class="btn" role="navigation" href="/page/2/">Próximo</a></li></ul></div></div></div></div><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/add-bookmark.js"></script><script>(function(window){var INSIGHT_CONFIG={TRANSLATION:{POSTS:"Posts",PAGES:"Pages",CATEGORIES:"Categories",TAGS:"Tags",UNTITLED:"(Untitled)",},CONTENT_URL:"/content.json",};window.INSIGHT_CONFIG=INSIGHT_CONFIG})(window);</script><script src="/js/insight.js" defer></script><div class="searchbox ins-search"><div class="searchbox-container ins-search-container"><div class="searchbox-input-wrapper"><input class="searchbox-input ins-search-input" type="text" placeholder="Search..."><span class="searchbox-close"><a class="fa fa-times-circle" onclick="closeWindow();"></a></span></div><div class="searchbox-result-wrapper ins-section-wrapper"><div class="ins-section-container"><p>Seraching...</p></div></div></div></div><script src="/js/baidu-tongji.js"></script></body></html>