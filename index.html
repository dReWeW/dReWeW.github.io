<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Dalong"><title>Dalong's Blog</title><meta name="description" content="随便写写"><meta name="keywords" content="Blog,博客"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="shortcut icon" type="image/x-icon" href="/images/favicon.webp"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/insight.css"><link rel="stylesheet" href="/css/search.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script src="/js/jquery.js"></script><meta name="generator" content="Hexo 6.1.0"></head><body><div class="page-top animated fadeInDown"><div class="nav"><li> <a class="current" href="/">Home</a></li><li> <a href="/archives">Archives</a></li><li> <a href="/tags">Tags</a></li></div><div class="information"><div class="nav_right_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)" style="display:none;"> </a></li><li><a class="fa fa-search" onclick="openWindow();"></a></li></div><div class="avatar"><img src="/images/avatar.webp"></div></div></div><div class="sidebar animated fadeInDown"><div class="sidebar-top"><div class="logo-title"><div class="title"><img src="/images/avatar.webp" style="width:200px;" alt="favicon"><h3 title=""><a href="/">Dalong's Blog</a></h3><div class="description"><p>随便写写</p></div></div><ul class="social-links"><li><a target="_blank" rel="noopener" href="https://github.com/dReWeW"><i class="fa fa-github"></i></a></li><li><a href="mailto:dalongzd@qq.com"><i class="fa fa-envelope"></i></a></li><li><a target="_blank" rel="noopener" href="http://sighttp.qq.com/authd?IDKEY=569775346"><i class="fa fa-qq"></i></a></li></ul></div></div><div class="footer"><div class="p"> <span> 全站CC-BY-SA-3.0 </span><i class="fa fa-star"></i><span> Dalong</span></div><div class="by_farbox"><span>Powered by </span><a href="https://hexo.io/zh-cn/" target="_blank">Hexo </a><span> & </span><span>Anatolo </span></div><div class="beian"></div></div></div><div class="main"><div class="autopagerize_page_element"><div class="content"><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/05/06/%E3%80%90%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%E3%80%91%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B2/">【编程艺术】函数式编程2</a></h3></div><div class="post-content"><div class="card"><p><h3 id="常用函数式编程"><a href="#常用函数式编程" class="headerlink" title="常用函数式编程"></a>常用函数式编程</h3><table>
<thead>
<tr>
<th>接口</th>
<th>输入</th>
<th>返回</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Predicate<T></td>
<td>T</td>
<td>boolean</td>
<td>断言</td>
</tr>
<tr>
<td>Consumer<T></td>
<td>T</td>
<td>\</td>
<td>消费一个数据</td>
</tr>
<tr>
<td>Function&lt;T,R&gt;</td>
<td>T</td>
<td>R</td>
<td>输入T输出R</td>
</tr>
<tr>
<td>Supplier<T></td>
<td>&#x2F;</td>
<td>T</td>
<td>提供一个数据</td>
</tr>
<tr>
<td>UnaryOperator<T></td>
<td>T</td>
<td>T</td>
<td>一元函数</td>
</tr>
<tr>
<td>BiFunction<T></td>
<td>(T,U)</td>
<td>R</td>
<td>二个输入的函数</td>
</tr>
<tr>
<td>BinaryOperator<T></td>
<td>&lt;T,T&gt;</td>
<td>T</td>
<td>二元函数（输入类型相同）</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 常用函数时编程接口</span></span><br><span class="line">        Predicate&lt;Integer&gt; predicate = i -&gt; i &gt; <span class="number">0</span>;</span><br><span class="line">        System.out.println(predicate.test(<span class="number">1</span>));</span><br><span class="line">        System.out.println(predicate.negate().test(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        Consumer&lt;String&gt; consumer=s-&gt;System.out.println(s);</span><br><span class="line">        consumer.accept(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        UnaryOperator&lt;String&gt; unaryOperator=s-&gt;s.toUpperCase();</span><br><span class="line">        System.out.println(unaryOperator.apply(<span class="string">&quot;hello world&quot;</span>));</span><br><span class="line"></span><br><span class="line">        Function&lt;String,Integer&gt; function=s-&gt;s.length();</span><br><span class="line">        System.out.println(function.apply(<span class="string">&quot;hello world&quot;</span>));</span><br><span class="line">        Function&lt;Integer,String&gt; newStringFunction=String::valueOf;</span><br><span class="line">        System.out.println(newStringFunction.apply(<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">false</span><br><span class="line">hello world</span><br><span class="line">HELLO WORLD</span><br><span class="line">11</span><br><span class="line">10</span><br></pre></td></tr></table></figure>

<h3 id="Stream流运行机制"><a href="#Stream流运行机制" class="headerlink" title="Stream流运行机制"></a>Stream流运行机制</h3><ol>
<li>对于所有操作都是链式调用，且一个函数只迭代一次</li>
<li>每个中间操作返回一个新的流，流里面有一个属性sourceStage指向同一个地方，就是head</li>
<li>head-&gt;nextStage-&gt;nextStage-&gt;…null</li>
<li>有状态操作会把无状态操作截断，单独处理</li>
<li>并行环境下，有状态操作的中间操作不一定能并行操作。（不一定是观察输出结果所得到的）</li>
<li>parallel&#x2F;sequetial这两个操作也是中间操作，也返回stream，但不创建流，只修改head</li>
</ol>
<p>示例代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Random random=<span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        Stream&lt;Integer&gt; stream=Stream.generate(()-&gt;random.nextInt(<span class="number">100</span>))</span><br><span class="line">        .limit(<span class="number">5000</span>)</span><br><span class="line">        .peek(a-&gt;System.out.println(a))</span><br><span class="line">        .filter(a-&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(a);</span><br><span class="line">            <span class="keyword">if</span>(a&gt;=<span class="number">50</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        stream.count();</span><br></pre></td></tr></table></figure>

<p>对于两个无状态的peek和fiLter操作，操作的顺序是 peek-&gt;stage-&gt;peek-&gt;stage;</p>
<p>如果中间增加了有状态操作则会变成</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Random random=<span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        Stream&lt;Integer&gt; stream=Stream.generate(()-&gt;random.nextInt(<span class="number">100</span>))</span><br><span class="line">        .limit(<span class="number">5000</span>)</span><br><span class="line">        .peek(a-&gt;System.out.println(a))</span><br><span class="line">        .peek(a-&gt;sout(a))</span><br><span class="line">        .sorted((a,b)-&gt;b-a)</span><br><span class="line">        .filter(a-&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(a);</span><br><span class="line">            <span class="keyword">if</span>(a&gt;=<span class="number">50</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<p>peek1-&gt;peek2-&gt;peek1-&gt;peek2-&gt;…. sort-&gt;sort-&gt;….-&gt;filter</p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-05-06</span><a class="tag" href="/categories/Java/" title="Java">Java </a><i class="fa fa-tag"></i><a class="tag" href="/tags/编程艺术/" title="编程艺术">编程艺术 </a><a class="tag" href="/tags/Java进阶/" title="Java进阶">Java进阶 </a><span class="leancloud_visitors"></span><span>About510words, 1min42secread</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/05/06/%E3%80%90%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%E3%80%91%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/">【编程艺术】函数式编程</a></h3></div><div class="post-content"><div class="card"><p><p>Java Stream提供了强大的功能，它可以帮助我们摆脱命令式编程，而更加关注代码的语义，实现函数式编程。举个简单的例子，通常我们需要寻找数组最小值时我们会这样写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] nums=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> min=Integer.MAX_VALUE;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(nums[j]&lt;min)&#123;</span><br><span class="line">        min=nums[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但使用Stream后我们可以把代码简化成如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IntStream.of(nums).min().getAsInt();</span><br></pre></td></tr></table></figure>

<p>可能有人觉得这区别也不大，那么我再设想一个情况。加入我们寻找最小的数组有100万大小，那我们必须要考虑使用多线程优化这个过程。那么在传统的命令式编程中，我可能需要手动地去创建线程池，使用快排的思想对于数组进行分区查找等等。这样写下来可能就是上百行代码。这样的编程不仅阅读性差，而且费时费力。但如果使用Stream流编程，代码则可以这样写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IntStream.of(nums).parallel().min().getAsInt();</span><br><span class="line"><span class="comment">// parallel会多线程地去执行stream流函数</span></span><br></pre></td></tr></table></figure>

<p>这样的区别就相当明显了。使用函数式编程可以使代码语义更加明确，</p>
<hr>
<blockquote>
<p>关于流函数编程效率的讨论，这里引用一篇非常专业的分析文章<br>版权声明：本文为CSDN博主「Al_assad」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/Al_assad/article/details/82356606">https://blog.csdn.net/Al_assad/article/details/82356606</a></p>
</blockquote>
<h2 id="JDK8-Stream-数据流效率分析"><a href="#JDK8-Stream-数据流效率分析" class="headerlink" title="JDK8 Stream 数据流效率分析"></a>JDK8 Stream 数据流效率分析</h2><p>Stream 是Java SE 8类库中新增的关键抽象，它被定义于 java.util.stream （这个包里有若干流类型： Stream<T> 代表对象引用流，此外还有一系列特化流，如 IntStream，LongStream，DoubleStream等 ），Java 8 引入的的Stream主要用于取代部分Collection的操作，每个流代表一个值序列，流提供一系列常用的聚集操作，可以便捷的在它上面进行各种运算。集合类库也提供了便捷的方式使我们可以以操作流的方式使用集合、数组以及其它数据结构；</p>
<h3 id="stream-的操作种类"><a href="#stream-的操作种类" class="headerlink" title="stream 的操作种类"></a>stream 的操作种类</h3><p>①中间操作 </p>
<ul>
<li>当数据源中的数据上了流水线后，这个过程对数据进行的所有操作都称为“中间操作”；</li>
<li>中间操作仍然会返回一个流对象，因此多个中间操作可以串连起来形成一个流水线；</li>
<li>stream 提供了多种类型的中间操作，如 filter、distinct、map、sorted 等等；</li>
</ul>
<p>②终端操作 </p>
<ul>
<li><p>当所有的中间操作完成后，若要将数据从流水线上拿下来，则需要执行终端操作；</p>
</li>
<li><p>stream 对于终端操作，可以直接提供一个中间操作的结果，或者将结果转换为特定的 collection、array、String 等；</p>
</li>
</ul>
<p>这一部分详细的说明可以参见：JDK8 Stream 详细使用</p>
<h3 id="stream-的特点"><a href="#stream-的特点" class="headerlink" title="stream 的特点"></a>stream 的特点</h3><p>①只能遍历一次：</p>
<p>数据流的从一头获取数据源，在流水线上依次对元素进行操作，当元素通过流水线，便无法再对其进行操作，可以重新在数据源获取一个新的数据流进行操作；</p>
<p>②采用内部迭代的方式：</p>
<p>对Collection进行处理，一般会使用 Iterator 遍历器的遍历方式，这是一种外部迭代；</p>
<p>而对于处理Stream，只要申明处理方式，处理过程由流对象自行完成，这是一种内部迭代，对于大量数据的迭代处理中，内部迭代比外部迭代要更加高效；</p>
<h3 id="stream-相对于-Collection-的优点"><a href="#stream-相对于-Collection-的优点" class="headerlink" title="stream 相对于 Collection 的优点"></a>stream 相对于 Collection 的优点</h3><p>无存储：流并不存储值；流的元素源自数据源（可能是某个数据结构、生成函数或I&#x2F;O通道等等），通过一系列计算步骤得到；<br>函数式风格：对流的操作会产生一个结果，但流的数据源不会被修改；<br>惰性求值：多数流操作（包括过滤、映射、排序以及去重）都可以以惰性方式实现。这使得我们可以用一遍遍历完成整个流水线操作，并可以用短路操作提供更高效的实现；<br>无需上界：不少问题都可以被表达为无限流（infinite stream）：用户不停地读取流直到满意的结果出现为止（比如说，枚举 完美数 这个操作可以被表达为在所有整数上进行过滤）；集合是有限的，但流可以表达为无线流；<br>代码简练：对于一些collection的迭代处理操作，使用 stream 编写可以十分简洁，如果使用传统的 collection 迭代操作，代码可能十分啰嗦，可读性也会比较糟糕；</p>
<h3 id="stream-和-iterator-迭代的效率比较"><a href="#stream-和-iterator-迭代的效率比较" class="headerlink" title="stream 和 iterator 迭代的效率比较"></a>stream 和 iterator 迭代的效率比较</h3><p>好了，上面 stream 的优点吹了那么多，stream 函数式的写法是很舒服，那么 steam 的效率到底怎样呢？</p>
<p><strong>先说结论</strong>：</p>
<ul>
<li><p>传统 iterator (for-loop) 比 stream(JDK8) 迭代性能要高，尤其在小数据量的情况下；</p>
</li>
<li><p>在多核情景下，对于大数据量的处理，parallel stream 可以有比 iterator 更高的迭代处理效率；</p>
</li>
</ul>
<p>我分别对一个随机数列 List （数量从 10 到 10000000）进行映射、过滤、排序、规约统计、字符串转化场景下，对使用 stream 和 iterator 实现的运行效率进行了统计，测试代码 基准测试代码链接</p>
<p>测试环境如下：</p>
<p>System：Ubuntu 16.04 xenial</p>
<p>CPU：Intel Core i7-8550U</p>
<p>RAM：16GB</p>
<p>JDK version：1.8.0_151</p>
<p>JVM：HotSpot(TM) 64-Bit Server VM (build 25.151-b12, mixed mode)</p>
<p>JVM Settings:</p>
<pre><code>-Xms1024m

-Xmx6144m

-XX:MaxMetaspaceSize=512m

-XX:ReservedCodeCacheSize=1024m

-XX:+UseConcMarkSweepGC

-XX:SoftRefLRUPolicyMSPerMB=100
</code></pre>
<ol>
<li>映射处理测试</li>
</ol>
<p>把一个随机数列（List<Integer>）中的每一个元素自增1后，重新组装为一个新的 List<Integer>，测试的随机数列容量从 10 - 10000000，跑10次取平均时间；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//stream</span></span><br><span class="line">List&lt;Integer&gt; result = list.stream()</span><br><span class="line">.mapToInt(x -&gt; x)</span><br><span class="line">.map(x -&gt; ++x)</span><br><span class="line">.boxed()</span><br><span class="line">.collect(Collectors.toCollection(ArrayList::<span class="keyword">new</span>));</span><br><span class="line"><span class="comment">//iterator</span></span><br><span class="line">List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(Integer e : list)&#123;</span><br><span class="line">    result.add(++e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//parallel stream</span></span><br><span class="line">List&lt;Integer&gt; result = list.parallelStream()</span><br><span class="line">.mapToInt(x -&gt; x)</span><br><span class="line">.map(x -&gt; ++x)</span><br><span class="line">.boxed()</span><br><span class="line">.collect(Collectors.toCollection(ArrayList::<span class="keyword">new</span>));</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdn.net/20180903232153503?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FsX2Fzc2Fk/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<ol start="2">
<li>过滤处理测试</li>
</ol>
<p>取出一个随机数列（List<Integer>）中的大于 200 的元素，并组装为一个新的 List<Integer>，测试的随机数列容量从 10 - 10000000，跑10次取平均时间；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//stream</span></span><br><span class="line">List&lt;Integer&gt; result = list.stream()</span><br><span class="line">.mapToInt(x -&gt; x)</span><br><span class="line">.filter(x -&gt; x &gt; <span class="number">200</span>)</span><br><span class="line">.boxed()</span><br><span class="line">.collect(Collectors.toCollection(ArrayList::<span class="keyword">new</span>));</span><br><span class="line"><span class="comment">//iterator</span></span><br><span class="line">List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list.size());</span><br><span class="line"><span class="keyword">for</span>(Integer e : list)&#123;</span><br><span class="line">    <span class="keyword">if</span>(e &gt; <span class="number">200</span>)&#123;</span><br><span class="line">        result.add(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//parallel stream</span></span><br><span class="line">List&lt;Integer&gt; result = list.parallelStream()</span><br><span class="line">.mapToInt(x -&gt; x)</span><br><span class="line">.filter(x -&gt; x &gt; <span class="number">200</span>)</span><br><span class="line">.boxed()</span><br><span class="line">.collect(Collectors.toCollection(ArrayList::<span class="keyword">new</span>));</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdn.net/20180903232219230?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FsX2Fzc2Fk/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<ol start="3">
<li>自然排序测试</li>
</ol>
<p>对一个随机数列（List<Integer>）进行自然排序，并组装为一个新的 List<Integer>，iterator 使用的是 Collections # sort API（使用归并排序算法实现），测试的随机数列容量从 10 - 10000000，跑10次取平均时间；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//stream</span></span><br><span class="line">List&lt;Integer&gt; result = list.stream()</span><br><span class="line">.mapToInt(x-&gt;x)</span><br><span class="line">.sorted()</span><br><span class="line">.boxed()</span><br><span class="line">.collect(Collectors.toCollection(ArrayList::<span class="keyword">new</span>));</span><br><span class="line"><span class="comment">//iterator</span></span><br><span class="line">List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list);</span><br><span class="line">Collections.sort(result);</span><br><span class="line"><span class="comment">//parallel stream</span></span><br><span class="line">List&lt;Integer&gt; result = list.parallelStream()</span><br><span class="line">.mapToInt(x-&gt;x)</span><br><span class="line">.sorted()</span><br><span class="line">.boxed()</span><br><span class="line">.collect(Collectors.toCollection(ArrayList::<span class="keyword">new</span>));</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdn.net/20180903232259436?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FsX2Fzc2Fk/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<ol start="4">
<li>归约统计测试</li>
</ol>
<p>获取一个随机数列（List<Integer>）的最大值，测试的随机数列容量从 10 - 10000000，跑10次取平均时间；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//stream</span></span><br><span class="line"><span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> list.stream()</span><br><span class="line">.mapToInt(x -&gt; x)</span><br><span class="line">.max()</span><br><span class="line">.getAsInt();</span><br><span class="line"><span class="comment">//iterator</span></span><br><span class="line"><span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(Integer e : list)&#123;</span><br><span class="line">    <span class="keyword">if</span>(e &gt; max)&#123;</span><br><span class="line">        max = e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//parallel stream</span></span><br><span class="line"><span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> list.parallelStream()</span><br><span class="line">.mapToInt(x -&gt; x)</span><br><span class="line">.max()</span><br><span class="line">.getAsInt();</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdn.net/201809032323401?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FsX2Fzc2Fk/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<ol start="5">
<li>字符串拼接测试</li>
</ol>
<p>获取一个随机数列（List<Integer>）各个元素使用“,”分隔的字符串，测试的随机数列容量从 10 - 10000000，跑10次取平均时间；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//stream</span></span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> list.stream().map(String::valueOf).collect(Collectors.joining(<span class="string">&quot;,&quot;</span>));</span><br><span class="line"><span class="comment">//iterator</span></span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"><span class="keyword">for</span>(Integer e : list)&#123;</span><br><span class="line">    builder.append(e).append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> builder.length() == <span class="number">0</span> ? <span class="string">&quot;&quot;</span> : builder.substring(<span class="number">0</span>,builder.length() - <span class="number">1</span>);</span><br><span class="line"><span class="comment">//parallel stream</span></span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> list.stream().map(String::valueOf).collect(Collectors.joining(<span class="string">&quot;,&quot;</span>));</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdn.net/20180903232420958?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FsX2Fzc2Fk/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<ol start="6">
<li>混合操作测试</li>
</ol>
<p>对一个随机数列（List<Integer>）进行去空值，除重，映射，过滤，并组装为一个新的 List<Integer>，测试的随机数列容量从 10 - 10000000，跑10次取平均时间；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//stream</span></span><br><span class="line">List&lt;Integer&gt; result = list.stream()</span><br><span class="line">.filter(Objects::nonNull)</span><br><span class="line">.mapToInt(x -&gt; x + <span class="number">1</span>)</span><br><span class="line">.filter(x -&gt; x &gt; <span class="number">200</span>)</span><br><span class="line">.distinct()</span><br><span class="line">.boxed()</span><br><span class="line">.collect(Collectors.toCollection(ArrayList::<span class="keyword">new</span>));</span><br><span class="line"><span class="comment">//iterator</span></span><br><span class="line">HashSet&lt;Integer&gt; set  = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(list.size());</span><br><span class="line"><span class="keyword">for</span>(Integer e : list)&#123;</span><br><span class="line">    <span class="keyword">if</span>(e != <span class="literal">null</span> &amp;&amp; e &gt; <span class="number">200</span>)&#123;</span><br><span class="line">        set.add(e + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(set);</span><br><span class="line"><span class="comment">//parallel stream</span></span><br><span class="line">List&lt;Integer&gt; result = list.parallelStream()</span><br><span class="line">.filter(Objects::nonNull)</span><br><span class="line">.mapToInt(x -&gt; x + <span class="number">1</span>)</span><br><span class="line">.filter(x -&gt; x &gt; <span class="number">200</span>)</span><br><span class="line">.distinct()</span><br><span class="line">.boxed()</span><br><span class="line">.collect(Collectors.toCollection(ArrayList::<span class="keyword">new</span>));</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdn.net/20180903232503325?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FsX2Fzc2Fk/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p>实验结果总结</p>
<p>从以上的实验来看，可以总结处以下几点：</p>
<ul>
<li><p>在少低数据量的处理场景中（size&lt;&#x3D;1000），stream 的处理效率是不如传统的 iterator 外部迭代器处理速度快的，但是实际上这些处理任务本身运行时间都低于毫秒，这点效率的差距对普通业务几乎没有影响，反而 stream 可以使得代码更加简洁；</p>
</li>
<li><p>在大数据量（szie&gt;10000）时，stream 的处理效率会高于 iterator，特别是使用了并行流，在cpu恰好将线程分配到多个核心的条件下（当然parallel stream 底层使用的是 JVM 的 ForkJoinPool，这东西分配线程本身就很玄学），可以达到一个很高的运行效率，然而实际普通业务一般不会有需要迭代高于10000次的计算；</p>
</li>
<li><p>Parallel Stream 受引 CPU 环境影响很大，当没分配到多个cpu核心时，加上引用 forkJoinPool 的开销，运行效率可能还不如普通的 Stream；</p>
</li>
</ul>
<p>使用 Stream 的建议</p>
<ul>
<li><p>简单的迭代逻辑，可以直接使用 iterator，对于有多步处理的迭代逻辑，可以使用 stream，损失一点几乎没有的效率，换来代码的高可读性是值得的；</p>
</li>
<li><p>单核 cpu 环境，不推荐使用 parallel stream，在多核 cpu 且有大数据量的条件下，推荐使用 paralle stream；</p>
</li>
<li><p>stream 中含有装箱类型，在进行中间操作之前，最好转成对应的数值流，减少由于频繁的拆箱、装箱造成的性能损失；</p>
</li>
</ul>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-05-06</span><a class="tag" href="/categories/Java/" title="Java">Java </a><i class="fa fa-tag"></i><a class="tag" href="/tags/编程艺术/" title="编程艺术">编程艺术 </a><a class="tag" href="/tags/Java进阶/" title="Java进阶">Java进阶 </a><span class="leancloud_visitors"></span><span>About2690words, 8min58secread</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/03/28/%E3%80%90%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E3%80%91%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/">【基础算法】二分查找</a></h3></div><div class="post-content"><div class="card"><p><h2 id="【基础算法】Binary-Search"><a href="#【基础算法】Binary-Search" class="headerlink" title="【基础算法】Binary Search"></a>【基础算法】Binary Search</h2><p>二分查找法主要是解决在“一堆数中找出指定的数”这类问题。而想要应用二分查找，这堆数需要有以下特征</p>
<ul>
<li>存储在数组中</li>
<li>有序排列</li>
</ul>
<p>需要注意二分查找的边界条件，不然会出现可能出现明明找到了对应数的下标，却返回了找不到，或者进入死循环的情况。</p>
<blockquote>
<p>笔者这里选择采用 start&#x3D;0,end&#x3D;n-1作为初始值，</p>
<p>边界判定条件：start&lt;&#x3D;end</p>
<p>边界更新: right&#x3D;mid+1| left&#x3D;mid-1</p>
<p>这里之所以有小于等于，本情况的二分查找，最后找到对应数的下标时，会出现start&#x3D;end的情况、</p>
</blockquote>
<p>首先来看递归写法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">binarySearchRecursively</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (start + end) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span> binarySearchRecursively(nums, start, mid - <span class="number">1</span>, target);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> binarySearchRecursively(nums, mid + <span class="number">1</span>, end, target);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>然后是非递归写法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">binarySearchNonRecur</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> start=<span class="number">0</span>,end=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(start&lt;=end)&#123;</span><br><span class="line">            <span class="type">int</span> mid=start+(end-start)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]==target)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&gt;target)&#123;</span><br><span class="line">                end=mid-<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                start=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-03-28</span><a class="tag" href="/categories/算法/" title="算法">算法 </a><i class="fa fa-tag"></i><a class="tag" href="/tags/面试/" title="面试">面试 </a><a class="tag" href="/tags/基础算法/" title="基础算法">基础算法 </a><span class="leancloud_visitors"></span><span>About308words, 1min1secread</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/03/26/%E3%80%90Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%91682%20%E6%A3%92%E7%90%83%E6%AF%94%E8%B5%9B/">【Leetcode刷题笔记】682 棒球比赛</a></h3></div><div class="post-content"><div class="card"><p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul>
<li><p>你现在是一场采用特殊赛制棒球比赛的记录员。这场比赛由若干回合组成，过去几回合的得分可能会影响以后几回合的得分。</p>
<p>比赛开始时，记录是空白的。你会得到一个记录操作的字符串列表 <code>ops</code>，其中 <code>ops[i]</code> 是你需要记录的第 <code>i</code> 项操作，<code>ops</code> 遵循下述规则：</p>
<ol>
<li>整数 <code>x</code> - 表示本回合新获得分数 <code>x</code></li>
<li><code>&quot;+&quot;</code> - 表示本回合新获得的得分是前两次得分的总和。题目数据保证记录此操作时前面总是存在两个有效的分数。</li>
<li><code>&quot;D&quot;</code> - 表示本回合新获得的得分是前一次得分的两倍。题目数据保证记录此操作时前面总是存在一个有效的分数。</li>
<li><code>&quot;C&quot;</code> - 表示前一次得分无效，将其从记录中移除。题目数据保证记录此操作时前面总是存在一个有效的分数。</li>
</ol>
<p>请你返回记录中所有得分的总和。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：ops = [&quot;5&quot;,&quot;2&quot;,&quot;C&quot;,&quot;D&quot;,&quot;+&quot;]</span><br><span class="line">输出：30</span><br><span class="line">解释：</span><br><span class="line">&quot;5&quot; - 记录加 5 ，记录现在是 [5]</span><br><span class="line">&quot;2&quot; - 记录加 2 ，记录现在是 [5, 2]</span><br><span class="line">&quot;C&quot; - 使前一次得分的记录无效并将其移除，记录现在是 [5].</span><br><span class="line">&quot;D&quot; - 记录加 2 * 5 = 10 ，记录现在是 [5, 10].</span><br><span class="line">&quot;+&quot; - 记录加 5 + 10 = 15 ，记录现在是 [5, 10, 15].</span><br><span class="line">所有得分的总和 5 + 10 + 15 = 30</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：ops = [&quot;5&quot;,&quot;-2&quot;,&quot;4&quot;,&quot;C&quot;,&quot;D&quot;,&quot;9&quot;,&quot;+&quot;,&quot;+&quot;]</span><br><span class="line">输出：27</span><br><span class="line">解释：</span><br><span class="line">&quot;5&quot; - 记录加 5 ，记录现在是 [5]</span><br><span class="line">&quot;-2&quot; - 记录加 -2 ，记录现在是 [5, -2]</span><br><span class="line">&quot;4&quot; - 记录加 4 ，记录现在是 [5, -2, 4]</span><br><span class="line">&quot;C&quot; - 使前一次得分的记录无效并将其移除，记录现在是 [5, -2]</span><br><span class="line">&quot;D&quot; - 记录加 2 * -2 = -4 ，记录现在是 [5, -2, -4]</span><br><span class="line">&quot;9&quot; - 记录加 9 ，记录现在是 [5, -2, -4, 9]</span><br><span class="line">&quot;+&quot; - 记录加 -4 + 9 = 5 ，记录现在是 [5, -2, -4, 9, 5]</span><br><span class="line">&quot;+&quot; - 记录加 9 + 5 = 14 ，记录现在是 [5, -2, -4, 9, 5, 14]</span><br><span class="line">所有得分的总和 5 + -2 + -4 + 9 + 5 + 14 = 27</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：ops = [&quot;1&quot;]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= ops.length &lt;= 1000</code></li>
<li><code>ops[i]</code> 为 <code>&quot;C&quot;</code>、<code>&quot;D&quot;</code>、<code>&quot;+&quot;</code>，或者一个表示整数的字符串。整数范围是 <code>[-3 * 104, 3 * 104]</code></li>
<li>对于 <code>&quot;+&quot;</code> 操作，题目数据保证记录此操作时前面总是存在两个有效的分数</li>
<li>对于 <code>&quot;C&quot;</code> 和 <code>&quot;D&quot;</code> 操作，题目数据保证记录此操作时前面总是存在一个有效的分数</li>
</ul>
<p>Related Topics</p>
<p>栈</p>
<p>数组</p>
<p>模拟</p>
</li>
</ul>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>用栈模拟。</p>
<blockquote>
<p> 最近很忙，做了很多Leetcode的题，都没写题解。今天要出门，写个每日一题的题解把博客续上。之前的题解慢慢更。</p>
</blockquote>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calPoints</span><span class="params">(String[] ops)</span> &#123;</span><br><span class="line">        Stack&lt;Integer&gt; scoreStack= <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> n= ops.length;</span><br><span class="line">        <span class="type">int</span> score=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(ops[i].equals(<span class="string">&quot;+&quot;</span>))&#123;</span><br><span class="line">                <span class="type">int</span> score1=scoreStack.pop();</span><br><span class="line">                <span class="type">int</span> score2=scoreStack.peek();</span><br><span class="line">                scoreStack.push(score1);</span><br><span class="line">                scoreStack.push(score1+score2);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ops[i].equals(<span class="string">&quot;D&quot;</span>))&#123;</span><br><span class="line">                scoreStack.push(scoreStack.peek()*<span class="number">2</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ops[i].equals(<span class="string">&quot;C&quot;</span>))&#123;</span><br><span class="line">                scoreStack.pop();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                scoreStack.push(Integer.parseInt(ops[i]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!scoreStack.isEmpty())&#123;</span><br><span class="line">            score+=scoreStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度</strong></p>
<p>时间复杂度O(n)</p>
<p>空间复杂度O(n)</p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-03-26</span><a class="tag" href="/categories/LeetCode/" title="LeetCode">LeetCode </a><i class="fa fa-tag"></i><a class="tag" href="/tags/刷题笔记/" title="刷题笔记">刷题笔记 </a><span class="leancloud_visitors"></span><span>About823words, 2min44secread</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/03/22/%E3%80%90Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%912038-%E5%A6%82%E6%9E%9C%E7%9B%B8%E9%82%BB%E4%B8%A4%E4%B8%AA%E9%A2%9C%E8%89%B2%E5%9D%87%E7%9B%B8%E5%90%8C%E5%88%99%E5%88%A0%E9%99%A4%E5%BD%93%E5%89%8D%E9%A2%9C%E8%89%B2/">【Leetcode刷题笔记】2038 如果相邻两个颜色均相同则删除当前颜色</a></h3></div><div class="post-content"><div class="card"><p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>总共有 <code>n</code> 个颜色片段排成一列，每个颜色片段要么是 <code>&#39;A&#39;</code> 要么是 <code>&#39;B&#39;</code> 。给你一个长度为 <code>n</code> 的字符串 <code>colors</code> ，其中 <code>colors[i]</code> 表示第 <code>i</code> 个颜色片段的颜色。</p>
<p>Alice 和 Bob 在玩一个游戏，他们 <strong>轮流</strong> 从这个字符串中删除颜色。Alice <strong>先手</strong> 。</p>
<ul>
<li>如果一个颜色片段为 <code>&#39;A&#39;</code> 且 <strong>相邻两个颜色</strong> 都是颜色 <code>&#39;A&#39;</code> ，那么 Alice 可以删除该颜色片段。Alice <strong>不可以</strong> 删除任何颜色 <code>&#39;B&#39;</code> 片段。</li>
<li>如果一个颜色片段为 <code>&#39;B&#39;</code> 且 <strong>相邻两个颜色</strong> 都是颜色 <code>&#39;B&#39;</code> ，那么 Bob 可以删除该颜色片段。Bob <strong>不可以</strong> 删除任何颜色 <code>&#39;A&#39;</code> 片段。</li>
<li>Alice 和 Bob <strong>不能</strong> 从字符串两端删除颜色片段。</li>
<li>如果其中一人无法继续操作，则该玩家 <strong>输</strong> 掉游戏且另一玩家 <strong>获胜</strong> 。</li>
</ul>
<p>假设 Alice 和 Bob 都采用最优策略，如果 Alice 获胜，请返回 <code>true</code>，否则 Bob 获胜，返回 <code>false</code>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：colors = &quot;AAABABB&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">AAABABB -&gt; AABABB</span><br><span class="line">Alice 先操作。</span><br><span class="line">她删除从左数第二个 &#x27;A&#x27; ，这也是唯一一个相邻颜色片段都是 &#x27;A&#x27; 的 &#x27;A&#x27; 。</span><br><span class="line"></span><br><span class="line">现在轮到 Bob 操作。</span><br><span class="line">Bob 无法执行任何操作，因为没有相邻位置都是 &#x27;B&#x27; 的颜色片段 &#x27;B&#x27; 。</span><br><span class="line">因此，Alice 获胜，返回 true 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：colors = &quot;AA&quot;</span><br><span class="line">输出：false</span><br><span class="line">解释：</span><br><span class="line">Alice 先操作。</span><br><span class="line">只有 2 个 &#x27;A&#x27; 且它们都在字符串的两端，所以她无法执行任何操作。</span><br><span class="line">因此，Bob 获胜，返回 false 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：colors = &quot;ABBBBBBBAAA&quot;</span><br><span class="line">输出：false</span><br><span class="line">解释：</span><br><span class="line">ABBBBBBBAAA -&gt; ABBBBBBBAA</span><br><span class="line">Alice 先操作。</span><br><span class="line">她唯一的选择是删除从右数起第二个 &#x27;A&#x27; 。</span><br><span class="line"></span><br><span class="line">ABBBBBBBAA -&gt; ABBBBBBAA</span><br><span class="line">接下来轮到 Bob 操作。</span><br><span class="line">他有许多选择，他可以选择任何一个 &#x27;B&#x27; 删除。</span><br><span class="line"></span><br><span class="line">然后轮到 Alice 操作，她无法删除任何片段。</span><br><span class="line">所以 Bob 获胜，返回 false 。</span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= colors.length &lt;= 105</code></li>
<li><code>colors</code> 只包含字母 <code>&#39;A&#39;</code> 和 <code>&#39;B&#39;</code></li>
</ul>
<p>Related Topics</p>
<p>贪心</p>
<p>数学</p>
<p>字符串</p>
<p>博弈</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>遍历字符串，找出<code>Alice</code>和<code>Bob</code>分别长度大于3的子串，计算操作数即可。</p>
<p>写这么长纯粹为了降低执行耗时。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">winnerOfGame</span><span class="params">(String colors)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> colors.length();</span><br><span class="line">        <span class="type">char</span>[] array=colors.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">scoreA</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">// Alice&#x27;s score</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">scoreB</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">// Bob&#x27;s score</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> array[<span class="number">0</span>] == <span class="string">&#x27;A&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>;<span class="comment">// 0 - alice 1 - bob</span></span><br><span class="line">        <span class="type">int</span> tmpA=<span class="number">0</span>;<span class="comment">// accmulation of alice</span></span><br><span class="line">        <span class="type">int</span> tmpB=<span class="number">0</span>;<span class="comment">// accmulation of bob</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i]==<span class="string">&#x27;A&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(flag==<span class="number">0</span>)&#123;</span><br><span class="line">                    tmpA++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    tmpB=<span class="number">0</span>;</span><br><span class="line">                    tmpA=<span class="number">1</span>;</span><br><span class="line">                    flag=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(flag==<span class="number">1</span>)&#123;</span><br><span class="line">                    tmpB++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    tmpA=<span class="number">0</span>;</span><br><span class="line">                    tmpB=<span class="number">1</span>;</span><br><span class="line">                    flag=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tmpA&gt;=<span class="number">3</span>)&#123;</span><br><span class="line">                scoreA+=tmpA-<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tmpB&gt;=<span class="number">3</span>)&#123;</span><br><span class="line">                scoreB+=tmpB-<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> scoreA&gt;scoreB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n)</p>
<p>空间复杂度O(1&#x2F;n)</p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-03-22</span><a class="tag" href="/categories/LeetCode/" title="LeetCode">LeetCode </a><i class="fa fa-tag"></i><a class="tag" href="/tags/刷题笔记/" title="刷题笔记">刷题笔记 </a><span class="leancloud_visitors"></span><span>About731words, 2min26secread</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/03/22/%E3%80%90Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%912039-%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B2%E7%9A%84%E6%97%B6%E5%88%BB/">【Leetcode刷题笔记】2039 网络空闲的时刻</a></h3></div><div class="post-content"><div class="card"><p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个有 <code>n</code> 个服务器的计算机网络，服务器编号为 <code>0</code> 到 <code>n - 1</code> 。同时给你一个二维整数数组 <code>edges</code> ，其中 <code>edges[i] = [ui, vi]</code> 表示服务器 <code>ui</code> 和 <code>vi</code> 之间有一条信息线路，在 <strong>一秒</strong> 内它们之间可以传输 <strong>任意</strong> 数目的信息。再给你一个长度为 <code>n</code> 且下标从 <strong>0</strong> 开始的整数数组 <code>patience</code> 。</p>
<p>题目保证所有服务器都是 <strong>相通</strong> 的，也就是说一个信息从任意服务器出发，都可以通过这些信息线路直接或间接地到达任何其他服务器。</p>
<p>编号为 <code>0</code> 的服务器是 <strong>主</strong> 服务器，其他服务器为 <strong>数据</strong> 服务器。每个数据服务器都要向主服务器发送信息，并等待回复。信息在服务器之间按 <strong>最优</strong> 线路传输，也就是说每个信息都会以 <strong>最少时间</strong> 到达主服务器。主服务器会处理 <strong>所有</strong> 新到达的信息并 <strong>立即</strong> 按照每条信息来时的路线 <strong>反方向</strong> 发送回复信息。</p>
<p>在 <code>0</code> 秒的开始，所有数据服务器都会发送各自需要处理的信息。从第 <code>1</code> 秒开始，<strong>每</strong> 一秒最 <strong>开始</strong> 时，每个数据服务器都会检查它是否收到了主服务器的回复信息（包括新发出信息的回复信息）：</p>
<ul>
<li>如果还没收到任何回复信息，那么该服务器会周期性 <strong>重发</strong> 信息。数据服务器 <code>i</code> 每 <code>patience[i]</code> 秒都会重发一条信息，也就是说，数据服务器 <code>i</code> 在上一次发送信息给主服务器后的 <code>patience[i]</code> 秒 <strong>后</strong> 会重发一条信息给主服务器。</li>
<li>否则，该数据服务器 <strong>不会重发</strong> 信息。</li>
</ul>
<p>当没有任何信息在线路上传输或者到达某服务器时，该计算机网络变为 <strong>空闲</strong> 状态。</p>
<p>请返回计算机网络变为 <strong>空闲</strong> 状态的 <strong>最早秒数</strong> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/09/22/quiet-place-example1.png" alt="example 1"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">输入：edges = [[0,1],[1,2]], patience = [0,2,1]</span><br><span class="line">输出：8</span><br><span class="line">解释：</span><br><span class="line">0 秒最开始时，</span><br><span class="line">- 数据服务器 1 给主服务器发出信息（用 1A 表示）。</span><br><span class="line">- 数据服务器 2 给主服务器发出信息（用 2A 表示）。</span><br><span class="line"></span><br><span class="line">1 秒时，</span><br><span class="line">- 信息 1A 到达主服务器，主服务器立刻处理信息 1A 并发出 1A 的回复信息。</span><br><span class="line">- 数据服务器 1 还没收到任何回复。距离上次发出信息过去了 1 秒（1 &lt; patience[1] = 2），所以不会重发信息。</span><br><span class="line">- 数据服务器 2 还没收到任何回复。距离上次发出信息过去了 1 秒（1 == patience[2] = 1），所以它重发一条信息（用 2B 表示）。</span><br><span class="line"></span><br><span class="line">2 秒时，</span><br><span class="line">- 回复信息 1A 到达服务器 1 ，服务器 1 不会再重发信息。</span><br><span class="line">- 信息 2A 到达主服务器，主服务器立刻处理信息 2A 并发出 2A 的回复信息。</span><br><span class="line">- 服务器 2 重发一条信息（用 2C 表示）。</span><br><span class="line">...</span><br><span class="line">4 秒时，</span><br><span class="line">- 回复信息 2A 到达服务器 2 ，服务器 2 不会再重发信息。</span><br><span class="line">...</span><br><span class="line">7 秒时，回复信息 2D 到达服务器 2 。</span><br><span class="line"></span><br><span class="line">从第 8 秒开始，不再有任何信息在服务器之间传输，也不再有信息到达服务器。</span><br><span class="line">所以第 8 秒是网络变空闲的最早时刻。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/09/04/network_a_quiet_place_2.png" alt="example 2"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：edges = [[0,1],[0,2],[1,2]], patience = [0,10,10]</span><br><span class="line">输出：3</span><br><span class="line">解释：数据服务器 1 和 2 第 2 秒初收到回复信息。</span><br><span class="line">从第 3 秒开始，网络变空闲。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>n == patience.length</code></li>
<li><code>2 &lt;= n &lt;= 105</code></li>
<li><code>patience[0] == 0</code></li>
<li>对于 <code>1 &lt;= i &lt; n</code> ，满足 <code>1 &lt;= patience[i] &lt;= 105</code></li>
<li><code>1 &lt;= edges.length &lt;= min(105, n * (n - 1) / 2)</code></li>
<li><code>edges[i].length == 2</code></li>
<li><code>0 &lt;= ui, vi &lt; n</code></li>
<li><code>ui != vi</code></li>
<li>不会有重边。</li>
<li>每个服务器都直接或间接与别的服务器相连。</li>
</ul>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><blockquote>
<p>刚看此题的时候，我寻思这才中等题？后来仔细一看，题中的情况其实非常简单</p>
</blockquote>
<p>分析题干可知，一个主机的数据包到达服务器的事件是固定不变的，不受其他影响。</p>
<p>那我们假设主机到服务器的最短路径为<code>x</code>，那么从开始到收到确认包，就需要<code>2x</code>的时间。</p>
<p>那么确认一台主机多久会进入空闲状态只需要知道它最后一个数据包被确认的时间了。</p>
<p>我们已知在<code>2x</code>时刻，第一个数据包的ack到达主机，此时主机不会再重复发数据包，那么最后一个可能重复发数据包的时刻就是<code>2x-1</code>。</p>
<p>很容易可以推知$$ (2x-1)\ mod\ patience[i]&#x3D;&#x3D;0$$时，该时刻需要发最后一个数据包。</p>
<p>那如果不等于0呢？那就是最后一个数据包的当前位置了。</p>
<p>我们把等于0的情况看做最后一个数据包位于发送方主机的位置。那么可以推知，此时最后一个数据包收到确认的时间为 $$2x-1-(2x-1)mod\ patience[i]$$</p>
<p>因而最后一个数据包到达的时间为$4x-1-(2x-1)mod\ patience[i]+1$</p>
<p>又因为到达的下一时刻才会进入空闲，那么进入空闲的时间为 $4x-(2x-1)mod\ patience[i]$</p>
<p><strong>单源最短路径</strong></p>
<p>那么现在只需要算出每个主机距离服务器的最短距离，然后遍历获取最大值即可。这里使用dijkstra算法完成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">node</span> &#123;</span><br><span class="line">        <span class="type">int</span> index;</span><br><span class="line">        <span class="type">int</span> length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">node</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.index = index;</span><br><span class="line">            <span class="built_in">this</span>.length = length;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">networkBecomesIdle</span><span class="params">(<span class="type">int</span>[][] edges, <span class="type">int</span>[] patience)</span> &#123;</span><br><span class="line">        <span class="comment">// 先用Dijkstra算法做一下</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> patience.length;</span><br><span class="line">        <span class="type">int</span>[][] map = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="comment">// 初始化map所有初始值为Inf</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            Arrays.fill(map[i], Integer.MAX_VALUE);</span><br><span class="line">            map[i][i]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] edge : edges) &#123;</span><br><span class="line">            map[edge[<span class="number">0</span>]][edge[<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] dist = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Arrays.fill(dist, Integer.MAX_VALUE);</span><br><span class="line">        dist[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        Queue&lt;node&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>();</span><br><span class="line">        queue.add(<span class="keyword">new</span> <span class="title class_">node</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">boolean</span>[] vis=<span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">        vis[<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">node</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (map[cur.index][i] == <span class="number">1</span> &amp;&amp; !vis[i]&amp;&amp; dist[i] &gt; dist[cur.index] + <span class="number">1</span>) &#123;</span><br><span class="line">                    dist[i] = dist[cur.index] + <span class="number">1</span>;</span><br><span class="line">                    queue.add(<span class="keyword">new</span> <span class="title class_">node</span>(i, dist[i]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count == n - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 到这里已经算出了最短路径</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> num=<span class="number">4</span>*dist[i]-(<span class="number">2</span>*dist[i]-<span class="number">1</span>)%patience[i];</span><br><span class="line">            <span class="keyword">if</span>(num&gt;max)</span><br><span class="line">                max=num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Comparator&lt;node&gt; com = <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;node&gt;() &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(node o1, node o2)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> o1.length - o2.length;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度</strong></p>
<p>时间复杂度 最坏为O(n^2),最好为O(n)</p>
<p>空间复杂度O(n)</p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-03-22</span><a class="tag" href="/categories/LeetCode/" title="LeetCode">LeetCode </a><i class="fa fa-tag"></i><a class="tag" href="/tags/刷题笔记/" title="刷题笔记">刷题笔记 </a><span class="leancloud_visitors"></span><span>About1688words, 5min37secread</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/03/22/%E3%80%90Mysql%E3%80%91Mysql%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/">【Mysql】Mysql面试题整理</a></h3></div><div class="post-content"><div class="card"><p><h2 id="InnoDB中的B-树怎么产生的"><a href="#InnoDB中的B-树怎么产生的" class="headerlink" title="InnoDB中的B+树怎么产生的"></a>InnoDB中的B+树怎么产生的</h2><h3 id="page结构"><a href="#page结构" class="headerlink" title="page结构"></a>page结构</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9sZ05xVm50bHM3T2liaWFYSlBMSHl6aGVUc3B6QUFTVXhSUmgySXFJa2Rkb2JDUUc4WmdQRW1jb1lWNnpxMFRqVXV1TTJvWHZ2eVBDcVlpYjd3S2huNDRCUS82NDA?x-oss-process=image/format,png" alt="img"></p>
<p>InnoDB Page结构图</p>
<h4 id="1、File-Header结构，记录了page页的一些头信息，一共38字节"><a href="#1、File-Header结构，记录了page页的一些头信息，一共38字节" class="headerlink" title="1、File Header结构，记录了page页的一些头信息，一共38字节"></a>1、File Header结构，记录了page页的一些头信息，一共38字节</h4><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9sZ05xVm50bHM3T2liaWFYSlBMSHl6aGVUc3B6QUFTVXhSY2c5WHlkdG9GTk5VdEpsR29veGNURm5hR1JnZzJvN1FvOEU3aWJiRU9YZGRsazJ0QnQ4ZklpYWcvNjQw?x-oss-process=image/format,png" alt="img"></p>
<h5 id="innodb存储页类型"><a href="#innodb存储页类型" class="headerlink" title="innodb存储页类型"></a>innodb存储页类型</h5><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9sZ05xVm50bHM3T2liaWFYSlBMSHl6aGVUc3B6QUFTVXhSRTBaNWQ4ZVFjN2FlMDloVG5BcnRHeDhFOUZsZGdZM1kxVVhzQzl0ZGMzaWNxaGFYOFN5cVpjQS82NDA?x-oss-process=image/format,png" alt="img"></p>
<h4 id="2、page-header，记录页的状态信息，共56字节"><a href="#2、page-header，记录页的状态信息，共56字节" class="headerlink" title="2、page header，记录页的状态信息，共56字节"></a>2、page header，记录页的状态信息，共56字节</h4><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9sZ05xVm50bHM3T2liaWFYSlBMSHl6aGVUc3B6QUFTVXhSczBZTjBmWVFFZzB5REFqd1pyeHN6VXhZZTlSZUVHaGN0UGpRNm82cmI5QU5kVHNFWXBFQmx3LzY0MA?x-oss-process=image/format,png" alt="img"></p>
<h4 id="3、虚拟最大最小记录-Infimum-and-Supremum-Records"><a href="#3、虚拟最大最小记录-Infimum-and-Supremum-Records" class="headerlink" title="3、虚拟最大最小记录(Infimum and Supremum Records)"></a>3、虚拟最大最小记录(Infimum and Supremum Records)</h4><p>最大记录是这个数据页中逻辑上最大的记录，所有用户的记录都小于它。最小记录是数据页上最小的记录，所有用户记录都大于它。他们在数据页被创建的时候创建，而且不能被删除。引入他们主要是方便页内操作。</p>
<h4 id="4、用户记录"><a href="#4、用户记录" class="headerlink" title="4、用户记录"></a>4、用户记录</h4><p>用户所有插入的记录都存放在这里，默认情况下记录跟记录之间没有间隙，但是如果重用了已删除记录的空间，就会导致空间碎片。每个记录都有指向下一个记录的指针，但是没有指向上一个记录的指针。记录按照主键顺序排序。即，用户可以从数据页最小记录开始遍历，直到最大的记录，这包括了所有正常的记录和所有被delete-marked记录，但是不会访问到被删除的记录(PAGE_FREE)。</p>
<h4 id="5、Free-Space"><a href="#5、Free-Space" class="headerlink" title="5、Free Space"></a>5、Free Space</h4><p>从PAGEHEAPTOP开始，到最后一个数据目录，这之间的空间就是空闲空间，都被重置为0，当用户需要插入记录时候，首先在被删除的记录的空间中查找，如果没有找到合适的空间，就从这里分配。空间分配给记录后，需要递增PAGENRECS和PAGENHEAP。</p>
<h4 id="6、Page-Directory"><a href="#6、Page-Directory" class="headerlink" title="6、Page Directory"></a>6、Page Directory</h4><p>用户的记录是从低地址向高地址扩展，而数据目录则相反。在数据页被初始化的时候，就会在数据页最后(当然在checksum之前)创建两个数据目录，分别指向最大和最小记录。之后插入新的数据的时候，需要维护这个目录，例如必要的时候增加目录的个数。每个数据目录占用两个字节，存储对应记录的页内偏移量。假设目录N，这个目录N管理目录N-1(不包括)和目录N之间的记录，我们称目录N own 这些记录。在目录N指向的记录中，会有字段记录own记录的数量。由此可见，目录own的记录不能太多，因为太多的话，即意味着目录太过稀疏，不能很好的提高查询效率，但同时也不能own太少，这会导致目录数量变多，占用过多的空间。在InnoDB的实现中，目录own的记录数量在4-8之间，包括4和8，平均是6个记录。如果超过这个数量，就需要重新均衡目录的数量。目录的增加和删除可能需要进行内存拷贝，但是由于目录占用的总体空间很小，开销可以忽略不计。</p>
<h4 id="7、File-Trailer"><a href="#7、File-Trailer" class="headerlink" title="7、File Trailer"></a>7、File Trailer</h4><p>这个部分处于数据页最后的位置，只有8个字节。低地址的四个字节存储checksum的值，高地址的四个字节存储FILPAGELSN的低位四字节。注意这里的checksum的值不一定与FILPAGESPACEORCHKSUM的相同，这个依赖不同的checksum计算方法。</p>
<p>找到一张比较不错的page结构图</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9sZ05xVm50bHM3T2liaWFYSlBMSHl6aGVUc3B6QUFTVXhSalZYM0gwSk95ZktpYkNlYmNyS05rVGpUbzAyeElNdVhZamZMZEc3TDByRmVBZUxrajZUaWFpYmliZy82NDA?x-oss-process=image/format,png" alt="img"></p>
<h2 id="高度为3的B-树能存多少数据？"><a href="#高度为3的B-树能存多少数据？" class="headerlink" title="高度为3的B+树能存多少数据？"></a>高度为3的B+树能存多少数据？</h2><p>非叶子节点(4+6)&#x3D;10b</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line">    <span class="type">int</span>*children;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非叶子节点每页可以存16kb&#x2F;10b&#x3D;1638个节点</p>
<p>第二层可以有1638页，每页1638个节点</p>
<p>第三层为叶子节点，一页可以存16kb&#x2F;1kb&#x3D;16个</p>
<p>最终$1638<em>1638</em>16$个</p>
<h2 id="Innodb是如何支持范围查找能走索引的？"><a href="#Innodb是如何支持范围查找能走索引的？" class="headerlink" title="Innodb是如何支持范围查找能走索引的？"></a>Innodb是如何支持范围查找能走索引的？</h2><p>举个例子</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">index(a)</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> a<span class="operator">&gt;</span><span class="number">6</span>;</span><br></pre></td></tr></table></figure>

<p>内部执行过程是：先执行a&#x3D;6 找到6对应的值，然后返回后面的结果即可。</p>
<h2 id="为什么要遵守最左前缀才能利用到索引？"><a href="#为什么要遵守最左前缀才能利用到索引？" class="headerlink" title="为什么要遵守最左前缀才能利用到索引？"></a>为什么要遵守最左前缀才能利用到索引？</h2><p>最左前缀原则指的是，如果查询的时候查询条件精确匹配索引的左边连续一列或几列，则此列就可以被用到</p>
<p>如User表的name和city加联合索引就是(name,city)</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name<span class="operator">=</span>xx <span class="keyword">and</span> city<span class="operator">=</span>xx ; ／／可以命中索引</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name<span class="operator">=</span>xx ; <span class="operator">/</span><span class="operator">/</span> 可以命中索引</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> city<span class="operator">=</span>xx ; <span class="operator">/</span><span class="operator">/</span> 无法命中索引  </span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> city<span class="operator">=</span>xx <span class="keyword">and</span> name<span class="operator">=</span>xx ; ／／可以命中索引  </span><br><span class="line"> </span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> name <span class="keyword">is</span>  <span class="keyword">null</span>;<span class="operator">/</span><span class="operator">/</span>可以命中索引，使用<span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span> 会失效 </span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;zs&#x27;</span> <span class="keyword">and</span> address<span class="operator">=</span><span class="string">&#x27;beijing&#x27;</span>; <span class="operator">/</span><span class="operator">/</span>name用到了索引     </span><br></pre></td></tr></table></figure>

<h2 id="范围查找导致索引失效原理"><a href="#范围查找导致索引失效原理" class="headerlink" title="范围查找导致索引失效原理"></a>范围查找导致索引失效原理</h2><p>这种情况出现在辅助索引上。</p>
<p>考虑以下</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index(b,c,d) <span class="keyword">on</span> table1;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> table1 <span class="keyword">where</span> b<span class="operator">&gt;</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>这时候执行explain语句会发现mysql走了全表扫描。</p>
<p>这是因为mysql的辅助索引存储的具体的索引字段信息，而叶子节点存储主键索引+数据，为了要找到b&gt;1的数据，需要先在非聚集索引中找到对应的主键，再根据主键索引，查找对应的行数据，等于走了两遍B+树进行搜索，如果数据量接近全表数据量的话，比全表扫描还低，这时mysql就会走全表扫描。</p>
<h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><p>如果查询的字段，是已有的索引，且符合最左前缀原则，则可以直接走索引，这叫覆盖索引。</p>
<h2 id="索引扫描底层原则"><a href="#索引扫描底层原则" class="headerlink" title="索引扫描底层原则"></a>索引扫描底层原则</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">考虑如下</span><br><span class="line"><span class="keyword">create</span> index(b) <span class="keyword">on</span> table1;</span><br><span class="line"><span class="keyword">select</span> b <span class="keyword">from</span> table1;</span><br></pre></td></tr></table></figure>

<p>这时候主键索引会扫描更多数据，就会走索引。</p>
<h2 id="Order-By导致索引失效"><a href="#Order-By导致索引失效" class="headerlink" title="Order By导致索引失效"></a>Order By导致索引失效</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index(b,c,d) <span class="keyword">on</span> table1;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> table1 <span class="keyword">order</span> <span class="keyword">by</span> (a,b,c);</span><br></pre></td></tr></table></figure>

<p>此时如果数据量比较少的话，排序时间短，全表扫描快。如果数据量大，走索引会更快，虽然会回表，但比排序快。</p>
<h2 id="Mysql-数据类型转换有哪些需要注意"><a href="#Mysql-数据类型转换有哪些需要注意" class="headerlink" title="Mysql 数据类型转换有哪些需要注意"></a>Mysql 数据类型转换有哪些需要注意</h2><p>charset:字符集</p>
<p>collation:对应国家字符集的排序规则</p>
<p> mysql只把字符转成数字</p>
<h2 id="对字符进行操作索引失效的原理"><a href="#对字符进行操作索引失效的原理" class="headerlink" title="对字符进行操作索引失效的原理"></a>对字符进行操作索引失效的原理</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index(e) <span class="keyword">on</span> table1;<span class="operator">/</span><span class="operator">/</span> e为字符</span><br><span class="line"><span class="keyword">select</span> e <span class="keyword">from</span> <span class="keyword">where</span> e<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样会走全表扫描。因为mysql需要先把e字段所有数据转换成数字，然后比较。这样走全表扫描更方便。</p>
<h2 id="Mysql有哪些存储引擎"><a href="#Mysql有哪些存储引擎" class="headerlink" title="Mysql有哪些存储引擎"></a>Mysql有哪些存储引擎</h2><p><strong>InnoDB</strong>默认存储引擎，事务型存储引擎。设计用来处理大量短期事务。</p>
<p><strong>MyISAM</strong>5.1之前默认存储引擎，但不支持事务和行级锁，且崩溃后无法安全回复。</p>
<p><strong>Memory存储引擎</strong>比MyISAM快一个数量级。数据文件存在内存中，表结构在重启后保留，数据会丢失。一般保存中间数据。</p>
<p><strong>Archive引擎</strong>只支持INSERT和Select，会缓存所有的写并利用zlib对插入的行进行压缩。但每次SELECT都需要全表扫描。适合日志和数据采集。</p>
<p><strong>CSV引擎</strong>可以将普通的CSV文件作为Mysql表处理，但不支持索引。常作为数据交换。</p>
<h2 id="MyISAM和InnoDB区别（前innodb后myisam"><a href="#MyISAM和InnoDB区别（前innodb后myisam" class="headerlink" title="MyISAM和InnoDB区别（前innodb后myisam)"></a>MyISAM和InnoDB区别（前innodb后myisam)</h2><p>一个支持事务，一个不支持事务</p>
<p>一个锁最小粒度是行锁，一个是表锁</p>
<p>innodb不保存具体行数，而myisam保存，所以进行全表查询，myisam更快。</p>
<p>一个是聚集索引，一个是非聚集索引。myisam主键索引和辅助索引独立，但innodb是在一起的。</p>
<p>innodb支持外键，myisam不支持。</p>
<h2 id="字段优先级"><a href="#字段优先级" class="headerlink" title="字段优先级"></a>字段优先级</h2><p>优先使用长度短，定长的数值型字段。避免使用ZEROFILL</p>
<p>整形&gt;date,time&gt;enum char&gt;varchar&gt;blob,text</p>
<h2 id="Varchar-M-最多存储多少数据"><a href="#Varchar-M-最多存储多少数据" class="headerlink" title="Varchar(M)最多存储多少数据"></a>Varchar(M)最多存储多少数据</h2><p>最多存储65535字节(2^16-1)个字节</p>
<h2 id="事务并发引发的问题"><a href="#事务并发引发的问题" class="headerlink" title="事务并发引发的问题"></a>事务并发引发的问题</h2><p><strong>脏读</strong>事务A读取到事务B未提交的数据</p>
<p><strong>不可重复读</strong>事务A读了两次a，但两次读之间事务B修改了数据a，导致事务B在两次读取出来的数据不一致。</p>
<p><strong>幻读</strong>与不可重复读类似，但第二次读到了事务A增加出来的新数据，而不是修改了的数据a</p>
<h2 id="简单描述Mysql索引"><a href="#简单描述Mysql索引" class="headerlink" title="简单描述Mysql索引"></a>简单描述Mysql索引</h2><p>按字段 主键，唯一索引，普通，前缀索引</p>
<p>其中前缀索引是对二进制类型字段或者字符串类型的前几个字符简历索引。</p>
<h2 id="三星索引"><a href="#三星索引" class="headerlink" title="三星索引"></a>三星索引</h2><p> 一个查询相关的索引行是相邻的或者至少相距足够靠近，则一星</p>
<p>如果索引中数据顺序和查找中排列顺序一直，则二星</p>
<p>如果索引中的列包含了查询需要的全部列则三星。</p>
<h2 id="Mysql存放多少行"><a href="#Mysql存放多少行" class="headerlink" title="Mysql存放多少行"></a>Mysql存放多少行</h2><p>2千多万行</p>
<h2 id="提高Insert性能"><a href="#提高Insert性能" class="headerlink" title="提高Insert性能"></a>提高Insert性能</h2><p>多条合并为一条 </p>
<p>调大大批量插入的缓存大小</p>
<p>手动使用事务 默认一次提交一条，可以手动设置为1000条提交一次事务</p>
<h2 id="全局锁、共享锁、排它锁"><a href="#全局锁、共享锁、排它锁" class="headerlink" title="全局锁、共享锁、排它锁"></a>全局锁、共享锁、排它锁</h2><p>全局锁，全局被锁，数据库只读</p>
<p><strong>共享锁</strong>其他事务可并发读。如果事务多读锁进行修改，容易死锁</p>
<p><strong>排它锁</strong>只能事务A读写数据，其他事务只能读。排它锁会阻塞所有排它锁和共享锁。</p>
<h2 id="Mysql-读写分离"><a href="#Mysql-读写分离" class="headerlink" title="Mysql 读写分离"></a>Mysql 读写分离</h2><p>主库写，从库读</p>
<p>关于主从库数据同步，依赖于binlog日志文件，只记录修改操作。</p>
<p>主从结构中，从库会复制一份binlog，然后写一份relay log（中继日志）。启动一个sql线程，执行binlog里的insert和update，这样主从库数据同步。</p>
<h2 id="Mysql分库分表"><a href="#Mysql分库分表" class="headerlink" title="Mysql分库分表"></a>Mysql分库分表</h2><p>水平拆分 - hash原理 （uid%size)&#x3D;hashcode</p>
<p>根据时间拆分 </p>
<h2 id="聚簇索引和非聚簇索引"><a href="#聚簇索引和非聚簇索引" class="headerlink" title="聚簇索引和非聚簇索引"></a>聚簇索引和非聚簇索引</h2><p>聚簇索引：数据和索引放一块儿，找到索引就找到数据，且数据的物理存放顺序和索引顺序一直</p>
<p>非聚簇索引：叶子节点不存储数据，存储的数据行的地址。</p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-03-22</span><a class="tag" href="/categories/面试/" title="面试">面试 </a><i class="fa fa-tag"></i><a class="tag" href="/tags/mysql/" title="mysql">mysql </a><span class="leancloud_visitors"></span><span>About2682words, 8min56secread</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/03/21/%E3%80%90Java%E3%80%91Java%E6%9C%89%E5%93%AA%E4%BA%9B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/">【Java】Java有哪些类加载器</a></h3></div><div class="post-content"><div class="card"><p><h2 id="什么是classloader"><a href="#什么是classloader" class="headerlink" title="什么是classloader"></a>什么是classloader</h2><p>classloader顾名思义，即是类加载。虚拟机把描述类的数据从class字节码文件加载到内存，并对数据进行检验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。了解java的类加载机制，可以快速解决运行时的各种加载问题并快速定位其背后的本质原因，也是解决疑难杂症的利器。因此学好类加载原理也至关重要。</p>
<h2 id="classloader的加载过程"><a href="#classloader的加载过程" class="headerlink" title="classloader的加载过程"></a>classloader的加载过程</h2><p>类从被加载到<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:1739289578%7D">虚拟机内存</a>到被卸载，整个完整的生命周期包括：类加载、验证、准备、解析、初始化、使用和卸载七个阶段。其中验证，准备，解析三个部分统称为连接。接下来我们可以详细了解下类加载的各个过程。</p>
<p><img src="https://pic3.zhimg.com/50/v2-071d6fa5c0aefe61c363bc94b6b5b286_720w.jpg?source=1940ef5c" alt="img"><img src="https://pic3.zhimg.com/80/v2-071d6fa5c0aefe61c363bc94b6b5b286_720w.jpg?source=1940ef5c" alt="img"></p>
<p>classloader的整个加载过程还是非常复杂的，具体的细节可以参考《<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:1739289578%7D">深入理解java虚拟机</a>》进行深入了解。为了方便记忆，我们可以使用一句话来表达其加载的整个过程，“家宴准备了西式菜”，即家(加载)宴(验证)准备(准备)了西(解析)式(初始化)菜。保证你以后能够很快的想起来。<br>虽然classloader的加载过程有复杂的5步，但事实上除了加载之外的四步，其它都是由JVM虚拟机控制的，我们除了适应它的规范进行开发外，能够干预的空间并不多。而加载则是我们控制classloader实现特殊目的最重要的手段了。也是接下来我们介绍的重点了。</p>
<h2 id="classloader双亲委托机制"><a href="#classloader双亲委托机制" class="headerlink" title="classloader双亲委托机制"></a>classloader双亲委托机制</h2><p>classloader的双亲委托机制是指多个类加载器之间存在父子关系的时候，某个class类具体由哪个加载器进行加载的问题。其具体的过程表现为：当一个类加载的过程中，它首先不会去加载，而是委托给自己的父类去加载，父类又委托给自己的父类。因此所有的类加载都会委托给顶层的父类，即Bootstrap Classloader进行加载，然后父类自己无法完成这个加载请求，子加载器才会尝试自己去加载。使用双亲委派模型，Java类随着它的加载器一起具备了一种带有优先级的层次关系，通过这种<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E5%B1%82%E6%AC%A1%E6%A8%A1%E5%9E%8B&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:1739289578%7D">层次模型</a>，可以避免类的重复加载，也可以避免核心类被不同的类加载器加载到内存中造成冲突和混乱，从而保证了Java核心库的安全。</p>
<p><img src="https://pic1.zhimg.com/50/v2-eafe30b56d52cc526d6da75430807390_720w.jpg?source=1940ef5c" alt="img"><img src="https://pic1.zhimg.com/80/v2-eafe30b56d52cc526d6da75430807390_720w.jpg?source=1940ef5c" alt="img"></p>
<p>整个java虚拟机的类加载层次关系如上图所示，启动类加载器(Bootstrap Classloader)负责将<JAVA_HOME>&#x2F;lib目录下并且被虚拟机识别的类库加载到虚拟机内存中。我们常用基础库，例如java.util.**，java.io.**，java.lang.**等等都是由根加载器加载。</p>
<p>扩展类加载器(Extention Classloader)负责加载JVM扩展类，比如swing系列、内置的js引擎、xml解析器等，这些类库以javax开头，它们的jar包位于<JAVA_HOME>&#x2F;lib&#x2F;ext目录中。</p>
<p>应用程序加载器(Application Classloader)也叫系统类加载器，它负责加载用户路径(ClassPath)上所指定的类库。我们自己编写的代码以及使用的第三方的jar包都是由它来加载的自定义加载器(Custom Classloader)通常是我们为了某些特殊目的实现的自定义加载器，后面我们得会详细介绍到它的作用以及使用场景。</p>
<p>双亲委托机制看起来比较复杂，但是其本身的核心代码逻辑却是非常的清晰简单，我们着重抽取了类加载的双亲委托的核心代码如下，不过二十行左右。</p>
<p><img src="https://pic1.zhimg.com/50/v2-d2b2276905548a42a329ca52e4444dfc_720w.jpg?source=1940ef5c" alt="img"><img src="https://pic1.zhimg.com/80/v2-d2b2276905548a42a329ca52e4444dfc_720w.jpg?source=1940ef5c" alt="img"></p>
<h2 id="classloader的应用场景"><a href="#classloader的应用场景" class="headerlink" title="classloader的应用场景"></a>classloader的应用场景</h2><p>类加载器是java语言的一项创新，也是java语言流行的重要原因这一。通过灵活定义classloader的加载机制，我们可以完成很多事情，例如解决类冲突问题，实现热加载以及热部署，甚至可以实现jar包的加密保护。接下来，我们会针对这些特殊场景进行逐一介绍。</p>
<blockquote>
<p> 作者：阿里巴巴淘系技术<br>链接：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/46719811/answer/1739289578">https://www.zhihu.com/question/46719811/answer/1739289578</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-03-21</span><a class="tag" href="/categories/Java/" title="Java">Java </a><i class="fa fa-tag"></i><a class="tag" href="/tags/Java基础/" title="Java基础">Java基础 </a><span class="leancloud_visitors"></span><span>About1256words, 4min11secread</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/03/21/%E3%80%90Spring%E3%80%91Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/">【Spring】Spring源码分析（一）</a></h3></div><div class="post-content"><div class="card"><p><h4 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h4><p><strong>IOC与DI</strong></p>
<p>IOC 控制反转，一种思想。依赖注入，一种手段。</p>
<p><strong>IOC</strong>是控制反转的意思，这是一种面向对象编程的设计思想。在不采用这种思想的情况下，我们需要自己维护对象与对象之间的依赖关系，很容易造成对象之间的耦合度过高，在一个大型的项目中这十分的不利于代码的维护。IoC则可以解决这种问题，它可以帮我们维护对象与对象之间的依赖关系，降低对象之间的耦合度。</p>
<p><strong>DI</strong>是依赖注入的意思，它是IoC实现的实现方式，就是说IoC是通过DI来实现的。由于IoC这个词汇比较抽象而DI却更直观，所以很多时候我们就用DI来代替它，在很多时候我们简单地将IoC和DI划等号，这是一种习惯。而实现依赖注入的关键是IoC容器，它的本质就是一个工厂。</p>
<p><strong>xml里配置bean</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">?</span> <span class="attr">class</span>=<span class="string">?</span> <span class="attr">abstract</span> <span class="attr">init-method</span> <span class="attr">scope</span> <span class="attr">dependon...</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">?</span> <span class="attr">value</span>=<span class="string">?/</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">?</span> <span class="attr">value</span>=<span class="string">?/</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>Java里获取bean</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Application ac=<span class="keyword">new</span>;</span><br><span class="line">ClassPathXmlApplicationContext(<span class="string">&quot;applicationContent.xml&quot;</span>);</span><br><span class="line">XXX xxx=ac.getBean(XXX.class);</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 从xml配置到bean发生了什么？</p>
</blockquote>
<p>LoadXml-&gt;ParseXml-&gt;封装BeanDefinition-&gt;实例化(使用反射而非<code>new</code>)-&gt;放入容器中-&gt;从容器中获取</p>
<ul>
<li>不只xml可以配置bean,如properties groovy也可以配置bean</li>
<li>从配置文件到生成beanDefinition,解析器需要实现<code>BeanDefinitionReader</code> 接口。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanDefinitionReader</span></span><br></pre></td></tr></table></figure>

<ul>
<li>理解实例化的过程需要先了解反射，这里简单复习一下Java反射机制</li>
</ul>
<p><strong>反射获取类对象的几种方式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class.forName();</span><br><span class="line">对象.getClass();</span><br><span class="line">类名.class();</span><br></pre></td></tr></table></figure>
<p>一些示例代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;TreeNode&quot;</span>);</span><br><span class="line">       Constructor[] constructors= clazz.getConstructors();</span><br><span class="line">       <span class="keyword">for</span> (Constructor constructor : constructors) &#123;</span><br><span class="line">           System.out.println(constructor);</span><br><span class="line">       &#125;</span><br><span class="line">       constructors=clazz.getDeclaredConstructors();</span><br><span class="line">       <span class="keyword">for</span> (Constructor constructor : constructors) &#123;</span><br><span class="line">           System.out.println(constructor);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 由于无参构造函数是私有的，而getConstructor只能获取公有的，所以会抛出异常</span></span><br><span class="line">       <span class="comment">// Constructor con=clazz.getConstructor(null);</span></span><br><span class="line">       <span class="comment">// System.out.println(con);</span></span><br><span class="line">       Constructor con=clazz.getConstructor(<span class="type">int</span>.class);</span><br><span class="line">       System.out.println(con);</span><br><span class="line"></span><br><span class="line">       TreeNode root= (TreeNode) con.newInstance(<span class="number">1</span>);</span><br><span class="line">       Field field=clazz.getDeclaredField(<span class="string">&quot;val&quot;</span>);</span><br><span class="line">       field.set(root, <span class="number">2</span>);</span><br><span class="line">       System.out.println(root.val);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 输出object mark word</span></span><br><span class="line">       </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>实例化的过程包括实例化和初始化<ul>
<li>注意 实例化和初始化不能等同来看</li>
<li><strong>实例化</strong>是给对象在堆中开辟一块空间，对象属性值都是默认值</li>
<li>而<strong>初始化</strong>是填充属性，设置Aware接口的属性，并执行init-method</li>
</ul>
</li>
</ul>
<h4 id="关于Bean的生命周期"><a href="#关于Bean的生命周期" class="headerlink" title="关于Bean的生命周期"></a><strong>关于Bean的生命周期</strong></h4><p>Spring容器管理Bean，涉及对Bean的创建、初始化、调用、销毁等一系列的流程，这个流程就是Bean的生命周期。整个流程参考下图：</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20220224/4107856_1645694380479/7EF8F66C3DFA7434E4CA11B47CF8F1F7" alt="img"></p>
<ol>
<li>在Bean 先要调用构造器完成实例化。</li>
<li>接下来是初始化的过程</li>
</ol>
<p>注意，这里的<code>postProcessorAfterInitialization和postProcessorBeforeInitialization</code>使用了AOP</p>
<p><strong>AOP实现的两种方法</strong></p>
<ul>
<li>DK动态代理：这是Java提供的动态代理技术，可以在运行时创建接口的代理实例。Spring AOP默认采用这种方式，在接口的代理实例中织入代码。</li>
<li>CGLib动态代理：采用底层的字节码技术，在运行时创建子类代理的实例。当目标对象不存在接口时，Spring AOP就会采用这种方式，在子类实例中织入代码。</li>
</ul>
<h5 id="Spring-Aware"><a href="#Spring-Aware" class="headerlink" title="Spring Aware"></a>Spring Aware</h5><blockquote>
<p>顾名思义，Spring Bean Aware 就是帮助bean感知Spring容器的存在。这会增加Bean与IOC容器的耦合。</p>
</blockquote>
<p>常见的 Spring Aware 接口</p>
<table>
<thead>
<tr>
<th align="left">Aware子接口</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">BeanNameAware</td>
<td align="left">获取容器中 Bean 的名称</td>
</tr>
<tr>
<td align="left">BeanFactoryAware</td>
<td align="left">获取当前 BeanFactory ，这样可以调用容器的服务</td>
</tr>
<tr>
<td align="left">ApplicationContextAware</td>
<td align="left">同上，在<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/YVl20QqUHTXMubr68wXR1A">BeanFactory 和 ApplicationContext 的区别</a> 中已明确说明</td>
</tr>
<tr>
<td align="left">MessageSourceAware</td>
<td align="left">获取 Message Source 相关文本信息</td>
</tr>
<tr>
<td align="left">ApplicationEventPublisherAware</td>
<td align="left">发布事件</td>
</tr>
<tr>
<td align="left">ResourceLoaderAware</td>
<td align="left">获取资源加载器，这样获取外部资源文件</td>
</tr>
</tbody></table>
<p>来看类关系图：<br><img src="http://rgyb.sunluomeng.top/%E5%85%AC%E4%BC%97%E8%B4%A6%E5%8F%B7%E6%96%87%E7%AB%A0/%E5%BA%94%E7%94%A8%E7%B1%BB%E6%96%87%E7%AB%A0/_image/2019-07-03/Xnip2019-07-03_14-39-56.jpg" alt="img"></p>
<p>当然不止以上这些 Aware， 通常使用 Spring Aware 的目的是为了让 Bean 获得 Spring 容器的服务。比如，通过Aware，可以通过当前对象，获取容器中其他所有对象。(有点反射那种思想)</p>
<h4 id="Spring中的观察者模式"><a href="#Spring中的观察者模式" class="headerlink" title="Spring中的观察者模式"></a>Spring中的观察者模式</h4><p>观察者模式的应用：监听器，监听事件，多播器</p>
<p>如监听Spring容器创建完成的观察者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">onRefresh();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">registerListeners();</span><br></pre></td></tr></table></figure>

<p><strong>BeanFactory和FactoryBean的区别</strong></p>
<p>都是用来创建对象的，当使用BeanFactory的时候必须要遵循完整的创建过程，这个过程是由spring来管理控制的。而使用FactoryBean只需要调用getObject就可以返回具体的对象，整个对象的创建过程是由用户自己来控制的，更加灵活。</p>
<p><strong>PostProcessor</strong></p>
<ul>
<li><code>BeanFactorPostProcessor</code> BeanDefinition增强器接口，自定义的PostProcessor需要实现它</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">myBeanFactoryPoProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanFactoryPostProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;myBeanFactoryPoProcessor&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>BeanProcessor</code>Bean的增强器接口，自定义的PostProcessor需要实现它</li>
</ul>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-03-21</span><a class="tag" href="/categories/Spring/" title="Spring">Spring </a><i class="fa fa-tag"></i><a class="tag" href="/tags/源码分析/" title="源码分析">源码分析 </a><span class="leancloud_visitors"></span><span>About1330words, 4min26secread</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/03/21/%E3%80%90%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/">【并发编程】高并发秒杀系统架构设计</a></h3></div><div class="post-content"><div class="card"><p><blockquote>
<p>以下内容为马士兵老师的Java并发编程中高并发秒杀系统架构实战的听课笔记</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1aS4y1R7UW?p=7">【马士兵教育】首次深入计算机底层原理透彻解析Java并发编程，JUC并发编程，多线程，高并发秒杀方案全套教程（合集）_哔哩哔哩_bilibili</a></p>
</blockquote>
<h3 id="CAP定理"><a href="#CAP定理" class="headerlink" title="CAP定理"></a>CAP定理</h3><p>CAP原则又称CAP定理，指的是在一个分布式系统中， Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可得兼。</p>
<ul>
<li><strong>一致性（C）</strong>：在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本）</li>
<li><strong>可用性（A）</strong>：保证每个请求不管成功或者失败都有响应。</li>
<li><strong>分区容忍性（P）</strong>：系统中任意信息的丢失或失败不会影响系统的继续运作。</li>
</ul>
<p><strong>关于分区容忍性的理解：</strong> 分区容忍性是指当系统发生故障时，是否可以继续正常运作。如，两台服务器之间的网线断开了，无法进行信息交换，如果这时系统能够容忍这样的故障发生并且继续运行，则叫分区容忍性。</p>
<p><strong>为什么不能同时满足的通俗理解</strong></p>
<ol>
<li>满足C和A，那么P能不能满足呢？</li>
</ol>
<p>满足C需要所有的服务器的数据要一样，也就是说要实现数据的同步，那么同步要不要时间？肯定是要的，并且机器越多，同步的时间肯定越慢，这里问题就来了，我们同时也满足了A，也就是说，我要同步时间短才行。这样的话，机器就不能太多了，也就是说P是满足不了的</p>
<ol start="2">
<li>满足C和P，那么A能不能满足呢？</li>
</ol>
<p>满足P需要很多服务器，假设有1000台服务器，同时满足了C，也就是说要保证每台机器的数据都一样，那么同步的时间可就很大，在这种情况下，我们肯定是不能保证用户随时访问每台服务器获取到的数据都是最新的，想要获取最新的，可以，你就等吧，等全部同步完了，你就可以获取到了，但是我们的A要求短时间就可以拿到想要的数据啊，这不就是矛盾了，所以说这里A是满足不了了</p>
<ol start="3">
<li>满足A和P，那么C能不能满足呢？</li>
</ol>
<p>满足P的话，需要多台服务器，而满足C的话，只有一台服务器才可以满足，这和P矛盾。</p>
<h3 id="12306的问题"><a href="#12306的问题" class="headerlink" title="12306的问题"></a>12306的问题</h3><ol>
<li>强一致性带来的难题 - 递归循环锁<ul>
<li>解决： 分布式一致性哈希环，防止一个节点存全量数据，只存和处理一部分数据。</li>
<li>降低一致性增强可用性</li>
<li>异步通讯，慢慢完成数据一致性。（前端一致，后端不一致）</li>
<li></li>
</ul>
</li>
</ol>
<h3 id="Base理论"><a href="#Base理论" class="headerlink" title="Base理论"></a>Base理论</h3><p>BASE理论是Basically Available(基本可用)，Soft State（软状态）和Eventually Consistent（最终一致性）三个短语的缩写。</p>
<p>核心思想：</p>
<blockquote>
<p>既是无法做到强一致性（Strong consistency），但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）。</p>
</blockquote>
<h4 id="基本可用"><a href="#基本可用" class="headerlink" title="基本可用"></a>基本可用</h4><p>什么是基本可用呢？假设系统，出现了不可预知的故障，但还是能用，相比较正常的系统而言：</p>
<p><strong>响应时间上的损失</strong>：正常情况下的搜索引擎0.5秒即返回给用户结果，而基本可用的搜索引擎可以在2秒作用返回结果。</p>
<p><strong>功能上的损失</strong>：在一个电商网站上，正常情况下，用户可以顺利完成每一笔订单。但是到了大促期间，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面。3.2. 软状态</p>
<h4 id="软状态"><a href="#软状态" class="headerlink" title="软状态"></a>软状态</h4><p>什么是软状态呢？相对于原子性而言，要求多个节点的数据副本都是一致的，这是一种“硬状态”。</p>
<p>软状态指的是：允许系统中的数据存在中间状态，并认为该状态不影响系统的整体可用性，即允许系统在多个不同节点的数据副本存在数据延时。</p>
<h4 id="最终一致性"><a href="#最终一致性" class="headerlink" title="最终一致性"></a>最终一致性</h4><p>上面说软状态，然后不可能一直是软状态，必须有个时间期限。在期限过后，应当保证所有副本保持数据一致性，从而达到数据的最终一致性。这个时间期限取决于网络延时、系统负载、数据复制方案设计等等因素。</p>
<h3 id="TPS和QPS区别"><a href="#TPS和QPS区别" class="headerlink" title="TPS和QPS区别"></a>TPS和QPS区别</h3><h5 id="TPS"><a href="#TPS" class="headerlink" title="TPS"></a><strong>TPS</strong></h5><p>TPS：Transactions Per Second，意思是每秒事务数，具体事务的定义，都是人为的，可以一个接口、多个接口、一个业务流程等等。一个事务是指事务内第一个请求发送到接收到最后一个请求的响应的过程，以此来计算使用的时间和完成的事务个数。</p>
<p>以单接口定义为事务为例，每个事务包括了如下3个过程：</p>
<p>　　a.向服务器发请求</p>
<p>　　b.服务器自己的内部处理（包含应用服务器、数据库服务器等）</p>
<p>　　c.服务器返回结果给客户端</p>
<p>　　如果每秒能够完成N次这三个过程，tps就是N；</p>
<p>如果多个接口定义为一个事务，那么，会重复执行abc，完成一次这几个请求，算做一个tps。</p>
<h5 id="QPS"><a href="#QPS" class="headerlink" title="QPS"></a>QPS</h5><p>QPS：Queries Per Second，意思是每秒查询率，是一台服务器每秒能够响应的查询次数（数据库中的每秒执行查询sql的次数），显然，这个不够全面，不能描述增删改，所以，不建议用qps来作为系统性能指标。</p>
<ul>
<li>qps包含tps</li>
</ul>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-03-21</span><a class="tag" href="/categories/实战/" title="实战">实战 </a><i class="fa fa-tag"></i><a class="tag" href="/tags/实战/" title="实战">实战 </a><span class="leancloud_visitors"></span><span>About1668words, 5min33secread</span></div></div></div></div><div class="pagination"><ul class="clearfix"><li class="next pagbuttons"><a class="btn" role="navigation" href="/page/2/">Próximo</a></li></ul></div></div></div></div><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/add-bookmark.js"></script><script>(function(window){var INSIGHT_CONFIG={TRANSLATION:{POSTS:"Posts",PAGES:"Pages",CATEGORIES:"Categories",TAGS:"Tags",UNTITLED:"(Untitled)",},CONTENT_URL:"/content.json",};window.INSIGHT_CONFIG=INSIGHT_CONFIG})(window);</script><script src="/js/insight.js" defer></script><div class="searchbox ins-search"><div class="searchbox-container ins-search-container"><div class="searchbox-input-wrapper"><input class="searchbox-input ins-search-input" type="text" placeholder="Search..."><span class="searchbox-close"><a class="fa fa-times-circle" onclick="closeWindow();"></a></span></div><div class="searchbox-result-wrapper ins-section-wrapper"><div class="ins-section-container"><p>Seraching...</p></div></div></div></div><script src="/js/baidu-tongji.js"></script></body></html>