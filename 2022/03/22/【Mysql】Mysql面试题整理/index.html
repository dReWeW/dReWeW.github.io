<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Dalong"><title>【Mysql】Mysql面试题整理 · Dalong's Blog</title><meta name="description" content="InnoDB中的B+树怎么产生的page结构
InnoDB Page结构图
1、File Header结构，记录了page页的一些头信息，一共38字节
innodb存储页类型
2、page header，记录页的状态信息，共56字节
3、虚拟最大最小记录(Infimum and Supremum R"><meta name="keywords" content="Blog,博客"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="shortcut icon" type="image/x-icon" href="/images/favicon.webp"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/insight.css"><link rel="stylesheet" href="/css/search.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script src="/js/jquery.js"></script><meta name="generator" content="Hexo 6.1.0"></head><body><div class="page-top animated fadeInDown"><div class="nav"><li> <a href="/">Home</a></li><li> <a href="/archives">Archives</a></li><li> <a href="/tags">Tags</a></li></div><div class="information"><div class="nav_right_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li><li><a class="fa fa-search" onclick="openWindow();"></a></li></div><div class="avatar"><img src="/images/avatar.webp"></div></div></div><div class="sidebar animated fadeInDown"><div class="sidebar-top"><div class="logo-title"><div class="title"><img src="/images/avatar.webp" style="width:200px;" alt="favicon"><h3 title=""><a href="/">Dalong's Blog</a></h3><div class="description"><p>随便写写</p></div></div><ul class="social-links"><li><a target="_blank" rel="noopener" href="https://github.com/dReWeW"><i class="fa fa-github"></i></a></li><li><a href="mailto:dalongzd@qq.com"><i class="fa fa-envelope"></i></a></li><li><a target="_blank" rel="noopener" href="http://sighttp.qq.com/authd?IDKEY=569775346"><i class="fa fa-qq"></i></a></li></ul></div></div><div class="footer"><div class="p"> <span> 全站CC-BY-SA-3.0 </span><i class="fa fa-star"></i><span> Dalong</span></div><div class="by_farbox"><span>Powered by </span><a href="https://hexo.io/zh-cn/" target="_blank">Hexo </a><span> & </span><span>Anatolo </span></div><div class="beian"></div></div></div><div class="main"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>【Mysql】Mysql面试题整理</a></h3></div><div class="post-content"><p><h2 id="InnoDB中的B-树怎么产生的"><a href="#InnoDB中的B-树怎么产生的" class="headerlink" title="InnoDB中的B+树怎么产生的"></a>InnoDB中的B+树怎么产生的</h2><h3 id="page结构"><a href="#page结构" class="headerlink" title="page结构"></a>page结构</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9sZ05xVm50bHM3T2liaWFYSlBMSHl6aGVUc3B6QUFTVXhSUmgySXFJa2Rkb2JDUUc4WmdQRW1jb1lWNnpxMFRqVXV1TTJvWHZ2eVBDcVlpYjd3S2huNDRCUS82NDA?x-oss-process=image/format,png" alt="img"></p>
<p>InnoDB Page结构图</p>
<h4 id="1、File-Header结构，记录了page页的一些头信息，一共38字节"><a href="#1、File-Header结构，记录了page页的一些头信息，一共38字节" class="headerlink" title="1、File Header结构，记录了page页的一些头信息，一共38字节"></a>1、File Header结构，记录了page页的一些头信息，一共38字节</h4><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9sZ05xVm50bHM3T2liaWFYSlBMSHl6aGVUc3B6QUFTVXhSY2c5WHlkdG9GTk5VdEpsR29veGNURm5hR1JnZzJvN1FvOEU3aWJiRU9YZGRsazJ0QnQ4ZklpYWcvNjQw?x-oss-process=image/format,png" alt="img"></p>
<h5 id="innodb存储页类型"><a href="#innodb存储页类型" class="headerlink" title="innodb存储页类型"></a>innodb存储页类型</h5><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9sZ05xVm50bHM3T2liaWFYSlBMSHl6aGVUc3B6QUFTVXhSRTBaNWQ4ZVFjN2FlMDloVG5BcnRHeDhFOUZsZGdZM1kxVVhzQzl0ZGMzaWNxaGFYOFN5cVpjQS82NDA?x-oss-process=image/format,png" alt="img"></p>
<h4 id="2、page-header，记录页的状态信息，共56字节"><a href="#2、page-header，记录页的状态信息，共56字节" class="headerlink" title="2、page header，记录页的状态信息，共56字节"></a>2、page header，记录页的状态信息，共56字节</h4><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9sZ05xVm50bHM3T2liaWFYSlBMSHl6aGVUc3B6QUFTVXhSczBZTjBmWVFFZzB5REFqd1pyeHN6VXhZZTlSZUVHaGN0UGpRNm82cmI5QU5kVHNFWXBFQmx3LzY0MA?x-oss-process=image/format,png" alt="img"></p>
<h4 id="3、虚拟最大最小记录-Infimum-and-Supremum-Records"><a href="#3、虚拟最大最小记录-Infimum-and-Supremum-Records" class="headerlink" title="3、虚拟最大最小记录(Infimum and Supremum Records)"></a>3、虚拟最大最小记录(Infimum and Supremum Records)</h4><p>最大记录是这个数据页中逻辑上最大的记录，所有用户的记录都小于它。最小记录是数据页上最小的记录，所有用户记录都大于它。他们在数据页被创建的时候创建，而且不能被删除。引入他们主要是方便页内操作。</p>
<h4 id="4、用户记录"><a href="#4、用户记录" class="headerlink" title="4、用户记录"></a>4、用户记录</h4><p>用户所有插入的记录都存放在这里，默认情况下记录跟记录之间没有间隙，但是如果重用了已删除记录的空间，就会导致空间碎片。每个记录都有指向下一个记录的指针，但是没有指向上一个记录的指针。记录按照主键顺序排序。即，用户可以从数据页最小记录开始遍历，直到最大的记录，这包括了所有正常的记录和所有被delete-marked记录，但是不会访问到被删除的记录(PAGE_FREE)。</p>
<h4 id="5、Free-Space"><a href="#5、Free-Space" class="headerlink" title="5、Free Space"></a>5、Free Space</h4><p>从PAGEHEAPTOP开始，到最后一个数据目录，这之间的空间就是空闲空间，都被重置为0，当用户需要插入记录时候，首先在被删除的记录的空间中查找，如果没有找到合适的空间，就从这里分配。空间分配给记录后，需要递增PAGENRECS和PAGENHEAP。</p>
<h4 id="6、Page-Directory"><a href="#6、Page-Directory" class="headerlink" title="6、Page Directory"></a>6、Page Directory</h4><p>用户的记录是从低地址向高地址扩展，而数据目录则相反。在数据页被初始化的时候，就会在数据页最后(当然在checksum之前)创建两个数据目录，分别指向最大和最小记录。之后插入新的数据的时候，需要维护这个目录，例如必要的时候增加目录的个数。每个数据目录占用两个字节，存储对应记录的页内偏移量。假设目录N，这个目录N管理目录N-1(不包括)和目录N之间的记录，我们称目录N own 这些记录。在目录N指向的记录中，会有字段记录own记录的数量。由此可见，目录own的记录不能太多，因为太多的话，即意味着目录太过稀疏，不能很好的提高查询效率，但同时也不能own太少，这会导致目录数量变多，占用过多的空间。在InnoDB的实现中，目录own的记录数量在4-8之间，包括4和8，平均是6个记录。如果超过这个数量，就需要重新均衡目录的数量。目录的增加和删除可能需要进行内存拷贝，但是由于目录占用的总体空间很小，开销可以忽略不计。</p>
<h4 id="7、File-Trailer"><a href="#7、File-Trailer" class="headerlink" title="7、File Trailer"></a>7、File Trailer</h4><p>这个部分处于数据页最后的位置，只有8个字节。低地址的四个字节存储checksum的值，高地址的四个字节存储FILPAGELSN的低位四字节。注意这里的checksum的值不一定与FILPAGESPACEORCHKSUM的相同，这个依赖不同的checksum计算方法。</p>
<p>找到一张比较不错的page结构图</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9sZ05xVm50bHM3T2liaWFYSlBMSHl6aGVUc3B6QUFTVXhSalZYM0gwSk95ZktpYkNlYmNyS05rVGpUbzAyeElNdVhZamZMZEc3TDByRmVBZUxrajZUaWFpYmliZy82NDA?x-oss-process=image/format,png" alt="img"></p>
<h2 id="高度为3的B-树能存多少数据？"><a href="#高度为3的B-树能存多少数据？" class="headerlink" title="高度为3的B+树能存多少数据？"></a>高度为3的B+树能存多少数据？</h2><p>非叶子节点(4+6)&#x3D;10b</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line">    <span class="type">int</span>*children;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非叶子节点每页可以存16kb&#x2F;10b&#x3D;1638个节点</p>
<p>第二层可以有1638页，每页1638个节点</p>
<p>第三层为叶子节点，一页可以存16kb&#x2F;1kb&#x3D;16个</p>
<p>最终$1638<em>1638</em>16$个</p>
<h2 id="Innodb是如何支持范围查找能走索引的？"><a href="#Innodb是如何支持范围查找能走索引的？" class="headerlink" title="Innodb是如何支持范围查找能走索引的？"></a>Innodb是如何支持范围查找能走索引的？</h2><p>举个例子</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">index(a)</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> a<span class="operator">&gt;</span><span class="number">6</span>;</span><br></pre></td></tr></table></figure>

<p>内部执行过程是：先执行a&#x3D;6 找到6对应的值，然后返回后面的结果即可。</p>
<h2 id="为什么要遵守最左前缀才能利用到索引？"><a href="#为什么要遵守最左前缀才能利用到索引？" class="headerlink" title="为什么要遵守最左前缀才能利用到索引？"></a>为什么要遵守最左前缀才能利用到索引？</h2><p>最左前缀原则指的是，如果查询的时候查询条件精确匹配索引的左边连续一列或几列，则此列就可以被用到</p>
<p>如User表的name和city加联合索引就是(name,city)</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name<span class="operator">=</span>xx <span class="keyword">and</span> city<span class="operator">=</span>xx ; ／／可以命中索引</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name<span class="operator">=</span>xx ; <span class="operator">/</span><span class="operator">/</span> 可以命中索引</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> city<span class="operator">=</span>xx ; <span class="operator">/</span><span class="operator">/</span> 无法命中索引  </span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> city<span class="operator">=</span>xx <span class="keyword">and</span> name<span class="operator">=</span>xx ; ／／可以命中索引  </span><br><span class="line"> </span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> name <span class="keyword">is</span>  <span class="keyword">null</span>;<span class="operator">/</span><span class="operator">/</span>可以命中索引，使用<span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span> 会失效 </span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;zs&#x27;</span> <span class="keyword">and</span> address<span class="operator">=</span><span class="string">&#x27;beijing&#x27;</span>; <span class="operator">/</span><span class="operator">/</span>name用到了索引     </span><br></pre></td></tr></table></figure>

<h2 id="范围查找导致索引失效原理"><a href="#范围查找导致索引失效原理" class="headerlink" title="范围查找导致索引失效原理"></a>范围查找导致索引失效原理</h2><p>这种情况出现在辅助索引上。</p>
<p>考虑以下</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index(b,c,d) <span class="keyword">on</span> table1;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> table1 <span class="keyword">where</span> b<span class="operator">&gt;</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>这时候执行explain语句会发现mysql走了全表扫描。</p>
<p>这是因为mysql的辅助索引存储的具体的索引字段信息，而叶子节点存储主键索引+数据，为了要找到b&gt;1的数据，需要先在非聚集索引中找到对应的主键，再根据主键索引，查找对应的行数据，等于走了两遍B+树进行搜索，如果数据量接近全表数据量的话，比全表扫描还低，这时mysql就会走全表扫描。</p>
<h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><p>如果查询的字段，是已有的索引，且符合最左前缀原则，则可以直接走索引，这叫覆盖索引。</p>
<h2 id="索引扫描底层原则"><a href="#索引扫描底层原则" class="headerlink" title="索引扫描底层原则"></a>索引扫描底层原则</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">考虑如下</span><br><span class="line"><span class="keyword">create</span> index(b) <span class="keyword">on</span> table1;</span><br><span class="line"><span class="keyword">select</span> b <span class="keyword">from</span> table1;</span><br></pre></td></tr></table></figure>

<p>这时候主键索引会扫描更多数据，就会走索引。</p>
<h2 id="Order-By导致索引失效"><a href="#Order-By导致索引失效" class="headerlink" title="Order By导致索引失效"></a>Order By导致索引失效</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index(b,c,d) <span class="keyword">on</span> table1;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> table1 <span class="keyword">order</span> <span class="keyword">by</span> (a,b,c);</span><br></pre></td></tr></table></figure>

<p>此时如果数据量比较少的话，排序时间短，全表扫描快。如果数据量大，走索引会更快，虽然会回表，但比排序快。</p>
<h2 id="Mysql-数据类型转换有哪些需要注意"><a href="#Mysql-数据类型转换有哪些需要注意" class="headerlink" title="Mysql 数据类型转换有哪些需要注意"></a>Mysql 数据类型转换有哪些需要注意</h2><p>charset:字符集</p>
<p>collation:对应国家字符集的排序规则</p>
<p> mysql只把字符转成数字</p>
<h2 id="对字符进行操作索引失效的原理"><a href="#对字符进行操作索引失效的原理" class="headerlink" title="对字符进行操作索引失效的原理"></a>对字符进行操作索引失效的原理</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index(e) <span class="keyword">on</span> table1;<span class="operator">/</span><span class="operator">/</span> e为字符</span><br><span class="line"><span class="keyword">select</span> e <span class="keyword">from</span> <span class="keyword">where</span> e<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样会走全表扫描。因为mysql需要先把e字段所有数据转换成数字，然后比较。这样走全表扫描更方便。</p>
<h2 id="Mysql有哪些存储引擎"><a href="#Mysql有哪些存储引擎" class="headerlink" title="Mysql有哪些存储引擎"></a>Mysql有哪些存储引擎</h2><p><strong>InnoDB</strong>默认存储引擎，事务型存储引擎。设计用来处理大量短期事务。</p>
<p><strong>MyISAM</strong>5.1之前默认存储引擎，但不支持事务和行级锁，且崩溃后无法安全回复。</p>
<p><strong>Memory存储引擎</strong>比MyISAM快一个数量级。数据文件存在内存中，表结构在重启后保留，数据会丢失。一般保存中间数据。</p>
<p><strong>Archive引擎</strong>只支持INSERT和Select，会缓存所有的写并利用zlib对插入的行进行压缩。但每次SELECT都需要全表扫描。适合日志和数据采集。</p>
<p><strong>CSV引擎</strong>可以将普通的CSV文件作为Mysql表处理，但不支持索引。常作为数据交换。</p>
<h2 id="MyISAM和InnoDB区别（前innodb后myisam"><a href="#MyISAM和InnoDB区别（前innodb后myisam" class="headerlink" title="MyISAM和InnoDB区别（前innodb后myisam)"></a>MyISAM和InnoDB区别（前innodb后myisam)</h2><p>一个支持事务，一个不支持事务</p>
<p>一个锁最小粒度是行锁，一个是表锁</p>
<p>innodb不保存具体行数，而myisam保存，所以进行全表查询，myisam更快。</p>
<p>一个是聚集索引，一个是非聚集索引。myisam主键索引和辅助索引独立，但innodb是在一起的。</p>
<p>innodb支持外键，myisam不支持。</p>
<h2 id="字段优先级"><a href="#字段优先级" class="headerlink" title="字段优先级"></a>字段优先级</h2><p>优先使用长度短，定长的数值型字段。避免使用ZEROFILL</p>
<p>整形&gt;date,time&gt;enum char&gt;varchar&gt;blob,text</p>
<h2 id="Varchar-M-最多存储多少数据"><a href="#Varchar-M-最多存储多少数据" class="headerlink" title="Varchar(M)最多存储多少数据"></a>Varchar(M)最多存储多少数据</h2><p>最多存储65535字节(2^16-1)个字节</p>
<h2 id="事务并发引发的问题"><a href="#事务并发引发的问题" class="headerlink" title="事务并发引发的问题"></a>事务并发引发的问题</h2><p><strong>脏读</strong>事务A读取到事务B未提交的数据</p>
<p><strong>不可重复读</strong>事务A读了两次a，但两次读之间事务B修改了数据a，导致事务B在两次读取出来的数据不一致。</p>
<p><strong>幻读</strong>与不可重复读类似，但第二次读到了事务A增加出来的新数据，而不是修改了的数据a</p>
<h2 id="简单描述Mysql索引"><a href="#简单描述Mysql索引" class="headerlink" title="简单描述Mysql索引"></a>简单描述Mysql索引</h2><p>按字段 主键，唯一索引，普通，前缀索引</p>
<p>其中前缀索引是对二进制类型字段或者字符串类型的前几个字符简历索引。</p>
<h2 id="三星索引"><a href="#三星索引" class="headerlink" title="三星索引"></a>三星索引</h2><p> 一个查询相关的索引行是相邻的或者至少相距足够靠近，则一星</p>
<p>如果索引中数据顺序和查找中排列顺序一直，则二星</p>
<p>如果索引中的列包含了查询需要的全部列则三星。</p>
<h2 id="Mysql存放多少行"><a href="#Mysql存放多少行" class="headerlink" title="Mysql存放多少行"></a>Mysql存放多少行</h2><p>2千多万行</p>
<h2 id="提高Insert性能"><a href="#提高Insert性能" class="headerlink" title="提高Insert性能"></a>提高Insert性能</h2><p>多条合并为一条 </p>
<p>调大大批量插入的缓存大小</p>
<p>手动使用事务 默认一次提交一条，可以手动设置为1000条提交一次事务</p>
<h2 id="全局锁、共享锁、排它锁"><a href="#全局锁、共享锁、排它锁" class="headerlink" title="全局锁、共享锁、排它锁"></a>全局锁、共享锁、排它锁</h2><p>全局锁，全局被锁，数据库只读</p>
<p><strong>共享锁</strong>其他事务可并发读。如果事务多读锁进行修改，容易死锁</p>
<p><strong>排它锁</strong>只能事务A读写数据，其他事务只能读。排它锁会阻塞所有排它锁和共享锁。</p>
<h2 id="Mysql-读写分离"><a href="#Mysql-读写分离" class="headerlink" title="Mysql 读写分离"></a>Mysql 读写分离</h2><p>主库写，从库读</p>
<p>关于主从库数据同步，依赖于binlog日志文件，只记录修改操作。</p>
<p>主从结构中，从库会复制一份binlog，然后写一份relay log（中继日志）。启动一个sql线程，执行binlog里的insert和update，这样主从库数据同步。</p>
<h2 id="Mysql分库分表"><a href="#Mysql分库分表" class="headerlink" title="Mysql分库分表"></a>Mysql分库分表</h2><p>水平拆分 - hash原理 （uid%size)&#x3D;hashcode</p>
<p>根据时间拆分 </p>
<h2 id="聚簇索引和非聚簇索引"><a href="#聚簇索引和非聚簇索引" class="headerlink" title="聚簇索引和非聚簇索引"></a>聚簇索引和非聚簇索引</h2><p>聚簇索引：数据和索引放一块儿，找到索引就找到数据，且数据的物理存放顺序和索引顺序一直</p>
<p>非聚簇索引：叶子节点不存储数据，存储的数据行的地址。</p>
</p><div class="tip">本文采用CC-BY-SA-3.0协议，转载请注明出处<br>Author: Dalong</div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-03-22</span><a class="tag" href="/categories/面试/" title="面试">面试 </a><i class="fa fa-tag"></i><a class="tag" href="/tags/mysql/" title="mysql">mysql </a><span class="leancloud_visitors"></span><span>About2682words, 8min56secread</span></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="" onclick="javascript:join_favorite()" ref="sidebar"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,https://drewew.github.io/2022/03/22/【Mysql】Mysql面试题整理/,Dalong's Blog,【Mysql】Mysql面试题整理,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2022/03/22/%E3%80%90Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%912039-%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B2%E7%9A%84%E6%97%B6%E5%88%BB/" title="【Leetcode刷题笔记】2039 网络空闲的时刻">Post Anterior</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2022/03/21/%E3%80%90Java%E3%80%91Java%E6%9C%89%E5%93%AA%E4%BA%9B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/" title="【Java】Java有哪些类加载器">Próximo post</a></li></ul></div><script src="/js/visitors.js"></script></div></div></div></div><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/add-bookmark.js"></script><script>(function(window){var INSIGHT_CONFIG={TRANSLATION:{POSTS:"Posts",PAGES:"Pages",CATEGORIES:"Categories",TAGS:"Tags",UNTITLED:"(Untitled)",},CONTENT_URL:"/content.json",};window.INSIGHT_CONFIG=INSIGHT_CONFIG})(window);</script><script src="/js/insight.js" defer></script><div class="searchbox ins-search"><div class="searchbox-container ins-search-container"><div class="searchbox-input-wrapper"><input class="searchbox-input ins-search-input" type="text" placeholder="Search..."><span class="searchbox-close"><a class="fa fa-times-circle" onclick="closeWindow();"></a></span></div><div class="searchbox-result-wrapper ins-section-wrapper"><div class="ins-section-container"><p>Seraching...</p></div></div></div></div><script src="/js/baidu-tongji.js"></script></body></html>