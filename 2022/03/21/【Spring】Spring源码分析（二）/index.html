<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Dalong"><title>【Spring】Spring源码分析（二） · Dalong's Blog</title><meta name="description" content="Spring启动流程
首先，对于一个web应用，其部署在web容器(tomcat)中，web容器提供其一个全局的上下文环境，这个上下文就是ServletContext，其为后面的spring IoC容器提供宿主环境；
spring容器启动流程
定位在spring中，使用统一的资源表现方式Resour"><meta name="keywords" content="Blog,博客"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="shortcut icon" type="image/x-icon" href="/images/favicon.webp"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/insight.css"><link rel="stylesheet" href="/css/search.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script src="/js/jquery.js"></script><meta name="generator" content="Hexo 6.1.0"></head><body><div class="page-top animated fadeInDown"><div class="nav"><li> <a href="/">Home</a></li><li> <a href="/archives">归档</a></li><li> <a href="/tags">Tags</a></li></div><div class="information"><div class="nav_right_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li><li><a class="fa fa-search" onclick="openWindow();"></a></li></div><div class="avatar"><img src="/images/avatar.webp"></div></div></div><div class="sidebar animated fadeInDown"><div class="sidebar-top"><div class="logo-title"><div class="title"><img src="/images/avatar.webp" style="width:200px;" alt="favicon"><h3 title=""><a href="/">Dalong's Blog</a></h3><div class="description"><p>随便写写</p></div></div><ul class="social-links"><li><a target="_blank" rel="noopener" href="https://github.com/dReWeW"><i class="fa fa-github"></i></a></li><li><a href="mailto:dalongzd@qq.com"><i class="fa fa-envelope"></i></a></li><li><a target="_blank" rel="noopener" href="http://sighttp.qq.com/authd?IDKEY=569775346"><i class="fa fa-qq"></i></a></li></ul></div></div><div class="footer"><div class="p"> <span> 全站CC-BY-SA-3.0 </span><i class="fa fa-star"></i><span> Dalong</span></div><div class="by_farbox"><span>Powered by </span><a href="https://hexo.io/zh-cn/" target="_blank">Hexo </a><span> & </span><span>Anatolo </span></div><div class="beian"></div></div></div><div class="main"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>【Spring】Spring源码分析（二）</a></h3></div><div class="post-content"><p><h2 id="Spring启动流程"><a href="#Spring启动流程" class="headerlink" title="Spring启动流程"></a>Spring启动流程</h2><ol>
<li>首先，对于一个<code>web应用</code>，其部署在<code>web容器(tomcat)</code>中，web容器提供其一个<code>全局的上下文环境</code>，这个上下文就是<code>ServletContext</code>，其<code>为后面的spring IoC容器提供宿主环境</code>；</li>
<li>spring容器启动流程<ol>
<li>定位<br>在spring中，使用统一的资源表现方式Resource，定位到spring配置文件。</li>
<li>加载<br>在加载这个过程中，主要工作是<code>读取spring配置文件</code>，<code>解析配置文件中的内容</code>，将这些信息转换成为Spring内容可以理解、使用的<code>BeanDefinition</code>。</li>
<li>注册<br>加载过配置文件后，就将<code>BeanDefinition</code>信息注册到<code>BeanDefinitionRegistry接口</code>中，通常情况下<code>Spring容器</code>的实现类都实现这个接口。<code>注册</code>其实就是把<code>beanName</code>和<code>beanDefinition</code>作为键值对放到beanFactory对象的<code>map</code>。</li>
</ol>
</li>
</ol>
<p>其次，在<code>web.xml</code>中会提供有<code>contextLoaderListener</code>。在<code>web容器启动时</code>，<code>会触发容器初始化事件</code>，此时 <code>contextLoaderListener会监听到这个事件</code>，其<code>contextInitialized方法会被调用</code>，在这个方法中，<code>spring会初始化一个启动上下文</code>，这个上下文被称为<code>根上下文</code>，即<code>WebApplicationContext</code>，这是一个接口类，确切的说，其实际的<code>实现类是 XmlWebApplicationContext</code>：<code>spring的IoC容器</code>，（<strong>定位</strong>）其对应的<code>Bean定义</code>的配置由web.xml中的 <code>context-param</code>标签指定，（<strong>加载</strong>）<code>读取并解析</code>spring配置文件，将这些信息<code>转换成为Spring内容可以理解、使用的BeanDefinition</code>。在这个<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=IoC&spm=1001.2101.3001.7020">IoC</a>容器初始化完毕后，spring以WebApplicationContext.ROOTWEBAPPLICATIONCONTEXTATTRIBUTE为属性Key，将其存储到ServletContext中，便于获取；（<strong>注册</strong>）加载过配置文件后，就<code>将BeanDefinition信息注册到BeanDefinitionRegistry接口中</code>，通常情况下<code>Spring容器的实现类</code>都实现这个接口。在加载完所有Bean Class后，开始有序的通过BeanDefinition实例化Bean。</p>
<p><img src="https://img-blog.csdnimg.cn/2019031915533150.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzZG5saWppbmdyYW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ol start="3">
<li>再次，<code>contextLoaderListener监听器初始化完毕后</code>，<code>开始初始化web.xml中配置的Servlet</code>，这里是<code>DispatcherServlet</code>，这个servlet实际上是一个<code>标准的前端控制器</code>，<code>用以转发、匹配、处理每个servlet请求</code>。DispatcherServlet上下文<code>在初始化的时候会建立自己的IoC上下文</code>，<code>用以持有spring mvc相关的bean</code>。在<code>建立DispatcherServlet自己的IoC上下文时</code>，会利用WebApplicationContext.ROOTWEBAPPLICATIONCONTEXTATTRIBUTE 先从ServletContext中<code>获取之前的根上下文</code>(即WebApplicationContext)作为自己上下文的parent上下文。<code>有了这个 parent上下文之后</code>，<code>再初始化自己持有的上下文</code>。这个DispatcherServlet初始化自己上下文的工作在其initStrategies方法中可以看到，<strong>大概的工作就是</strong> <code>初始化处理器映射、视图解析等</code>。这个servlet自己持有的上下文默认实现类也是 mlWebApplicationContext。初始化完毕后，spring以与servlet的名字相关(此处不是简单的以servlet名为 Key，而是通过一些转换，具体可自行查看源码)的属性为属性Key，<code>也将其存到ServletContext中</code>，以便后续使用。这样每个servlet 就持有自己的上下文，即拥有自己独立的bean空间，同时各个servlet共享相同的bean，即根上下文(第2步中初始化的上下文)定义的那些 bean。</li>
</ol>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/moshenglv/article/details/53517343">(44条消息) 【Spring启动过程分析】（1）启动流程简介_程序员面试经验分享的博客-CSDN博客_spring启动流程</a></p>
</blockquote>
<h3 id="Refresh流程"><a href="#Refresh流程" class="headerlink" title="Refresh流程"></a>Refresh流程</h3><p>refresh源代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123;</span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="built_in">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">      <span class="type">StartupStep</span> <span class="variable">contextRefresh</span> <span class="operator">=</span> <span class="built_in">this</span>.applicationStartup.start(<span class="string">&quot;spring.context.refresh&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">      prepareRefresh();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">      <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">      prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">         postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="type">StartupStep</span> <span class="variable">beanPostProcess</span> <span class="operator">=</span> <span class="built_in">this</span>.applicationStartup.start(<span class="string">&quot;spring.context.beans.post-process&quot;</span>);</span><br><span class="line">         <span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">         invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">         registerBeanPostProcessors(beanFactory);</span><br><span class="line">         beanPostProcess.end();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Initialize message source for this context.</span></span><br><span class="line">         initMessageSource();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">         initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">         onRefresh();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">         registerListeners();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">         finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">         finishRefresh();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">         <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">         destroyBeans();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">         cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Propagate exception to caller.</span></span><br><span class="line">         <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line">         <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">         resetCommonCaches();</span><br><span class="line">         contextRefresh.end();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>SpringMVC是Spring的后续产品，融合在Srping Web Flow里面。Spring 框架提供了构件Web应用程序的全功能MVC模块，使用Spring可插入的MVC架构，从而在使用Spring进行Web开发时，可以选择使用SpringMVC或者其他MVC框架进行开发。</p>
<ul>
<li>SringMVC通过一套注解，让普通Java类称为Servlet controller,实现了控制层与Servlet的解耦。传统servlet需要一个请求对应一个Servlet对象。当有多种请求存在时，将会创建大量的servlet对象。而springmvc可以一个controller对应多个servlet请求</li>
<li>支持Rest风格的Url写法</li>
<li>采用松耦合</li>
</ul>
<p><strong>MVC</strong>设计理念</p>
<ul>
<li>M- model  模型层 DAO封装(MyBatis,JPA)</li>
<li>V- view 视图层 前端</li>
<li>C- controller 控制层 Servlet封装</li>
</ul>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><img src="http://m.qpic.cn/psc?/V51tJwXe303oBN0L3hL04alyjr4AX6ez/45NBuzDIW489QBoVep5mcYTHjTBC4MftBTApiv4RYrFU6Mh.1qDXKuCfPWfy9ozTpCi4IigSgVJ3FI6gp1z4MktHmxpwmzJ2frCh5GykmtM!/b&bo=pQM2AgAAAAADN4A!&rf=viewer_4" alt="image-20220322152827960"></p>
<p><strong>DispatcherServlet</strong></p>
<p>用户请求到达前端控制器，是整个流程控制的中心，由它调用其他组件处理用户的请求，降低组件之间的耦合性。</p>
<p><strong>HandlerMapping</strong></p>
<p>HandlerMapping负责根据用户请求找到Handler即对应的处理器。SpringMVC提供了不同映射器的实现不同的映射方式。例如配置文件，注解，实现接口等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">AbstractDetectingUrlHandlerMapping</span><br><span class="line">AbstractHandlerMapping</span><br><span class="line">AbstractHandlerMethodMapping</span><br><span class="line">AbstractUrlHandlerMapping</span><br><span class="line">BeanNameUrlHandlerMapping</span><br><span class="line">MatchableHandlerMapping</span><br><span class="line">PathPatternMatchableHandlerMapping</span><br><span class="line">PathSettingHandlerMapping in HandlerMappingIntrospector</span><br><span class="line">RequestMappingHandlerMapping</span><br><span class="line">RequestMappingInfoHandlerMapping</span><br><span class="line">RouterFunctionMapping</span><br><span class="line">SimpleUrlHandlerMapping</span><br><span class="line">WebMvcPropertySourcedRequestMappingHandlerMapping</span><br><span class="line">WelcomePageHandlerMapping</span><br></pre></td></tr></table></figure>

<p><strong>HandlerAdapter</strong></p>
<p>处理器适配器。通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器执行。</p>
<p><strong>Handler</strong></p>
<p>它就是我们开发中要编写的具体业务控制器。由<code>DispatcherServlet</code>把用户请求转发到<code>Handler</code>。</p>
<p><strong>View Resolver</strong></p>
<p>负责将处理结果生成View视图，View Resolver首先根据逻辑视图名解析成物理师徒名，即具体的页面地址，再生成view视图对象，最后对View进行渲染将处理结果通过页面展示返回给用户</p>
<p><strong>View</strong></p>
<p>SpringMVC框架提供了很多View视图类型的支持。包括<code>JstlView,freemakerView,pdfView</code>,最常用jsp</p>
</p><div class="tip">本文采用CC-BY-SA-3.0协议，转载请注明出处<br>Author: Dalong</div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-03-21</span><a class="tag" href="/categories/Spring/" title="Spring">Spring </a><i class="fa fa-tag"></i><a class="tag" href="/tags/源码分析/" title="源码分析">源码分析 </a><span class="leancloud_visitors"></span><span>About1647words, 5min29secread</span></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="" onclick="javascript:join_favorite()" ref="sidebar"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,https://drewew.github.io/2022/03/21/【Spring】Spring源码分析（二）/,Dalong's Blog,【Spring】Spring源码分析（二）,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2022/03/21/%E3%80%90Java%E3%80%91Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" title="【Java】Java并发编程">Post Anterior</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2022/03/19/%E3%80%90Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%91606-%E6%A0%B9%E6%8D%AE%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%9B%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2/" title="【Leetcode刷题笔记】606 根据二叉树创建字符串">Próximo post</a></li></ul></div><script src="/js/visitors.js"></script></div></div></div></div><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/add-bookmark.js"></script><script>(function(window){var INSIGHT_CONFIG={TRANSLATION:{POSTS:"Posts",PAGES:"Pages",CATEGORIES:"Categories",TAGS:"Tags",UNTITLED:"(Untitled)",},CONTENT_URL:"/content.json",};window.INSIGHT_CONFIG=INSIGHT_CONFIG})(window);</script><script src="/js/insight.js" defer></script><div class="searchbox ins-search"><div class="searchbox-container ins-search-container"><div class="searchbox-input-wrapper"><input class="searchbox-input ins-search-input" type="text" placeholder="Search..."><span class="searchbox-close"><a class="fa fa-times-circle" onclick="closeWindow();"></a></span></div><div class="searchbox-result-wrapper ins-section-wrapper"><div class="ins-section-container"><p>Seraching...</p></div></div></div></div><script src="/js/baidu-tongji.js"></script></body></html>