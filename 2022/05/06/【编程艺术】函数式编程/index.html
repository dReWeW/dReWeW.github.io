<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Dalong"><title>【编程艺术】函数式编程 · Dalong's Blog</title><meta name="description" content="Java Stream提供了强大的功能，它可以帮助我们摆脱命令式编程，而更加关注代码的语义，实现函数式编程。举个简单的例子，通常我们需要寻找数组最小值时我们会这样写
1234567int[] nums=new int[10];int min=Integer.MAX_VALUE;for (int j "><meta name="keywords" content="Blog,博客"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="shortcut icon" type="image/x-icon" href="/images/favicon.webp"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/insight.css"><link rel="stylesheet" href="/css/search.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script src="/js/jquery.js"></script><meta name="generator" content="Hexo 6.1.0"></head><body><div class="page-top animated fadeInDown"><div class="nav"><li> <a href="/">Home</a></li><li> <a href="/archives">Archives</a></li><li> <a href="/tags">Tags</a></li></div><div class="information"><div class="nav_right_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li><li><a class="fa fa-search" onclick="openWindow();"></a></li></div><div class="avatar"><img src="/images/avatar.webp"></div></div></div><div class="sidebar animated fadeInDown"><div class="sidebar-top"><div class="logo-title"><div class="title"><img src="/images/avatar.webp" style="width:200px;" alt="favicon"><h3 title=""><a href="/">Dalong's Blog</a></h3><div class="description"><p>随便写写</p></div></div><ul class="social-links"><li><a target="_blank" rel="noopener" href="https://github.com/dReWeW"><i class="fa fa-github"></i></a></li><li><a href="mailto:dalongzd@qq.com"><i class="fa fa-envelope"></i></a></li><li><a target="_blank" rel="noopener" href="http://sighttp.qq.com/authd?IDKEY=569775346"><i class="fa fa-qq"></i></a></li></ul></div></div><div class="footer"><div class="p"> <span> 全站CC-BY-SA-3.0 </span><i class="fa fa-star"></i><span> Dalong</span></div><div class="by_farbox"><span>Powered by </span><a href="https://hexo.io/zh-cn/" target="_blank">Hexo </a><span> & </span><span>Anatolo </span></div><div class="beian"></div></div></div><div class="main"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>【编程艺术】函数式编程</a></h3></div><div class="post-content"><p><p>Java Stream提供了强大的功能，它可以帮助我们摆脱命令式编程，而更加关注代码的语义，实现函数式编程。举个简单的例子，通常我们需要寻找数组最小值时我们会这样写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] nums=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> min=Integer.MAX_VALUE;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(nums[j]&lt;min)&#123;</span><br><span class="line">        min=nums[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但使用Stream后我们可以把代码简化成如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IntStream.of(nums).min().getAsInt();</span><br></pre></td></tr></table></figure>

<p>可能有人觉得这区别也不大，那么我再设想一个情况。加入我们寻找最小的数组有100万大小，那我们必须要考虑使用多线程优化这个过程。那么在传统的命令式编程中，我可能需要手动地去创建线程池，使用快排的思想对于数组进行分区查找等等。这样写下来可能就是上百行代码。这样的编程不仅阅读性差，而且费时费力。但如果使用Stream流编程，代码则可以这样写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IntStream.of(nums).parallel().min().getAsInt();</span><br><span class="line"><span class="comment">// parallel会多线程地去执行stream流函数</span></span><br></pre></td></tr></table></figure>

<p>这样的区别就相当明显了。使用函数式编程可以使代码语义更加明确，</p>
<hr>
<blockquote>
<p>关于流函数编程效率的讨论，这里引用一篇非常专业的分析文章<br>版权声明：本文为CSDN博主「Al_assad」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/Al_assad/article/details/82356606">https://blog.csdn.net/Al_assad/article/details/82356606</a></p>
</blockquote>
<h2 id="JDK8-Stream-数据流效率分析"><a href="#JDK8-Stream-数据流效率分析" class="headerlink" title="JDK8 Stream 数据流效率分析"></a>JDK8 Stream 数据流效率分析</h2><p>Stream 是Java SE 8类库中新增的关键抽象，它被定义于 java.util.stream （这个包里有若干流类型： Stream<T> 代表对象引用流，此外还有一系列特化流，如 IntStream，LongStream，DoubleStream等 ），Java 8 引入的的Stream主要用于取代部分Collection的操作，每个流代表一个值序列，流提供一系列常用的聚集操作，可以便捷的在它上面进行各种运算。集合类库也提供了便捷的方式使我们可以以操作流的方式使用集合、数组以及其它数据结构；</p>
<h3 id="stream-的操作种类"><a href="#stream-的操作种类" class="headerlink" title="stream 的操作种类"></a>stream 的操作种类</h3><p>①中间操作 </p>
<ul>
<li>当数据源中的数据上了流水线后，这个过程对数据进行的所有操作都称为“中间操作”；</li>
<li>中间操作仍然会返回一个流对象，因此多个中间操作可以串连起来形成一个流水线；</li>
<li>stream 提供了多种类型的中间操作，如 filter、distinct、map、sorted 等等；</li>
</ul>
<p>②终端操作 </p>
<ul>
<li><p>当所有的中间操作完成后，若要将数据从流水线上拿下来，则需要执行终端操作；</p>
</li>
<li><p>stream 对于终端操作，可以直接提供一个中间操作的结果，或者将结果转换为特定的 collection、array、String 等；</p>
</li>
</ul>
<p>这一部分详细的说明可以参见：JDK8 Stream 详细使用</p>
<h3 id="stream-的特点"><a href="#stream-的特点" class="headerlink" title="stream 的特点"></a>stream 的特点</h3><p>①只能遍历一次：</p>
<p>数据流的从一头获取数据源，在流水线上依次对元素进行操作，当元素通过流水线，便无法再对其进行操作，可以重新在数据源获取一个新的数据流进行操作；</p>
<p>②采用内部迭代的方式：</p>
<p>对Collection进行处理，一般会使用 Iterator 遍历器的遍历方式，这是一种外部迭代；</p>
<p>而对于处理Stream，只要申明处理方式，处理过程由流对象自行完成，这是一种内部迭代，对于大量数据的迭代处理中，内部迭代比外部迭代要更加高效；</p>
<h3 id="stream-相对于-Collection-的优点"><a href="#stream-相对于-Collection-的优点" class="headerlink" title="stream 相对于 Collection 的优点"></a>stream 相对于 Collection 的优点</h3><p>无存储：流并不存储值；流的元素源自数据源（可能是某个数据结构、生成函数或I&#x2F;O通道等等），通过一系列计算步骤得到；<br>函数式风格：对流的操作会产生一个结果，但流的数据源不会被修改；<br>惰性求值：多数流操作（包括过滤、映射、排序以及去重）都可以以惰性方式实现。这使得我们可以用一遍遍历完成整个流水线操作，并可以用短路操作提供更高效的实现；<br>无需上界：不少问题都可以被表达为无限流（infinite stream）：用户不停地读取流直到满意的结果出现为止（比如说，枚举 完美数 这个操作可以被表达为在所有整数上进行过滤）；集合是有限的，但流可以表达为无线流；<br>代码简练：对于一些collection的迭代处理操作，使用 stream 编写可以十分简洁，如果使用传统的 collection 迭代操作，代码可能十分啰嗦，可读性也会比较糟糕；</p>
<h3 id="stream-和-iterator-迭代的效率比较"><a href="#stream-和-iterator-迭代的效率比较" class="headerlink" title="stream 和 iterator 迭代的效率比较"></a>stream 和 iterator 迭代的效率比较</h3><p>好了，上面 stream 的优点吹了那么多，stream 函数式的写法是很舒服，那么 steam 的效率到底怎样呢？</p>
<p><strong>先说结论</strong>：</p>
<ul>
<li><p>传统 iterator (for-loop) 比 stream(JDK8) 迭代性能要高，尤其在小数据量的情况下；</p>
</li>
<li><p>在多核情景下，对于大数据量的处理，parallel stream 可以有比 iterator 更高的迭代处理效率；</p>
</li>
</ul>
<p>我分别对一个随机数列 List （数量从 10 到 10000000）进行映射、过滤、排序、规约统计、字符串转化场景下，对使用 stream 和 iterator 实现的运行效率进行了统计，测试代码 基准测试代码链接</p>
<p>测试环境如下：</p>
<p>System：Ubuntu 16.04 xenial</p>
<p>CPU：Intel Core i7-8550U</p>
<p>RAM：16GB</p>
<p>JDK version：1.8.0_151</p>
<p>JVM：HotSpot(TM) 64-Bit Server VM (build 25.151-b12, mixed mode)</p>
<p>JVM Settings:</p>
<pre><code>-Xms1024m

-Xmx6144m

-XX:MaxMetaspaceSize=512m

-XX:ReservedCodeCacheSize=1024m

-XX:+UseConcMarkSweepGC

-XX:SoftRefLRUPolicyMSPerMB=100
</code></pre>
<ol>
<li>映射处理测试</li>
</ol>
<p>把一个随机数列（List<Integer>）中的每一个元素自增1后，重新组装为一个新的 List<Integer>，测试的随机数列容量从 10 - 10000000，跑10次取平均时间；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//stream</span></span><br><span class="line">List&lt;Integer&gt; result = list.stream()</span><br><span class="line">.mapToInt(x -&gt; x)</span><br><span class="line">.map(x -&gt; ++x)</span><br><span class="line">.boxed()</span><br><span class="line">.collect(Collectors.toCollection(ArrayList::<span class="keyword">new</span>));</span><br><span class="line"><span class="comment">//iterator</span></span><br><span class="line">List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(Integer e : list)&#123;</span><br><span class="line">    result.add(++e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//parallel stream</span></span><br><span class="line">List&lt;Integer&gt; result = list.parallelStream()</span><br><span class="line">.mapToInt(x -&gt; x)</span><br><span class="line">.map(x -&gt; ++x)</span><br><span class="line">.boxed()</span><br><span class="line">.collect(Collectors.toCollection(ArrayList::<span class="keyword">new</span>));</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdn.net/20180903232153503?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FsX2Fzc2Fk/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<ol start="2">
<li>过滤处理测试</li>
</ol>
<p>取出一个随机数列（List<Integer>）中的大于 200 的元素，并组装为一个新的 List<Integer>，测试的随机数列容量从 10 - 10000000，跑10次取平均时间；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//stream</span></span><br><span class="line">List&lt;Integer&gt; result = list.stream()</span><br><span class="line">.mapToInt(x -&gt; x)</span><br><span class="line">.filter(x -&gt; x &gt; <span class="number">200</span>)</span><br><span class="line">.boxed()</span><br><span class="line">.collect(Collectors.toCollection(ArrayList::<span class="keyword">new</span>));</span><br><span class="line"><span class="comment">//iterator</span></span><br><span class="line">List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list.size());</span><br><span class="line"><span class="keyword">for</span>(Integer e : list)&#123;</span><br><span class="line">    <span class="keyword">if</span>(e &gt; <span class="number">200</span>)&#123;</span><br><span class="line">        result.add(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//parallel stream</span></span><br><span class="line">List&lt;Integer&gt; result = list.parallelStream()</span><br><span class="line">.mapToInt(x -&gt; x)</span><br><span class="line">.filter(x -&gt; x &gt; <span class="number">200</span>)</span><br><span class="line">.boxed()</span><br><span class="line">.collect(Collectors.toCollection(ArrayList::<span class="keyword">new</span>));</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdn.net/20180903232219230?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FsX2Fzc2Fk/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<ol start="3">
<li>自然排序测试</li>
</ol>
<p>对一个随机数列（List<Integer>）进行自然排序，并组装为一个新的 List<Integer>，iterator 使用的是 Collections # sort API（使用归并排序算法实现），测试的随机数列容量从 10 - 10000000，跑10次取平均时间；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//stream</span></span><br><span class="line">List&lt;Integer&gt; result = list.stream()</span><br><span class="line">.mapToInt(x-&gt;x)</span><br><span class="line">.sorted()</span><br><span class="line">.boxed()</span><br><span class="line">.collect(Collectors.toCollection(ArrayList::<span class="keyword">new</span>));</span><br><span class="line"><span class="comment">//iterator</span></span><br><span class="line">List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list);</span><br><span class="line">Collections.sort(result);</span><br><span class="line"><span class="comment">//parallel stream</span></span><br><span class="line">List&lt;Integer&gt; result = list.parallelStream()</span><br><span class="line">.mapToInt(x-&gt;x)</span><br><span class="line">.sorted()</span><br><span class="line">.boxed()</span><br><span class="line">.collect(Collectors.toCollection(ArrayList::<span class="keyword">new</span>));</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdn.net/20180903232259436?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FsX2Fzc2Fk/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<ol start="4">
<li>归约统计测试</li>
</ol>
<p>获取一个随机数列（List<Integer>）的最大值，测试的随机数列容量从 10 - 10000000，跑10次取平均时间；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//stream</span></span><br><span class="line"><span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> list.stream()</span><br><span class="line">.mapToInt(x -&gt; x)</span><br><span class="line">.max()</span><br><span class="line">.getAsInt();</span><br><span class="line"><span class="comment">//iterator</span></span><br><span class="line"><span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(Integer e : list)&#123;</span><br><span class="line">    <span class="keyword">if</span>(e &gt; max)&#123;</span><br><span class="line">        max = e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//parallel stream</span></span><br><span class="line"><span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> list.parallelStream()</span><br><span class="line">.mapToInt(x -&gt; x)</span><br><span class="line">.max()</span><br><span class="line">.getAsInt();</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdn.net/201809032323401?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FsX2Fzc2Fk/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<ol start="5">
<li>字符串拼接测试</li>
</ol>
<p>获取一个随机数列（List<Integer>）各个元素使用“,”分隔的字符串，测试的随机数列容量从 10 - 10000000，跑10次取平均时间；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//stream</span></span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> list.stream().map(String::valueOf).collect(Collectors.joining(<span class="string">&quot;,&quot;</span>));</span><br><span class="line"><span class="comment">//iterator</span></span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"><span class="keyword">for</span>(Integer e : list)&#123;</span><br><span class="line">    builder.append(e).append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> builder.length() == <span class="number">0</span> ? <span class="string">&quot;&quot;</span> : builder.substring(<span class="number">0</span>,builder.length() - <span class="number">1</span>);</span><br><span class="line"><span class="comment">//parallel stream</span></span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> list.stream().map(String::valueOf).collect(Collectors.joining(<span class="string">&quot;,&quot;</span>));</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdn.net/20180903232420958?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FsX2Fzc2Fk/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<ol start="6">
<li>混合操作测试</li>
</ol>
<p>对一个随机数列（List<Integer>）进行去空值，除重，映射，过滤，并组装为一个新的 List<Integer>，测试的随机数列容量从 10 - 10000000，跑10次取平均时间；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//stream</span></span><br><span class="line">List&lt;Integer&gt; result = list.stream()</span><br><span class="line">.filter(Objects::nonNull)</span><br><span class="line">.mapToInt(x -&gt; x + <span class="number">1</span>)</span><br><span class="line">.filter(x -&gt; x &gt; <span class="number">200</span>)</span><br><span class="line">.distinct()</span><br><span class="line">.boxed()</span><br><span class="line">.collect(Collectors.toCollection(ArrayList::<span class="keyword">new</span>));</span><br><span class="line"><span class="comment">//iterator</span></span><br><span class="line">HashSet&lt;Integer&gt; set  = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(list.size());</span><br><span class="line"><span class="keyword">for</span>(Integer e : list)&#123;</span><br><span class="line">    <span class="keyword">if</span>(e != <span class="literal">null</span> &amp;&amp; e &gt; <span class="number">200</span>)&#123;</span><br><span class="line">        set.add(e + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(set);</span><br><span class="line"><span class="comment">//parallel stream</span></span><br><span class="line">List&lt;Integer&gt; result = list.parallelStream()</span><br><span class="line">.filter(Objects::nonNull)</span><br><span class="line">.mapToInt(x -&gt; x + <span class="number">1</span>)</span><br><span class="line">.filter(x -&gt; x &gt; <span class="number">200</span>)</span><br><span class="line">.distinct()</span><br><span class="line">.boxed()</span><br><span class="line">.collect(Collectors.toCollection(ArrayList::<span class="keyword">new</span>));</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdn.net/20180903232503325?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FsX2Fzc2Fk/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p>实验结果总结</p>
<p>从以上的实验来看，可以总结处以下几点：</p>
<ul>
<li><p>在少低数据量的处理场景中（size&lt;&#x3D;1000），stream 的处理效率是不如传统的 iterator 外部迭代器处理速度快的，但是实际上这些处理任务本身运行时间都低于毫秒，这点效率的差距对普通业务几乎没有影响，反而 stream 可以使得代码更加简洁；</p>
</li>
<li><p>在大数据量（szie&gt;10000）时，stream 的处理效率会高于 iterator，特别是使用了并行流，在cpu恰好将线程分配到多个核心的条件下（当然parallel stream 底层使用的是 JVM 的 ForkJoinPool，这东西分配线程本身就很玄学），可以达到一个很高的运行效率，然而实际普通业务一般不会有需要迭代高于10000次的计算；</p>
</li>
<li><p>Parallel Stream 受引 CPU 环境影响很大，当没分配到多个cpu核心时，加上引用 forkJoinPool 的开销，运行效率可能还不如普通的 Stream；</p>
</li>
</ul>
<p>使用 Stream 的建议</p>
<ul>
<li><p>简单的迭代逻辑，可以直接使用 iterator，对于有多步处理的迭代逻辑，可以使用 stream，损失一点几乎没有的效率，换来代码的高可读性是值得的；</p>
</li>
<li><p>单核 cpu 环境，不推荐使用 parallel stream，在多核 cpu 且有大数据量的条件下，推荐使用 paralle stream；</p>
</li>
<li><p>stream 中含有装箱类型，在进行中间操作之前，最好转成对应的数值流，减少由于频繁的拆箱、装箱造成的性能损失；</p>
</li>
</ul>
</p><div class="tip">本文采用CC-BY-SA-3.0协议，转载请注明出处<br>Author: Dalong</div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-05-06</span><a class="tag" href="/categories/Java/" title="Java">Java </a><i class="fa fa-tag"></i><a class="tag" href="/tags/编程艺术/" title="编程艺术">编程艺术 </a><a class="tag" href="/tags/Java进阶/" title="Java进阶">Java进阶 </a><span class="leancloud_visitors"></span><span>About2690words, 8min58secread</span></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="" onclick="javascript:join_favorite()" ref="sidebar"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,https://drewew.github.io/2022/05/06/【编程艺术】函数式编程/,Dalong's Blog,【编程艺术】函数式编程,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2022/05/06/%E3%80%90%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%E3%80%91%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B2/" title="【编程艺术】函数式编程2">Post Anterior</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2022/03/28/%E3%80%90%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E3%80%91%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/" title="【基础算法】二分查找">Próximo post</a></li></ul></div><script src="/js/visitors.js"></script></div></div></div></div><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/add-bookmark.js"></script><script>(function(window){var INSIGHT_CONFIG={TRANSLATION:{POSTS:"Posts",PAGES:"Pages",CATEGORIES:"Categories",TAGS:"Tags",UNTITLED:"(Untitled)",},CONTENT_URL:"/content.json",};window.INSIGHT_CONFIG=INSIGHT_CONFIG})(window);</script><script src="/js/insight.js" defer></script><div class="searchbox ins-search"><div class="searchbox-container ins-search-container"><div class="searchbox-input-wrapper"><input class="searchbox-input ins-search-input" type="text" placeholder="Search..."><span class="searchbox-close"><a class="fa fa-times-circle" onclick="closeWindow();"></a></span></div><div class="searchbox-result-wrapper ins-section-wrapper"><div class="ins-section-container"><p>Seraching...</p></div></div></div></div><script src="/js/baidu-tongji.js"></script></body></html>