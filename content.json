{"pages":[],"posts":[{"title":"【Leetcode刷题笔记】1219 黄金矿工","text":"题目描述你要开发一座金矿，地质勘测学家已经探明了这座金矿中的资源分布，并用大小为 m * n 的网格 grid 进行了标注。每个单元格中的整数就表示这一单元格中的黄金数量；如果该单元格是空的，那么就是 0。 为了使收益最大化，矿工需要按以下规则来开采黄金： 每当矿工进入一个单元，就会收集该单元格中的所有黄金。 矿工每次可以从当前位置向上下左右四个方向走。 每个单元格只能被开采（进入）一次。 不得开采（进入）黄金数目为 0 的单元格。 矿工可以从网格中 任意一个 有黄金的单元格出发或者是停止。 示例 1： 1234567输入：grid = [[0,6,0],[5,8,7],[0,9,0]]输出：24解释：[[0,6,0], [5,8,7], [0,9,0]]一种收集最多黄金的路线是：9 -&gt; 8 -&gt; 7。 示例 2： 123456789输入：grid = [[1,0,7],[2,0,6],[3,4,5],[0,3,0],[9,0,20]]输出：28解释：[[1,0,7], [2,0,6], [3,4,5], [0,3,0], [9,0,20]]一种收集最多黄金的路线是：1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; 7。 提示： 1 &lt;= grid.length, grid[i].length &lt;= 15 0 &lt;= grid[i][j] &lt;= 100 最多 25 个单元格中有黄金。 题解这是一道典型的多源DFS题目。从每个不是0的单元格出发遍历每条可能的路径，记录最大挖矿值。 代码如下 12345678910111213141516171819202122232425262728293031323334353637class Solution { public static final int[][] dirs = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}}; int res = 0; int[][] grid; int m; int n; public int getMaximumGold(int[][] grid) { this.grid = grid; m = grid.length; n = grid[0].length; for (int i = 0; i &lt; m; i++) { for (int j = 0; j &lt; n; j++) { if (grid[i][j] != 0) { dfs(i, j, 0); } } } return res; } private void dfs(int x, int y, int gold) { gold += grid[x][y]; res = Math.max(res, gold); int rec = grid[x][y]; grid[x][y] = 0; for (int[] dir : dirs) { int nx = x + dir[0], ny = y + dir[1]; if (nx &lt; m &amp;&amp; nx &gt;= 0 &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; n &amp;&amp; grid[nx][ny] != 0) { dfs(nx, ny, gold); } } grid[x][y] = rec; }} 复杂度 空间复杂度O(1) 时间复杂度O(3^T)","link":"/2022/02/25/%E3%80%90Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%911219%20%E9%BB%84%E9%87%91%E7%9F%BF%E5%B7%A5/"},{"title":"【Leetcode刷题笔记】1601 最多可达成的换楼请求","text":"问题我们有 n 栋楼，编号从 0 到 n - 1 。每栋楼有若干员工。由于现在是换楼的季节，部分员工想要换一栋楼居住。 给你一个数组 requests ，其中 requests[i] = [fromi, toi] ，表示一个员工请求从编号为 fromi 的楼搬到编号为 toi 的楼。 一开始 所有楼都是满的，所以从请求列表中选出的若干个请求是可行的需要满足 每栋楼员工净变化为 0 。意思是每栋楼 离开 的员工数目 等于 该楼 搬入 的员工数数目。比方说 n = 3 且两个员工要离开楼 0 ，一个员工要离开楼 1 ，一个员工要离开楼 2 ，如果该请求列表可行，应该要有两个员工搬入楼 0 ，一个员工搬入楼 1 ，一个员工搬入楼 2 。 请你从原请求列表中选出若干个请求，使得它们是一个可行的请求列表，并返回所有可行列表中最大请求数目。 题解根据题目，n&lt;=20，所以可以用二进制枚举每一种可能。 代码Java代码，双指针 123456789101112131415161718192021222324252627282930class Solution { public int maximumRequests(int n, int[][] requests) { int[] delta = new int[n]; int ans = 0, m = requests.length; for (int mask = 0; mask &lt; (1 &lt;&lt; m); ++mask) { int cnt = Integer.bitCount(mask); if (cnt &lt;= ans) { continue; } Arrays.fill(delta, 0); for (int i = 0; i &lt; m; ++i) { if ((mask &amp; (1 &lt;&lt; i)) != 0) { ++delta[requests[i][0]]; --delta[requests[i][1]]; } } boolean flag = true; for (int x : delta) { if (x != 0) { flag = false; break; } } if (flag) { ans = cnt; } } return ans; }} 复杂度 时间复杂度O(2^m*n) 空间复杂度O(n)","link":"/2022/02/28/%E3%80%90Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%911601%20%E6%9C%80%E5%A4%9A%E5%8F%AF%E8%BE%BE%E6%88%90%E7%9A%84%E6%8D%A2%E6%A5%BC%E8%AF%B7%E6%B1%82/"},{"title":"【Leetcode刷题笔记】三数之和","text":"问题给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。 注意：答案中不可以包含重复的三元组。 1234567891011示例 1：输入：nums = [-1,0,1,2,-1,-4]输出：[[-1,-1,2],[-1,0,1]]示例 2：输入：nums = []输出：[]示例 3：输入：nums = [0]输出：[] 提示： 0 &lt;= nums.length &lt;= 3000-105 &lt;= nums[i] &lt;= 105 题解Leetcode第一题两数之和为我提供了思路，实际上稍微思考就可以将问题转换为N个两数之和的问题。 由于本人做两数之和的时间已经比较久远，忘记了其多种做法，这里列出两种思路 先排序，然后三层循环遍历求解。时间复杂度O(n3)，空间复杂度O(1)。 双指针 先排序 建立N个两数之和问题，即对数组中每个数做两数之和求解，只不过求和目标值不是0，而是’-nums[i]’。 ①如果nums[i]&gt;0，直接不用做两数之和的问题。因为数组已排序，说明后面的数都是&gt;0，因而可以直接返回结果 ②如果nums[i]&lt;=0，设置两个指针j=i+1,k=n-1. ​ 设置while条件(j&lt;k) ​ if(nums[j]+nums[k]&gt;tmp): k向前移动 if(*nums*[j]+*nums*[k]&lt;tmp): j向后移动 ​ if(nums[j]+nums[k]==tmp): 加入结果数组 ​ 去重操作 事件复杂度O(n2),O(1) 代码Java代码，双指针 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution { public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) { int n = nums.length; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); // return empty set if(n&lt;3){ return res; } Arrays.sort(nums); for(int i=0;i&lt;n-2;i++){ if(nums[i]&gt;0){ break; } int tmp=-nums[i]; int j=i+1,k=n-1; while(j&lt;k){ if(nums[j]+nums[k]&gt;tmp){ k--; }else if(nums[j]+nums[k]&lt;tmp){ j++; }else if(nums[j]+nums[k]==tmp){ res.add(new ArrayList&lt;Integer&gt;(Arrays.asList(nums[i],nums[j],nums[k]))); while(j&lt;n-1&amp;&amp;nums[j]==nums[j+1]){ j++; } while(k&gt;0&amp;&amp;nums[k]==nums[k-1]){ k--; } j++; k--; if(!(j&lt;k)){ break; } } } while(i&lt;n-2&amp;&amp;nums[i]==nums[i+1]){ i++; } } return res; }} 成绩","link":"/2022/02/17/%E3%80%90Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%9115%20%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"},{"title":"【Leetcode刷题笔记】18 四数之和","text":"题目描述给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）： 0 &lt;= a, b, c, d &lt; n a、b、c 和 d 互不相同 nums[a] + nums[b] + nums[c] + nums[d] == target 你可以按 任意顺序 返回答案 。 示例 1： 12输入：nums = [1,0,-1,0,-2,2], target = 0输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]] 示例 2： 12输入：nums = [2,2,2,2,2], target = 8输出：[[2,2,2,2]] 提示： 1 &lt;= nums.length &lt;= 200 -109 &lt;= nums[i] &lt;= 109 -109 &lt;= target &lt;= 109 Related Topics 数组 双指针 排序 题解参照 1 两数之和 以及 15 三数之和的方法，我们可以将其分解为$n^2$​个两数之和问题。对于任意nums[i]+nums[j]，我们需要在剩下的数组中寻找两数和为target-nums[i]-nums[j]。 需要注意，去重通过，每当完成一层遍历时，跳过该层遍历已经使用过的使用过的数即可。 代码12345678910111213141516171819202122232425262728293031323334353637class Solution { public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) { List&lt;List&lt;Integer&gt;&gt; lists = new ArrayList&lt;List&lt;Integer&gt;&gt;(); Arrays.sort(nums); int n = nums.length; for (int i = 0; i &lt; n; i++) { for (int j = i + 1; j &lt; n; j++) { int tar = target - nums[i] - nums[j]; int k = j + 1, l = n - 1; while (k &lt; l) { if (nums[k] + nums[l] &gt; tar) { l--; } else if (nums[k] + nums[l] &lt; tar) { k++; } else if (nums[k] + nums[l] == tar) { lists.add(Arrays.asList(nums[i],nums[j],nums[k],nums[l])); while (k + 1 &lt; n &amp;&amp; nums[k] == nums[k + 1] &amp;&amp; k &lt; l) { k++; } while (l - 1 &gt; j &amp;&amp; nums[l] == nums[l - 1] &amp;&amp; k &lt; l) { l--; } k++; l--; } } while(j+1&lt;n&amp;&amp;nums[j]==nums[j+1]){ j++; } } while (i+1&lt;n&amp;&amp;nums[i]==nums[i+1]){ i++; } } return lists; }} 复杂度分析 时间复杂度 O(n3+nlogn) 空间复杂度O(C)，其中C = 解的个数","link":"/2022/02/23/%E3%80%90Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%9118%20%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/"},{"title":"【Leetcode刷题笔记】1706 球会落何处","text":"题目描述用一个大小为 m x n 的二维网格 grid 表示一个箱子。你有 n 颗球。箱子的顶部和底部都是开着的。 箱子中的每个单元格都有一个对角线挡板，跨过单元格的两个角，可以将球导向左侧或者右侧。 将球导向右侧的挡板跨过左上角和右下角，在网格中用 1 表示。 将球导向左侧的挡板跨过右上角和左下角，在网格中用 -1 表示。 在箱子每一列的顶端各放一颗球。每颗球都可能卡在箱子里或从底部掉出来。如果球恰好卡在两块挡板之间的 “V” 形图案，或者被一块挡导向到箱子的任意一侧边上，就会卡住。 返回一个大小为 n 的数组 answer ，其中 answer[i] 是球放在顶部的第 i 列后从底部掉出来的那一列对应的下标，如果球卡在盒子里，则返回 -1 。 示例 1： 12345678输入：grid = [[1,1,1,-1,-1],[1,1,1,-1,-1],[-1,-1,-1,1,1],[1,1,1,1,-1],[-1,-1,-1,-1,-1]]输出：[1,-1,-1,-1,-1]解释：示例如图：b0 球开始放在第 0 列上，最终从箱子底部第 1 列掉出。b1 球开始放在第 1 列上，会卡在第 2、3 列和第 1 行之间的 &quot;V&quot; 形里。b2 球开始放在第 2 列上，会卡在第 2、3 列和第 0 行之间的 &quot;V&quot; 形里。b3 球开始放在第 3 列上，会卡在第 2、3 列和第 0 行之间的 &quot;V&quot; 形里。b4 球开始放在第 4 列上，会卡在第 2、3 列和第 1 行之间的 &quot;V&quot; 形里。 示例 2： 123输入：grid = [[-1]]输出：[-1]解释：球被卡在箱子左侧边上。 示例 3： 12输入：grid = [[1,1,1,1,1,1],[-1,-1,-1,-1,-1,-1],[1,1,1,1,1,1],[-1,-1,-1,-1,-1,-1]]输出：[0,1,2,3,4,-1] 提示： m == grid.length n == grid[i].length 1 &lt;= m, n &lt;= 100 grid[i][j] 为 1 或 -1 Related Topics 深度优先搜索 数组 动态规划 矩阵 模拟 题解由于此题每一层的出口都直接由上一层的导板方向所影响，所以只需要在向下遍历每一层的同时，维护当前层出口的dp数组即可。 123456789101112131415161718192021222324252627282930class Solution { public int[] findBall(int[][] grid) { // dp[n] // 状态转移方程如下 // if(grid[row][dp[col]]==1&amp;&amp;grid[row][dp[col]+1]==1 dp[col]+=1; // if(grid[row][dp[col]]==1&amp;&amp;grid[row][dp[col]+1]==-1 dp[col]=-1; // if(grid[row][dp[col]]==-1&amp;&amp;grid[row][dp[col]-1]==-1 dp[col]-=1; // if(grid[row][dp[col]]==-1&amp;&amp;grid[row][dp[col]-1]==1 dp[col]=-1; int m = grid.length; int n = grid[0].length; int[] dp = new int[n]; for (int i = 0; i &lt; n; i++) { dp[i] = i; } for (int row = 0; row &lt; m; row++) { for (int col = 0; col &lt; n; col++) { if (dp[col] != -1) { if (grid[row][dp[col]] == -1 &amp;&amp; dp[col] - 1 &gt;= 0 &amp;&amp; grid[row][dp[col] - 1] == -1) { dp[col] -= 1; } else if (grid[row][dp[col]] == 1 &amp;&amp; dp[col] + 1 &lt; n &amp;&amp; grid[row][dp[col] + 1] == 1) { dp[col] += 1; } else { dp[col] = -1; } } } } return dp; }} 复杂度分析 时间复杂度 O(mn+n) 空间复杂度O(n)","link":"/2022/02/24/%E3%80%90Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%911706%20%E7%90%83%E4%BC%9A%E8%90%BD%E4%BD%95%E5%A4%84/"},{"title":"【Leetcode刷题笔记】2044 统计按位或能得到最大值的子集数目","text":"题目描述 给你一个整数数组 nums ，请你找出 nums 子集 按位或 可能得到的 最大值 ，并返回按位或能得到最大值的 不同非空子集的数目 。 如果数组 a 可以由数组 b 删除一些元素（或不删除）得到，则认为数组 a 是数组 b 的一个 子集 。如果选中的元素下标位置不一样，则认为两个子集 不同 。 对数组 a 执行 按位或 ，结果等于 a[0] **OR** a[1] **OR** ... **OR** a[a.length - 1]（下标从 0 开始）。 示例 1： 12345输入：nums = [3,1]输出：2解释：子集按位或能得到的最大值是 3 。有 2 个子集按位或可以得到 3 ：- [3]- [3,1] 示例 2： 123输入：nums = [2,2,2]输出：7解释：[2,2,2] 的所有非空子集的按位或都可以得到 2 。总共有 23 - 1 = 7 个子集。 示例 3： 123456789输入：nums = [3,2,1,5]输出：6解释：子集按位或可能的最大值是 7 。有 6 个子集按位或可以得到 7 ：- [3,5]- [3,1,5]- [3,2,5]- [3,2,1,5]- [2,5]- [2,1,5] 提示： 1 &lt;= nums.length &lt;= 16 1 &lt;= nums[i] &lt;= 105 题解解决此题需要解决两个主要问题： 如何保证遍历到nums的所有子集 如何保证不重复 我们知道，对于一个集合的所有子集，当集合添加了新的元素，其新子集等于在原子集上增添新的元素。然后对新子集依次按位或，统计和更新最大值和个数即可。这样做的时间复杂度是$O(2^n*n)$，这是第一种暴力解法。 分析可以发现，新子集的按位或结果，是原子集按位或结果再与新元素按位或后的结果。这个操作是$O(1)$的复杂度，因而总的时间复杂度可以优化到$O(2^n)$，对应法二的回溯法 代码法一： 暴力 1234567891011121314151617181920212223242526272829303132333435363738394041import java.util.ArrayList;import java.util.Arrays;import java.util.List;import java.util.stream.Collectors;class Solution { int max; int res; public int countMaxOrSubsets(int[] nums) { // 生成nums的所有子集 List&lt;List&lt;Integer&gt;&gt; subsets = getSubsets(nums); return res; } private List&lt;List&lt;Integer&gt;&gt; getSubsets(int[] nums) { List&lt;List&lt;Integer&gt;&gt; allSubSets = new ArrayList&lt;&gt;(); // 空集 allSubSets.add(new ArrayList&lt;&gt;()); // 每个元素可以与现有子集组合，生成res.size()个新子集 for (int num : nums) { int size = allSubSets.size(); for (int i = 0; i &lt; size; i++) { List&lt;Integer&gt; subset = new ArrayList&lt;&gt;(allSubSets.get(i)); subset.add(num); int or = subset.stream().reduce(0, (a, b) -&gt; a | b); // 如果or大于max，则更新max，重置res // 如果or等于max，则res++ if (or &gt; max) { max = or; res = 1; } else if (or == max) { res++; } allSubSets.add(subset); } } return allSubSets; }} 法二：回溯 1234567891011121314151617181920212223242526272829303132333435import java.util.ArrayList;import java.util.Arrays;import java.util.List;import java.util.stream.Collectors;class Solution { int max; int res; int[] nums; public int countMaxOrSubsets(int[] nums) { // 生成nums的所有子集 this.nums=nums; backtrack(0,0); return res; } // 回溯 private void backtrack(int val,int index){ // 如果index等于nums.length时，则比较val与max的值 // 二叉树保证不会产生重复的结果，但必须要遍历到最后一个节点 if(nums.length==index){ if(val&gt;max){ max=val; res=1; }else if(val==max){ res++; } return; } backtrack(val|nums[index],index+1); backtrack(val,index+1); }}","link":"/2022/03/15/%E3%80%90Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%912044%20%E7%BB%9F%E8%AE%A1%E6%8C%89%E4%BD%8D%E6%88%96%E8%83%BD%E5%BE%97%E5%88%B0%E6%9C%80%E5%A4%A7%E5%80%BC%E7%9A%84%E5%AD%90%E9%9B%86%E6%95%B0%E7%9B%AE/"},{"title":"【Leetcode刷题笔记】1994 好子集数目","text":"题目描述 给你一个整数数组 nums 。如果 nums 的一个子集中，所有元素的乘积可以表示为一个或多个 互不相同的质数 的乘积，那么我们称它为 好子集 。 比方说，如果 1nums = [1, 2, 3, 4] [2, 3] ，[1, 2, 3] 和 [1, 3] 是 好 子集，乘积分别为 6 = 23 ，6 = 23 和 3 = 3 。 [1, 4] 和 [4] 不是 好 子集，因为乘积分别为 4 = 22 和 4 = 22 请你返回 nums 中不同的 好 子集的数目对 109 + 7 取余 的结果。 nums 中的 子集 是通过删除 nums 中一些（可能一个都不删除，也可能全部都删除）元素后剩余元素组成的数组。如果两个子集删除的下标不同，那么它们被视为不同的子集。 示例 1： 123456789输入：nums = [1,2,3,4]输出：6解释：好子集为：- [1,2]：乘积为 2 ，可以表示为质数 2 的乘积。- [1,2,3]：乘积为 6 ，可以表示为互不相同的质数 2 和 3 的乘积。- [1,3]：乘积为 3 ，可以表示为质数 3 的乘积。- [2]：乘积为 2 ，可以表示为质数 2 的乘积。- [2,3]：乘积为 6 ，可以表示为互不相同的质数 2 和 3 的乘积。- [3]：乘积为 3 ，可以表示为质数 3 的乘积。 示例 2： 12345678输入：nums = [4,2,3,15]输出：5解释：好子集为：- [2]：乘积为 2 ，可以表示为质数 2 的乘积。- [2,3]：乘积为 6 ，可以表示为互不相同质数 2 和 3 的乘积。- [2,15]：乘积为 30 ，可以表示为互不相同质数 2，3 和 5 的乘积。- [3]：乘积为 3 ，可以表示为质数 3 的乘积。- [15]：乘积为 15 ，可以表示为互不相同质数 3 和 5 的乘积。 提示： 1 &lt;= nums.length &lt;= 105 1 &lt;= nums[i] &lt;= 30 题解这道题因为数字范围在[1,30]之间，因而我们可以做以下分类 1 对于任何一个好子集，可以以任何个数存在，且依然是好子集。 4,8 ,9 ,12,16,18,20,24,25,27,28 因为存在平方因子，因而不能存在在好子集中。 2, 3, 5, 6, 7 ,10, 11, 13, 14, 17, 19, 21, 22, 23, 26 , 29, 30 不存在平方因子，因而可以出现在好子集中，且最多出现一次 注意到质数是2, 3, 5, 7, 11, 13, 17, 19, 23, 29，总共十 个。可以用十位二进制数来表示好子集的乘积用了哪些质因子。 后面是动态规划 （这道题背着官方的答案做的。 题解后面再完善完善） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution { public static int[] PRIMES = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29}; public static final int mod = 1000000007; public int numberOfGoodSubsets(int[] nums) { int[] cnt = new int[31]; int n = nums.length; int[] dp = new int[1 &lt;&lt; PRIMES.length]; for (int i = 0; i &lt; n; i++) { cnt[nums[i]]++; } dp[0] = 1; for (int i = 0; i &lt; cnt[1]; i++) { dp[0] = dp[0] * 2 % mod; } for (int i = 2; i &lt; 31; i++) { if (cnt[i] == 0) { continue; } boolean check = true; int subnet = 0; for (int j = 0; j &lt; PRIMES.length; j++) { if (i % (PRIMES[j] * PRIMES[j]) == 0) { check = false; break; } if (i % PRIMES[j] == 0) { subnet |= 1 &lt;&lt; j; } } if (!check) { continue; } for (int mask = (1 &lt;&lt; PRIMES.length) - 1; mask &gt;= subnet; mask--) { if ((mask &amp; subnet) == subnet) { dp[mask] = (int) ((dp[mask] + ((long) dp[mask ^ subnet]) * cnt[i]) % mod); } } } int res=0; for (int mask = 1, maskMax = (1 &lt;&lt; PRIMES.length); mask &lt; maskMax; ++mask) { res = (res + dp[mask]) % mod; } return res; }} 复杂度 空间复杂度O(2^10) 时间复杂度O(30*2^10)","link":"/2022/02/22/%E3%80%90Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%911994%20%E5%A5%BD%E5%AD%90%E9%9B%86%E6%95%B0%E7%9B%AE/"},{"title":"【Leetcode刷题笔记】2049 统计最高分的节点数目","text":"题目描述 给你一棵根节点为 0 的 二叉树 ，它总共有 n 个节点，节点编号为 0 到 n - 1 。同时给你一个下标从 0 开始的整数数组 parents 表示这棵树，其中 parents[i] 是节点 i 的父节点。由于节点 0 是根，所以 parents[0] == -1 。 一个子树的 大小 为这个子树内节点的数目。每个节点都有一个与之关联的 分数 。求出某个节点分数的方法是，将这个节点和与它相连的边全部 删除 ，剩余部分是若干个 非空 子树，这个节点的 分数 为所有这些子树 大小的乘积 。 请你返回有 最高得分 节点的 数目 。 题解得到一个点的分数需要三个部分。n1: 节点左子树节点数 n2:节点右子树节点数 n3:除开节点本身和其子树的剩下的子树的节点数。 $Point=n1n2n3$ $n3=N-n1-n2-1$ 综上可推出求出n1,n2即可求出Point 对于一个节点，dfs其子树，返回遍历到的节点数即可得到其子树的节点数。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution { int[] ans; int n; int[] children1; int[] children2; public int countHighestScoreNodes(int[] parents) { n = parents.length; ans = new int[n]; children1=new int[n]; children2=new int[n]; for (int i = 1; i &lt; n; i++) { if(children1[parents[i]]==0){ children1[parents[i]]=i; }else{ children2[parents[i]]=i; } } dfs( 0, parents); int max = 0; int res = 0; for (int i = 0; i &lt; n; i++) { if (ans[i] &gt; max) { max = ans[i]; res = 1; } else if (ans[i] == max) { res++; } } } private int dfs(int node, int[] parents) { List&lt;Integer&gt; subTreeNodes = new ArrayList&lt;&gt;(); int subNodes = 0; if (children1[node] != 0) { int tmp = dfs( children1[node], parents); subNodes += tmp; subTreeNodes.add(tmp); } if (children2[node] != 0) { int tmp = dfs( children2[node], parents); subNodes += tmp; subTreeNodes.add(tmp); } if (node != 0) subTreeNodes.add(n - subNodes - 1); ans[node] = 1; for (Integer nodes : subTreeNodes) { ans[node] *= nodes; } return subNodes + 1; }} 复杂度 空间复杂度O(n） 时间复杂度O(3*n)","link":"/2022/03/11/%E3%80%90Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%912049%20%E7%BB%9F%E8%AE%A1%E6%9C%80%E9%AB%98%E5%88%86%E7%9A%84%E8%8A%82%E7%82%B9%E6%95%B0%E7%9B%AE/"},{"title":"【Leetcode刷题笔记】21 合并两个有序链表","text":"题解将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例 1： 12输入：l1 = [1,2,4], l2 = [1,3,4]输出：[1,1,2,3,4,4] 示例 2： 12输入：l1 = [], l2 = []输出：[] 示例 3： 12输入：l1 = [], l2 = [0]输出：[0] 提示： 两个链表的节点数目范围是 [0, 50] -100 &lt;= Node.val &lt;= 100 l1 和 l2 均按 非递减顺序 排列 题解注意到题中给出节点数目可以为0，因而需要单独处理数目为0的情况。 由于链表已经有序，因而只需要采用双指针，依次遍历两个链表，将一个链表 s1 合并到另一个链表s2 中即可。 当s1.val&lt;=s2.val&lt;=s1.next.val || s1.next==null 时，s2加入到s1后面。更新s1和s2的值 否则s1=s1.next 代码123456789101112131415161718192021222324252627282930class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { ListNode head1, head2, res; if(list1==null){ return list2; }else if(list2==null){ return list1; } if (list1.val &lt;= list2.val) { head1 = list1; head2 = list2; res = list1; } else { head1 = list2; head2 = list1; res = list2; } while (head2 != null) { if ((head2.val &gt;= head1.val &amp;&amp; head1.next != null &amp;&amp; head2.val &lt;= head1.next.val)||head1.next==null) { ListNode tmp = new ListNode(head2.val, head1.next); head1.next = tmp; head1 = head1.next; head2 = head2.next; } else if(head1.next!=null){ head1 = head1.next; } } return res; }}","link":"/2022/02/23/%E3%80%90Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%9121%20%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"},{"title":"【Leetcode刷题笔记】23 合并K个升序链表","text":"题目描述 给你一个链表数组，每个链表都已经按升序排列。 请你将所有链表合并到一个升序链表中，返回合并后的链表。 示例 1： 12345678910输入：lists = [[1,4,5],[1,3,4],[2,6]]输出：[1,1,2,3,4,4,5,6]解释：链表数组如下：[ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6]将它们合并到一个有序链表中得到。1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6 示例 2： 12输入：lists = []输出：[] 示例 3： 12输入：lists = [[]]输出：[] 提示： k == lists.length 0 &lt;= k &lt;= 10^4 0 &lt;= lists[i].length &lt;= 500 -10^4 &lt;= lists[i][j] &lt;= 10^4 lists[i] 按 升序 排列 lists[i].length 的总和不超过 10^4 题解顺序合并两个链表 代码12345678910111213141516171819202122232425262728293031323334353637class Solution { public ListNode mergeKLists(ListNode[] lists) { ListNode ans=null; int n = lists.length; if(n==0){ return ans; } if(n==1){ return lists[0]; } ans=merge(lists[0],lists[1]); for (int i = 2; i &lt; n; i++) { ans=merge(ans,lists[i]); } return ans; } private ListNode merge(ListNode a, ListNode b) { if (a == null || b == null) { return a != null ? a : b; } ListNode head = new ListNode(0); ListNode tail = head, aPtr = a, bPtr = b; while (aPtr != null &amp;&amp; bPtr != null) { if (aPtr.val &lt; bPtr.val) { tail.next = aPtr; aPtr = aPtr.next; } else { tail.next = bPtr; bPtr = bPtr.next; } tail = tail.next; } tail.next = (aPtr != null ? aPtr : bPtr); return head.next; }} 复杂度 时间复杂度O($k^2n$) 空间复杂度O(1)","link":"/2022/03/11/%E3%80%90Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%9123%20%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/"},{"title":"【Leetcode刷题笔记】393 UTF-8 编码验证","text":"题目描述 给定一个表示数据的整数数组 data ，返回它是否为有效的 UTF-8 编码。 UTF-8 中的一个字符可能的长度为 1 到 4 字节，遵循以下的规则： 对于 1 字节 的字符，字节的第一位设为 0 ，后面 7 位为这个符号的 unicode 码。 对于 n 字节 的字符 (n &gt; 1)，第一个字节的前 n 位都设为1，第 n+1 位设为 0 ，后面字节的前两位一律设为 10 。剩下的没有提及的二进制位，全部为这个符号的 unicode 码。 这是 UTF-8 编码的工作方式： 1234567Char. number range | UTF-8 octet sequence (hexadecimal) | (binary)--------------------+---------------------------------------------0000 0000-0000 007F | 0xxxxxxx0000 0080-0000 07FF | 110xxxxx 10xxxxxx0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 注意：输入是整数数组。只有每个整数的 最低 8 个有效位 用来存储数据。这意味着每个整数只表示 1 字节的数据。 示例 1： 1234输入：data = [197,130,1]输出：true解释：数据表示字节序列:11000101 10000010 00000001。这是有效的 utf-8 编码，为一个 2 字节字符，跟着一个 1 字节字符。 示例 2： 123456输入：data = [235,140,4]输出：false解释：数据表示 8 位的序列: 11101011 10001100 00000100.前 3 位都是 1 ，第 4 位为 0 表示它是一个 3 字节字符。下一个字节是开头为 10 的延续字节，这是正确的。但第二个延续字节不以 10 开头，所以是不符合规则的。 提示: 1 &lt;= data.length &lt;= 2 * 104 0 &lt;= data[i] &lt;= 255 题解位运算 判断编码是否有效，需要解决两个问题： 当前字节是否是单字节字符。 多字节字符有多少位，是否符合格式。 对于问题1，我们准备MASK1(1&lt;&lt;7)来判断 对于问题2，我们依次从高位到低位判断有n个1（n的个数小于等于4个），随后判断后面的n个字节是否以10开头即可。 当不满足以上任一条件时，编码无效。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution { public static final int MASK1=1&lt;&lt;7;// 判断1字节还是n字节 public static final int MASK2=(1&lt;&lt;7)+(1&lt;&lt;6); // 判断编码第一字节还是其他字节 public boolean validUtf8(int[] data) { int n=data.length; int i=0; while (i&lt;n){ if((data[i]&amp;MASK1)==0){ i++; }else{ int nums=6; int maskBytes=1&lt;&lt;nums; int bytes=1; while(nums&gt;0){ if((maskBytes&amp;data[i])==maskBytes){ bytes++; nums--; maskBytes=1&lt;&lt;nums; }else{ break; } } if(nums&lt;3||bytes&lt;2){ return false; } for (int j = 1; j &lt; bytes; j++) { i++; if(i&gt;=n){ return false; } if((data[i]&amp;MASK2)!=MASK1){ return false; } } i++; } } return true; }} 复杂度 空间复杂度O(n） 时间复杂度O(1)","link":"/2022/03/01/%E3%80%90Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%91393%20UTF-8%20%E7%BC%96%E7%A0%81%E9%AA%8C%E8%AF%81/"},{"title":"【Leetcode刷题笔记】504 7进制数","text":"【Leetcode刷题笔记】504 七进制数题目描述 给定一个整数 num，将其转化为 7 进制，并以字符串形式输出。 示例 1: 12输入: num = 100输出: &quot;202&quot; 示例 2: 12输入: num = -7输出: &quot;-10&quot; 提示： -107 &lt;= num &lt;= 107 Related Topics 数学 题解连除即可。 由于需要转换成字符串，需要注意数字的正负。 12345678910111213141516171819class Solution { public String convertToBase7(int num) { int tmp=num; if(num==0){ return &quot;0&quot;; } num=Math.abs(num); StringBuffer res=new StringBuffer(); while (num!=0){ res.append(num%7); num/=7; } if(tmp&lt;0){ res.append('-'); } return res.reverse().toString(); }} 复杂度 空间复杂度O(C) C为除尽num的次数。 时间复杂度O(1)","link":"/2022/03/07/%E3%80%90Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%91504%20%E4%B8%83%E8%BF%9B%E5%88%B6%E6%95%B0/"},{"title":"【Leetcode刷题笔记】589 N叉树的前序遍历","text":"题目描述 给定一个 n 叉树的根节点 root ，返回 其节点值的 前序遍历 。 n 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 null 分隔（请参见示例）。 示例 1： 12输入：root = [1,null,3,2,4,null,5,6]输出：[1,3,5,6,2,4] 示例 2： 12输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]输出：[1,2,3,6,7,11,14,4,8,12,5,9,13,10] 提示： 节点总数在范围 [0, 104]内 0 &lt;= Node.val &lt;= 104 n 叉树的高度小于或等于 1000 题解递归法很简单，搞清楚前序遍历的原理即可。 遍历可使用栈实现，但效率不如递归法。用栈存储每个杰点子节点的迭代器，如果Iterator.hasNext()为真，则把iterator.next()入栈，否则出栈。 代码递归法 12345678910111213141516171819class Solution { List&lt;Integer&gt; res; public List&lt;Integer&gt; preorder(Node root) { res = new ArrayList&lt;&gt;(); preOrderTraverse(root); return res; }private void preOrderTraverse(Node root) { if (root == null) { return; } this.res.add(root.val); Iterator&lt;Node&gt; it = root.children.iterator(); while (it.hasNext()) { preOrderTraverse(it.next()); } }} 遍历法 1234567891011121314151617181920212223242526class Solution { List&lt;Integer&gt; res; public List&lt;Integer&gt; preorder(Node root) { res = new ArrayList&lt;&gt;(); if(root==null){ return res; } res.add(root.val); Stack&lt;Iterator&lt;Node&gt;&gt; stack=new Stack&lt;&gt;(); stack.push(root.children.iterator()); while(!stack.isEmpty()){ Iterator&lt;Node&gt; it=stack.peek(); if(!it.hasNext()){ stack.pop(); }else { Node node=it.next(); res.add(node.val); stack.add(node.children.iterator()); } } return res;// preOrderTraverse(root);// return res; }} 复杂度 时间复杂度O(n)","link":"/2022/03/10/%E3%80%90Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%91589%20N%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/"},{"title":"【Leetcode刷题笔记】6 Z字形变换","text":"题目描述 将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。 比如输入字符串为 &quot;PAYPALISHIRING&quot; 行数为 3 时，排列如下： 123P A H NA P L S I I GY I R 之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：&quot;PAHNAPLSIIGYIR&quot;。 请你实现这个将字符串进行指定行数变换的函数： 1string convert(string s, int numRows); 示例 1： 12输入：s = &quot;PAYPALISHIRING&quot;, numRows = 3输出：&quot;PAHNAPLSIIGYIR&quot; 示例 2： 1234567输入：s = &quot;PAYPALISHIRING&quot;, numRows = 4输出：&quot;PINALSIGYAHRPI&quot;解释：P I NA L S I GY A H RP I 示例 3： 12输入：s = &quot;A&quot;, numRows = 1输出：&quot;A&quot; 提示： 1 &lt;= s.length &lt;= 1000 s 由英文字母（小写和大写）、',' 和 '.' 组成 1 &lt;= numRows &lt;= 1000 题解思路就是，创建一个二维字符数组来存放Z字形字符，然后遍历原字符串，计算出每个字符相应位置。然后遍历二维字符数组一次即可。 123456789101112131415161718192021222324252627class Solution { public String convert(String s, int numRows) { if (numRows==1){ return s; } int n = s.length(); char[] ss = s.toCharArray(); int T = numRows * 2 - 2; int numT = n / T + 1; char[][] res = new char[numRows][numT*(numRows-1)]; for (int i = 0; i &lt; n; i++) { int row = i % T &gt; T / 2 ? T - i % T : i % T; int col = i / T * (T - numRows + 1) + (i % T &gt; T / 2 ? i % T - T / 2 : 0); res[row][col]=ss[i]; } StringBuffer ans=new StringBuffer(); for (int i = 0; i &lt; numRows; i++) { for (int j = 0; j &lt; numT * (numRows - 1); j++) { if (res[i][j]!='\\0'){ ans.append(res[i][j]); } } } return ans.toString(); }} 复杂度 空间复杂度O(n+numrows * (n/(numrows*2-2)) 时间复杂度O(numrows * (n/(numrows*2-2))","link":"/2022/03/01/%E3%80%90Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%916%20Z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/"},{"title":"【Leetcode刷题笔记】599 两个列表最小索引总和","text":"题目描述 假设 Andy 和 Doris 想在晚餐时选择一家餐厅，并且他们都有一个表示最喜爱餐厅的列表，每个餐厅的名字用字符串表示。 你需要帮助他们用最少的索引和找出他们共同喜爱的餐厅。 如果答案不止一个，则输出所有答案并且不考虑顺序。 你可以假设答案总是存在。 示例 1: 123输入: list1 = [&quot;Shogun&quot;, &quot;Tapioca Express&quot;, &quot;Burger King&quot;, &quot;KFC&quot;]，list2 = [&quot;Piatti&quot;, &quot;The Grill at Torrey Pines&quot;, &quot;Hungry Hunter Steakhouse&quot;, &quot;Shogun&quot;]输出: [&quot;Shogun&quot;]解释: 他们唯一共同喜爱的餐厅是“Shogun”。 示例 2: 123输入:list1 = [&quot;Shogun&quot;, &quot;Tapioca Express&quot;, &quot;Burger King&quot;, &quot;KFC&quot;]，list2 = [&quot;KFC&quot;, &quot;Shogun&quot;, &quot;Burger King&quot;]输出: [&quot;Shogun&quot;]解释: 他们共同喜爱且具有最小索引和的餐厅是“Shogun”，它有最小的索引和1(0+1)。 提示: 1 &lt;= list1.length, list2.length &lt;= 1000 1 &lt;= list1[i].length, list2[i].length &lt;= 30 list1[i] 和 list2[i] 由空格 ' ' 和英文字母组成。 list1 的所有字符串都是 唯一 的。 list2 中的所有字符串都是 唯一 的。 题解哈希表 遍历任意一个字符串数组，建立hash表。随后遍历另一个字符串数组，如果hashMap中Key存在分为两种情况： 索引和与当前最小索引和相等，则入栈 索引和比当前最小索引和小，则清空栈再入栈 这里我用长度较小的字符串数组建立HashMap，节省了一些空间开销。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution { class Pair{ public String name; public int sum; public Pair(String name, int sum) { this.name = name; this.sum = sum; } } public String[] findRestaurant(String[] list1, String[] list2) { int n1 = list1.length; int n2 = list2.length; String[] mapString = n1 &lt; n2 ? list2 : list1; String[] cmpString = n1 &lt; n2 ? list1 : list2; Map&lt;String, Integer&gt; nameMap = new HashMap&lt;&gt;(); List&lt;String&gt; res=new ArrayList&lt;&gt;(); Stack&lt;Pair&gt; stack=new Stack&lt;&gt;(); for (int j = 0; j &lt; mapString.length; j++) { nameMap.putIfAbsent(mapString[j], j); } for (int i = 0; i &lt; cmpString.length; i++) { int index=nameMap.getOrDefault(cmpString[i],-1); if (index != -1) { if(!stack.isEmpty()){ if(stack.peek().sum&gt;index+i){ stack.clear(); stack.push(new Pair(cmpString[i],index+i)); }else if(stack.peek().sum==index+i){ stack.push(new Pair(cmpString[i],index+i)); } }else{ stack.push(new Pair(cmpString[i],index+i)); } } } Iterator&lt;Pair&gt; iter=stack.iterator(); while(iter.hasNext()){ res.add(iter.next().name); } return res.toArray(new String[0]); }} 复杂度 空间复杂度O(min(n1,n2)) 时间复杂度O(n1+n2)","link":"/2022/03/14/%E3%80%90Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%91599%20%E4%B8%A4%E4%B8%AA%E5%88%97%E8%A1%A8%E6%9C%80%E5%B0%8F%E7%B4%A2%E5%BC%95%E6%80%BB%E5%92%8C/"},{"title":"【Leetcode刷题笔记】720 词典中最长的单词","text":"题目描述 给出一个字符串数组 words 组成的一本英语词典。返回 words 中最长的一个单词，该单词是由 words 词典中其他单词逐步添加一个字母组成。 若其中有多个可行的答案，则返回答案中字典序最小的单词。若无答案，则返回空字符串。 示例 1： 123输入：words = [&quot;w&quot;,&quot;wo&quot;,&quot;wor&quot;,&quot;worl&quot;, &quot;world&quot;]输出：&quot;world&quot;解释： 单词&quot;world&quot;可由&quot;w&quot;, &quot;wo&quot;, &quot;wor&quot;, 和 &quot;worl&quot;逐步添加一个字母组成。 示例 2： 123输入：words = [&quot;a&quot;, &quot;banana&quot;, &quot;app&quot;, &quot;appl&quot;, &quot;ap&quot;, &quot;apply&quot;, &quot;apple&quot;]输出：&quot;apple&quot;解释：&quot;apply&quot; 和 &quot;apple&quot; 都能由词典中的单词组成。但是 &quot;apple&quot; 的字典序小于 &quot;apply&quot; 提示： 1 &lt;= words.length &lt;= 1000 1 &lt;= words[i].length &lt;= 30 所有输入的字符串 words[i] 都只包含小写字母。 Related Topics 字典树 数组 哈希表 字符串 排序 题解前缀树 前缀树：以空串为根节点，出现新的前缀则增加新的子节点。本题因为是针对单词，因而可以把children设置为长度为26的字符数组。更复杂的情况可能需要使用HashMap来处理。 注意题中要求，如果一个单词不是在已有前缀上增添一个新字母而产生的，则无效。因而我们在节点中增加一个新的值word，来代表是否有单词的终点为此节点。 这样做的好处是在搜索时，如果发现搜索的子节点的word属性为Null，说明该单词不是从已有的派生出来的，此时搜索可以直接返回false。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution { String res; TrieNode root; public String longestWord(String[] words) { root = new TrieNode(); root.word=&quot;&quot;; res=new String(&quot;&quot;); for (String word : words) { TrieNode node = root; for (char c : word.toCharArray()) { if (node.children[c - 'a'] == null) { node.children[c - 'a'] = new TrieNode(); } node = node.children[c - 'a']; } node.word=word; } for(String word:words){ if(search(word)){ if(word.length()&gt;res.length()||(word.length()==res.length())&amp;&amp;word.compareTo(res)&lt;0){ res=word; } } } return res; } private boolean search(String prefix) { TrieNode node=root; for(char c:prefix.toCharArray()){ if(node.children[c-'a'].word==null){ return false; } node=node.children[c-'a']; } return true; } class TrieNode { TrieNode[] children = new TrieNode[26]; String word; }} 复杂度 空间复杂度O(n) 时间复杂度O($\\sum_{0}^{n-1}len(words[i]) $)","link":"/2022/03/17/%E3%80%90Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%91720%20%E8%AF%8D%E5%85%B8%E4%B8%AD%E6%9C%80%E9%95%BF%E7%9A%84%E5%8D%95%E8%AF%8D/"},{"title":"【Leetcode刷题笔记】74 搜索矩阵","text":"题目描述编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性： 每行中的整数从左到右按升序排列。 每行的第一个整数大于前一行的最后一个整数。 示例 1： 12输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3输出：true 示例 2： 12输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13输出：false 提示： m == matrix.length n == matrix[i].length 1 &lt;= m, n &lt;= 100 -104 &lt;= matrix[i][j], target &lt;= 104 题解从矩阵右上角为根，发现根的左节点都小于根值，根的下节点都大于根值，这可以抽象成一棵BST java代码如下 1234567891011121314151617class Solution { public boolean searchMatrix(int[][] matrix, int target) { int height = matrix.length; int row = 0, col = matrix[0].length - 1; while (row != height &amp;&amp; col != -1) { if (matrix[row][col] == target) { return true; } else if (target &gt; matrix[row][col]) { row++; } else if (target &lt; matrix[row][col]) { col--; } } return false; }} 复杂度 空间复杂度 O(1) 时间复杂度O (logmn)","link":"/2022/02/20/%E3%80%90Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%9174%20%E6%90%9C%E7%B4%A2%E7%9F%A9%E9%98%B5/"},{"title":"【Leetcode刷题笔记】917 仅仅反转字母","text":"题目描述难度 hard 给你一个字符串 s ，根据下述规则反转字符串： 所有非英文字母保留在原有位置。 所有英文字母（小写或大写）位置反转。 返回反转后的 s 。 示例 1： 12输入：s = &quot;ab-cd&quot;输出：&quot;dc-ba&quot; 示例 2： 12输入：s = &quot;a-bC-dEf-ghIj&quot;输出：&quot;j-Ih-gfE-dCba&quot; 示例 3： 12输入：s = &quot;Test1ng-Leet=code-Q!&quot;输出：&quot;Qedo1ct-eeLg=ntse-T!&quot; 提示 1 &lt;= s.length &lt;= 100 s 仅由 ASCII 值在范围 [33, 122] 的字符组成 s 不含 '\\&quot;' 或 '\\\\' 题解我们知道翻转字符串的代码往往采用双指针这样写 123456int i=0,j=n-1;while(i&lt;j){ swap(i,j,s); i++; j--;} 这道题要求只对字母进行翻转，因而在指针遇到非字母字符直接跳过即可，遇到字母时直接翻转即可。 代码1234567891011121314151617181920212223class Solution { public String reverseOnlyLetters(String s) { char[] sa = s.toCharArray(); int n = sa.length; int i = 0, j = n - 1; while (i &lt; j) { while (!((sa[i] &gt;= 'a' &amp;&amp; sa[i] &lt;= 'z') || (sa[i] &gt;= 'A' &amp;&amp; sa[i] &lt;= 'Z')) &amp;&amp; i &lt; j) { i++; } while (!((sa[j] &gt;= 'a' &amp;&amp; sa[j] &lt;= 'z') || (sa[j] &gt;= 'A' &amp;&amp; sa[j] &lt;= 'Z')) &amp;&amp; i &lt; j) { j--; } if (i &lt; j) { char tmp = sa[i]; sa[i] = sa[j]; sa[j] = tmp; i++; j--; } } return new String(sa); }}","link":"/2022/02/23/%E3%80%90Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%91917%20%E4%BB%85%E4%BB%85%E5%8F%8D%E8%BD%AC%E5%AD%97%E6%AF%8D/"},{"title":"【Leetcode刷题笔记】 537 复数乘法","text":"题目描述复数 可以用字符串表示，遵循 &quot;**实部**+**虚部**i&quot; 的形式，并满足下述条件： 实部 是一个整数，取值范围是 [-100, 100] 虚部 也是一个整数，取值范围是 [-100, 100] i2 == -1 给你两个字符串表示的复数 num1 和 num2 ，请你遵循复数表示形式，返回表示它们乘积的字符串。 示例 1： 123输入：num1 = &quot;1+1i&quot;, num2 = &quot;1+1i&quot;输出：&quot;0+2i&quot;解释：(1 + i) * (1 + i) = 1 + i2 + 2 * i = 2i ，你需要将它转换为 0+2i 的形式。 示例 2： 123输入：num1 = &quot;1+-1i&quot;, num2 = &quot;1+-1i&quot;输出：&quot;0+-2i&quot;解释：(1 - i) * (1 - i) = 1 + i2 - 2 * i = -2i ，你需要将它转换为 0+-2i 的形式。 提示： num1 和 num2 都是有效的复数表示。 Related Topics 数学 字符串 模拟 题解这道题没什么好说的，直接模拟即可，很简单。 显然此题需要用到分割字符串来获得实数和虚数的数值，我们很容易想到String.split()方法，这里复习一下split()方法的用法： String.split()public String[] split(String regex) Splits this string around matches of the given regular expression. This method works as if by invoking the two-argument split method with the given expression and a limit argument of zero. Trailing empty strings are therefore not included in the resulting array. The string &quot;boo:and:foo&quot;, for example, yields the following results with these expressions: Regex Result : { &quot;boo&quot;, &quot;and&quot;, &quot;foo&quot; } o { &quot;b&quot;, &quot;&quot;, &quot;:and:f&quot; } Parameters: regex - the delimiting regular expression Returns: the array of strings computed by splitting this string around matches of the given regular expression Throws: PatternSyntaxException - if the regular expression’s syntax is invalid Since: 1.4 See Also: Pattern 代码123456789101112131415class Solution { public String complexNumberMultiply(String num1, String num2) { String[] complex1=num1.split(&quot;\\\\+|i&quot;); String[] complex2=num2.split(&quot;\\\\+|i&quot;); int real1=Integer.parseInt(complex1[0]); int imag1=Integer.parseInt(complex1[1]); int real2=Integer.parseInt(complex2[0]); int imag2=Integer.parseInt(complex2[1]); int real=real1*real2-imag1*imag2; int imag=real1*imag2+real2*imag1; String res=String.format(&quot;%d+%di&quot;,real,imag); return res; }} 复杂度 时间空间皆为O(1)","link":"/2022/02/25/%E3%80%90Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%91537%20%E5%A4%8D%E6%95%B0%E4%B9%98%E6%B3%95/"},{"title":"关于使用Anaconda的Pip出现SSL错误","text":"重装anaconda后，使用pip安装包出现以下错误 1ValueError: check_hostname requires server_hostname 以下是stackoverflow上查询到的解决方案 复制以下文件C:\\Users\\MyUser\\Miniconda3\\Library\\bin to C:\\Users\\MyUser\\Miniconda3\\DLLs: libcrypto-1_1-x64.dll libcrypto-1_1-x64.pdb libssl-1_1-x64.dll libssl-1_1-x64.pdb 成功解决问题。 这里贴出问题链接，这个问题里还有很多关于此问题的不同解决办法：pip is configured with locations that require TLS/SSL, however the ssl module in Python is not available - Stack Overflow 解决问题后，再使用pip install时依然出现了问题 12 raise ValueError(&quot;check_hostname requires server_hostname&quot;)ValueError: check_hostname requires server_hostname 问题是因为打开了vpn。注意，类似的问题在使用conda install时也会出现。在安装依赖时请关闭你的vp。","link":"/2021/09/16/%E3%80%90%E6%9D%82%E8%AE%B0%E3%80%91%E5%85%B3%E4%BA%8E%E4%BD%BF%E7%94%A8Anaconda%E7%9A%84Pip%E5%87%BA%E7%8E%B0SSL%E9%94%99%E8%AF%AF/"},{"title":"【JAVA】匿名内部类","text":"匿名内部类是局部内部类的更深入一步。 假如只创建某类的一个对象时，就不必将该类进行命名。 匿名内部类的前提是存在一个类或者接口，且匿名内部类是写在方法中的。 只针对重写一个方法时使用，需要重写多个方法时不建议使用 既然是匿名类，所以你无法在别的地方使用这个类（实例化，调用它的静态方法之类的） 特点的话，除了只能使用一次，其实还有其他用处（在看spring-boot源码时发现的） 当你想使用一个类的protected 方法时，但是又不和这个类在同一个包下，你是没办法调用的。 这时候匿名类就派上用场了，你可以声明一个匿名类继承该类，并定义一个方法，在这个方法内使用super调用你想调用的那个方法（其实你也可以写个类继承这个类，就能调用父类的protected方法了，但是匿名类更简洁，因为你只想调用这个方法而已） 举个栗子： 这个类有一个protected方法test，如果你在其他包下想调用这个protected方法是不行的，可以发现没有提示test方法 这时候你可以使用匿名类继承这个类，定义一个方法callParentTest()，在这个方法体内调用super.test()，最后调用这个callParentTest()即可。 在spring-boot中的HttpMessageConverts里也有用到这种方法 想复用WebMvcConfigurationSupport的getMessageConverter方法，但是定义为protected方法，所以使用匿名类来调用","link":"/2022/03/01/%E3%80%90Java%E3%80%91%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB/"},{"title":"【服务器】服务器配置记录","text":"服务器配置记录Ubuntu安装Docker1curl -sSL https://get.daocloud.io/docker | sh 在 /etc/docker下建立 daemon.json 文件，添加以下内容 123{ &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;]} 重启docker 1systemctl restart docker.service 测试安装成功 1sudo docker run hello-world 安装Redis1234567# 拉取Redis镜像docker pull redis# 查看本地Redis镜像docker images#运行redisdocker run --name myredis -p 6379:6379 -d redis redis-server --appendonly yes docker run - 运行docker name myredis - 名字 -p 6379:6379 - 把服务器的6379端口映射到docker的6379端口，这样可以通过服务器的端口访问docker的端口 -d 表示以后台形式运行redis redis redis-server –appendonly yes 表示开启持久化缓存模式，可以存到硬盘","link":"/2021/10/29/%E3%80%90%E6%9C%8D%E5%8A%A1%E5%99%A8%E3%80%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/"},{"title":"【算法】数独编程","text":"【算法】数独编程思路使用回溯法求解，从左到右从上到下依次求解。当出现错误方案，就回溯到上一层求解中继续判断下一个值的可行性。 时间复杂度最优为O(n²) 最坏为O(n²logn)，空间复杂度为O(n) 输入12345678910int[][] grid = new int[][] { { 0, 0, 5, 3, 0, 0, 0, 0, 0 }, { 8, 0, 0, 0, 0, 0, 0, 2, 0 }, { 0, 7, 0, 0, 1, 0, 5, 0, 0 }, { 4, 0, 0, 0, 0, 5, 3, 0, 0 }, { 0, 1, 0, 0, 7, 0, 0, 0, 6 }, { 0, 0, 3, 2, 0, 0, 0, 8, 0 }, { 0, 6, 0, 5, 0, 0, 0, 0, 9 }, { 0, 0, 4, 0, 0, 0, 0, 3, 0 }, { 0, 0, 0, 0, 0, 9, 7, 0, 0 } }; 输出123456789[1, 4, 5, 3, 2, 7, 6, 9, 8][8, 3, 9, 6, 5, 4, 1, 2, 7][6, 7, 2, 9, 1, 8, 5, 4, 3][4, 9, 6, 1, 8, 5, 3, 7, 2][2, 1, 8, 4, 7, 3, 9, 5, 6][7, 5, 3, 2, 9, 6, 4, 8, 1][3, 6, 7, 5, 4, 2, 8, 1, 9][9, 8, 4, 7, 6, 1, 2, 3, 5][5, 2, 1, 8, 3, 9, 7, 6, 4] 源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687import java.util.Arrays;public class Sudoku { int[][] grid = new int[][] { { 0, 0, 5, 3, 0, 0, 0, 0, 0 }, { 8, 0, 0, 0, 0, 0, 0, 2, 0 }, { 0, 7, 0, 0, 1, 0, 5, 0, 0 }, { 4, 0, 0, 0, 0, 5, 3, 0, 0 }, { 0, 1, 0, 0, 7, 0, 0, 0, 6 }, { 0, 0, 3, 2, 0, 0, 0, 8, 0 }, { 0, 6, 0, 5, 0, 0, 0, 0, 9 }, { 0, 0, 4, 0, 0, 0, 0, 3, 0 }, { 0, 0, 0, 0, 0, 9, 7, 0, 0 } }; int ROWS = 9; int COLS = 9; public static void main(String[] args) { Sudoku sudoku = new Sudoku(); sudoku.BackTrack(0); } /** * @description: (x,y)处是否允许放置num * @param {*} * @return {*} */ Boolean PlaceAllowed(int num, int x, int y) { // 获取x,y所在3*3box的左上角起点位置 int boxStartRow = x / 3 * 3; int boxStartCol = y / 3 * 3; // 行判断 for (int i = 0; i &lt; COLS; i++) { if (y != i &amp;&amp; grid[x][i] == num) { return false; } } // 列判断 for (int i = 0; i &lt; ROWS; i++) { if (x != i &amp;&amp; grid[i][y] == num) { return false; } } // box判断 for (int i = boxStartRow; i &lt; boxStartRow + 3; i++) { for (int j = boxStartCol; j &lt; boxStartCol + 3; j++) { if ((x != i || y != j) &amp;&amp; grid[i][j] == num) { return false; } } } // 上述三种情况都成立，则该位置可以放置num return true; } /** * @description:回溯法 * @param {solvedNums}:当前已解决的数独个数 * @return */ void BackTrack(int solvedNums) { // 如果填满，则求得解，输出结果 if (solvedNums == 81) { for (int i = 0; i &lt; ROWS; i++) { System.out.println(Arrays.toString(grid[i])); } } else { // 获取当前回溯位置的x,y坐标 int x = solvedNums / 9; int y = solvedNums % 9; // 如果当前x,y坐标已经被填充（预置数），则直接开启下一次回溯 if (grid[x][y] != 0) { BackTrack(solvedNums + 1); } else { for (int i = 1; i &lt; 10; i++) { if (PlaceAllowed(i, x, y)) { grid[x][y] = i; BackTrack(solvedNums + 1); } // 如果backtrack函数的 solvedNums 参数未到达81就返回，当前t的填充方案是错误的，需要重置grid[x][y] grid[x][y] = 0; } } } }}","link":"/2021/10/11/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%95%B0%E7%8B%AC%E7%BC%96%E7%A8%8B/"},{"title":"【Redis】源码分析（一）主数据结构分析","text":"Redis String底层数据结构分析Redis的String的数据类型可谓包罗万象，它既可以是一个简单的String，也可以是一个int型，还可以是float型，还可以是一张很大的图片，一首歌曲等。事实上所有的key都会在redis内部转换成一串不定长的字符串。当然，如果单纯用一串字符串来保存String那是不是效率太低了呢？试想一下，我有一个key长度为5，而另一个String长度为100000，那这两个String我应该怎么去分配他的空间呢？如果都用一个很大的空间去存储一个String，那效率就太低了。实际上，redis定义了一个名为sds的数据结构作为key的类型，先来看看他的源码： 1234567891011121314151617181920212223242526272829303132typedef char *sds;/* Note: sdshdr5 is never used, we just access the flags byte directly. * However is here to document the layout of type 5 SDS strings. */struct __attribute__ ((__packed__)) sdshdr5 { unsigned char flags; /* 3 lsb of type, and 5 msb of string length */ char buf[];};struct __attribute__ ((__packed__)) sdshdr8 { uint8_t len; /* used */ uint8_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[];};struct __attribute__ ((__packed__)) sdshdr16 { uint16_t len; /* used */ uint16_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[];};struct __attribute__ ((__packed__)) sdshdr32 { uint32_t len; /* used */ uint32_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[];};struct __attribute__ ((__packed__)) sdshdr64 { uint64_t len; /* used */ uint64_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[];}; 先从sdshdr5开始分析，sdshdr5中有两个变量，一个是flags，一个是buf。从注解中我们很容易可以看出，redis使用一个字节长度的unsigned char存储key的类型和长度，其中前三位为key的类型，即该key的数据结构是属于sdshdr中的哪一种，后五位为key的长度。而buf就是存储key的区域。 我们可以很容易推导出，sdshdr5可以存储$2^5-1=31$位的数据。 当然，31位的长度显然是不够的，因而redis的设计者还设计了sdshdr8,sdshdr16,sdshdr32,sdshdr64这四种更长的sds类型。 与sdshdr5不同的是，在后续的sds类型中，flag只表示类型（后5位不再使用）,而是使用一个符合长度需求的len来表示。 以下是sds中各个变量含义 变量名 解释 len sdshdr8以上使用len表示buf的长度 alloc 剩余可分配的buf长度 flag sdshdr5使用flag来表示类型和长度，sdshdr8以上只表示类型 buf 实际存储key ps:flag前五位的类型判断 1234567891011121314151617181920212223#define SDS_TYPE_5 0#define SDS_TYPE_8 1#define SDS_TYPE_16 2#define SDS_TYPE_32 3#define SDS_TYPE_64 4#define SDS_TYPE_MASK 7static inline size_t sdslen(const sds s) { unsigned char flags = s[-1]; switch(flags&amp;SDS_TYPE_MASK) { case SDS_TYPE_5: return SDS_TYPE_5_LEN(flags); case SDS_TYPE_8: return SDS_HDR(8,s)-&gt;len; case SDS_TYPE_16: return SDS_HDR(16,s)-&gt;len; case SDS_TYPE_32: return SDS_HDR(32,s)-&gt;len; case SDS_TYPE_64: return SDS_HDR(64,s)-&gt;len; } return 0;} Redis作者为了节省空间和提高性能所采取的办法和思想非常值得学习！ Redis 数据库源码分析数据库数据结构分析 图片原作者：爱写代码的大曾（B站） Redis String int 编码底层原理要分析Redis String和int的编码，需要把存储value的对象拿出来分析。以下是redis中存储value的对象-redisObject的源代码。 123456789typedef struct redisObject { unsigned type:4; // 数据类型 string,list,set,zset,hash... unsigned encoding:4; // 编码类型 unsigned lru:LRU_BITS; /* LRU time (relative to global lru_clock) or * LFU data (least significant 8 bits frequency * and most significant 16 bits access time). */ int refcount; // 引用计数 void *ptr;// 指向存储value的指针} robj; 注意看源代码中的encoding变量，本节的主要任务就是分析它的作用。 首先来看redis中决定value编码的源代码 12345678910111213141516171819202122232425262728293031323334353637383940robj *tryObjectEncoding(robj *o) { ... /* Check if we can represent this string as a long integer. * Note that we are sure that a string larger than 20 chars is not * representable as a 32 nor 64 bit integer. */ len = sdslen(s); // 如果value长度小于等于20以内，则有可能转换为整型值 if (len &lt;= 20 &amp;&amp; string2l(s,len,&amp;value)) { /* This object is encodable as a long. Try to use a shared object. * Note that we avoid using shared integers when maxmemory is used * because every object needs to have a private LRU field for the LRU * algorithm to work well. */ if ((server.maxmemory == 0 || !(server.maxmemory_policy &amp; MAXMEMORY_FLAG_NO_SHARED_INTEGERS)) &amp;&amp; value &gt;= 0 &amp;&amp; value &lt; OBJ_SHARED_INTEGERS) { decrRefCount(o); incrRefCount(shared.integers[value]); return shared.integers[value]; } else { if (o-&gt;encoding == OBJ_ENCODING_RAW) { sdsfree(o-&gt;ptr); o-&gt;encoding = OBJ_ENCODING_INT; // 将值本身赋给指针。 o-&gt;ptr = (void*) value; return o; } else if (o-&gt;encoding == OBJ_ENCODING_EMBSTR) { decrRefCount(o); return createStringObjectFromLongLongForValue(value); } } } .... return o;} 可以看到，redis对于String和int的处理是，如果String小于20，则可能可以用一个long类型来表示这个String。因而这时可以直接把指针的值作为value。因而我们在读这种数据时，直接读指针的值即可，不用再做一次IO去读取指针所指向的值。这样就又节省了空间和时间，提高了性能。 妙！ Redis EmdString在了解 EmdStr之前，我们需要先了解redisObject的大小。 type:4 bit encoding:4bit lru:24bit countRef:4 byte void* 8byte 加起来16Bytes 从前面贴出的源代码可知，一个redisObject的大小为16bytes，然而CPU从内存中取数据一次最少要取64bytes，那我取一个redisObject的话，相当于剩下的48byte都没用。这就产生了浪费。 redis作者为了把这一部分字节用起来，又设置了一种数据类型叫emdstr。顾名思义，这种string类型是嵌入到redisObject里面的。 接下来我们来看这段决定编码是不是EmdStr的代码。 1234567891011121314#define OBJ_ENCODING_EMBSTR_SIZE_LIMIT 44/* If the string is small and is still RAW encoded, * try the EMBSTR encoding which is more efficient. * In this representation the object and the SDS string are allocated * in the same chunk of memory to save space and cache misses. */if (len &lt;= OBJ_ENCODING_EMBSTR_SIZE_LIMIT) { robj *emb; if (o-&gt;encoding == OBJ_ENCODING_EMBSTR) return o; emb = createEmbeddedStringObject(s,sdslen(s)); decrRefCount(o); return emb;} 可以看到，当len&lt;=44的时候，就采用emdstr去编码这个value。那为什么是44呢。因为这个时候value的数据结构是sdshdr5或者sdshdr8。而sdshdr5或者8的最大大小是4byte。那么除去者4byte，只剩下44byte了。这也就是为什么是44的原因。","link":"/2022/03/18/%E3%80%90Redis%E3%80%91%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%E4%B8%BB%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/"},{"title":"【Redis】源码分析（二） 数据类型源码分析","text":"Redis Rehashing过程分析过程请看注释 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657int dictRehash(dict *d, int n) { // 空访问阈值 int empty_visits = n*10; /* Max number of empty buckets to visit. */ // 如果 rehashidx==-1 则没有在rehash，那就停止rehash if (!dictIsRehashing(d)) return 0; // 如果rehash个数达到或者table[0]已经rehash完就结束while循环 while(n-- &amp;&amp; d-&gt;ht_used[0] != 0) { dictEntry *de, *nextde; /* Note that rehashidx can't overflow as we are sure there are more * elements because ht[0].used != 0 */ assert(DICTHT_SIZE(d-&gt;ht_size_exp[0]) &gt; (unsigned long)d-&gt;rehashidx); // 跳过空的dictEntry，如果空的个数达到阈值，则放弃rehashing while(d-&gt;ht_table[0][d-&gt;rehashidx] == NULL) { d-&gt;rehashidx++; if (--empty_visits == 0) return 1; } // 从非空rehash开始 de = d-&gt;ht_table[0][d-&gt;rehashidx]; /* Move all the keys in this bucket from the old to the new hash HT */ // 如果de非空 while(de) { uint64_t h; nextde = de-&gt;next; /* Get the index in the new hash table */ // 计算新的hashkey h = dictHashKey(d, de-&gt;key) &amp; DICTHT_SIZE_MASK(d-&gt;ht_size_exp[1]); // de转移到新的table[1]上 de-&gt;next = d-&gt;ht_table[1][h]; d-&gt;ht_table[1][h] = de; // 旧表已用减少 d-&gt;ht_used[0]--; // 新表医用增多 d-&gt;ht_used[1]++; de = nextde; } d-&gt;ht_table[0][d-&gt;rehashidx] = NULL; d-&gt;rehashidx++; } /* Check if we already rehashed the whole table... */ // 如果已经rehash完所有，则释放table[0]的空间，并将table[1]移到tabke[0] if (d-&gt;ht_used[0] == 0) { zfree(d-&gt;ht_table[0]); /* Copy the new ht onto the old one */ d-&gt;ht_table[0] = d-&gt;ht_table[1]; d-&gt;ht_used[0] = d-&gt;ht_used[1]; d-&gt;ht_size_exp[0] = d-&gt;ht_size_exp[1]; _dictReset(d, 1); d-&gt;rehashidx = -1; return 0; } /* More to rehash... */ return 1;} List底层实现原理分析List是一个有序的数据结构（按加入时序），Redis采用quicklist(双端链表)和ziplist(压缩列表)作为list的底层实现。其中ziplist作为节点存储在quicklist上，因而list的encoding是quicklist 可以通过设置每个Ziplist的最大容量，quickList(双端链表)的数据压缩范围，提升数据存储效率。 图片原作者：爱写代码的大曾（B站） quickListquickList是一个ziplist组成的双向链表。每个节点使用ziplist来保存数据。本质上来说，quicklist里面保存着一个一个小的ziplist。 结构 源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445typedef struct quicklistNode { struct quicklistNode *prev; //上一个node节点 struct quicklistNode *next; //下一个node unsigned char *zl; //保存的数据 压缩前ziplist 压缩后压缩的数据 unsigned int sz; /* ziplist size in bytes */ unsigned int count : 16; /* count of items in ziplist */ unsigned int encoding : 2; /* RAW==1 or LZF==2 */ unsigned int container : 2; /* NONE==1 or ZIPLIST==2 */ unsigned int recompress : 1; /* was this node previous compressed? */ unsigned int attempted_compress : 1; /* node can't compress; too small */ unsigned int extra : 10; /* more bits to steal for future usage */} quicklistNode; quickList就是一个标准的双向链表的配置，有head 有tail; 每一个节点是一个quicklistNode，包含prev和next指针。 每一个quicklistNode 包含 一个ziplist，*zp 压缩链表里存储键值。 所以quicklist是对ziplist进行一次封装，使用小块的ziplist来既保证了少使用内存，也保证了性能。 为什么不全部使用 ziplist呢？ 因为：ziplist存储在一段连续的内存上，所以存储效率很高。但是，它不利于修改操作，插入和删除操作需要频繁的申请和释放内存。特别是当ziplist长度很长的时候，一次realloc可能会导致大批量的数据拷贝。 ziplist压缩列表 ziplist 是为 Redis 节约内存而开发的。ziplist 是由一系列特殊编码的内存块构成的列表(像内存连续的数组，但每个元素长度不同)， 一个 ziplist 可以包含多个节点（entry）。ziplist 将表中每一项存放在前后连续的地址空间内，每一项因占用的空间不同，而采用变长编码。 ziplist的主要优点是节省内存，但它上面的查找操作只能按顺序查找（可以是从前往后、也可以从后往前）。ziplist将数据按照一定规则编码在一块连续的内存区域，目的是节省内存，这种结构并不擅长做修改操作。一旦数据发生改动，就会引发内存realloc，可能导致内存拷贝。 ziplist 是一个特殊的双向链表特殊之处在于：没有维护双向指针:prev next；而是存储上一个 entry的长度和 当前entry的长度，通过长度推算下一个元素在什么地方。牺牲读取的性能，获得高效的存储空间，因为(简短字符串的情况)存储指针比存储entry长度 更费内存。这是典型的“时间换空间”。 ziplist使用局限性字段、值比较小，才会用ziplist。 源码 12345678910111213141516171819202122232425typedef struct zlentry { // 压缩列表节点 unsigned int prevrawlensize, prevrawlen; // prevrawlen是前一个节点的长度，prevrawlensize是指prevrawlen的大小，有1字节和5字节两种 unsigned int lensize, len; // len为当前节点长度 lensize为编码len所需的字节大小 unsigned int headersize; // 当前节点的header大小 unsigned char encoding; // 节点的编码方式 unsigned char *p; // 指向节点的指针} zlentry; 如何通过一个节点向前跳转到另一个节点？用指向当前节点的指针 e ， 减去 前一个 entry的长度， 得出的结果就是指向前一个节点的地址 p 。 ziplist连锁更新问题 因为在ziplist中，每个zlentry都存储着前一个节点所占的字节数，而这个数值又是变长编码的。假设存在一个压缩列表，其包含e1、e2、e3、e4…..，e1节点的大小为253字节，那么e2.prevrawlen的大小为1字节，如果此时在e2与e1之间插入了一个新节点e_new，e_new编码后的整体长度（包含e1的长度）为254字节，此时e2.prevrawlen就需要扩充为5字节；如果e2的整体长度变化又引起了e3.prevrawlen的存储长度变化，那么e3也需要扩…….如此递归直到表尾节点或者某一个节点的prevrawlen本身长度可以容纳前一个节点的变化。其中每一次扩充都需要进行空间再分配操作。删除节点亦是如此，只要引起了操作节点之后的节点的prevrawlen的变化，都可能引起连锁更新。 连锁更新在最坏情况下需要进行N次空间再分配，而每次空间再分配的最坏时间复杂度为O(N)，因此连锁更新的总体时间复杂度是O(N^2)。即使涉及连锁更新的时间复杂度这么高，但它能引起的性能问题的概率是极低的：需要列表中存在大量的节点长度接近254的zlentry。","link":"/2022/03/18/%E3%80%90Redis%E3%80%91%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"title":"【Leetcode刷题笔记】606 根据二叉树创建字符串","text":"题目描述你需要采用前序遍历的方式，将一个二叉树转换成一个由括号和整数组成的字符串。 空节点则用一对空括号 “()” 表示。而且你需要省略所有不影响字符串与原始二叉树之间的一对一映射关系的空括号对。 示例 1: 123456789101112输入: 二叉树: [1,2,3,4] 1 / \\ 2 3 / 4 输出: &quot;1(2(4))(3)&quot;解释: 原本将是“1(2(4)())(3())”，在你省略所有不必要的空括号对之后，它将是“1(2(4))(3)”。 示例 2: 1234567891011输入: 二叉树: [1,2,3,null,4] 1 / \\ 2 3 \\ 4 输出: &quot;1(2()(4))(3)&quot;解释: 和第一个示例相似，除了我们不能省略第一个对括号来中断输入和输出之间的一对一映射关系。 Related Topics 树 深度优先搜索 字符串 二叉树 题解首先要弄清楚不省略括号的情况是什么： 当遍历到的空间点属于左节点，且其父节点的右节点不空，那这个空括号不可被省略 搞清楚这一点就很好办了。但是有个问题出现了，题目要求采用前序遍历，先遍历左节点，后遍历右节点。是否添加空括号需要提前知道右节点是否为空这个信息。这样应该有多种解决方法。 我的解决方法是，把所有的空括号都添加进来，最后统一处理删除不必要的括号。 代码如下： 12345678910111213141516171819202122232425262728class Solution { List&lt;String&gt; res; public String tree2str(TreeNode root) { // 空括号存在的情况：左空右不空 // 由于我们会先遍历左节点，所以加上一个标识符来判断左节点为空且右节点不为空 res=new ArrayList&lt;&gt;(); preTraversebTree(root); StringBuilder ret=new StringBuilder(); int n=res.size(); for (int i = 1; i &lt; n-1; i++) { if((res.get(i).equals(&quot;()&quot;)&amp;&amp;i+1&lt;n&amp;&amp;i+2&lt;n&amp;&amp;res.get(i+1).equals(&quot;(&quot;)&amp;&amp;!res.get(i+1).equals(&quot;)&quot;))||!res.get(i).equals(&quot;()&quot;)){ ret.append(res.get(i)); } } return ret.toString(); } private void preTraversebTree(TreeNode root){ if(root==null){ res.add(&quot;()&quot;); return; } res.add(&quot;(&quot;); res.add(String.valueOf(root.val)); preTraversebTree(root.left); preTraversebTree(root.right); res.add(&quot;)&quot;); }} 复杂度： 时间 O(n) 空间O(n)","link":"/2022/03/19/%E3%80%90Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%91606-%E6%A0%B9%E6%8D%AE%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%9B%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"title":"【Java】Java有哪些类加载器","text":"什么是classloaderclassloader顾名思义，即是类加载。虚拟机把描述类的数据从class字节码文件加载到内存，并对数据进行检验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。了解java的类加载机制，可以快速解决运行时的各种加载问题并快速定位其背后的本质原因，也是解决疑难杂症的利器。因此学好类加载原理也至关重要。 classloader的加载过程类从被加载到虚拟机内存到被卸载，整个完整的生命周期包括：类加载、验证、准备、解析、初始化、使用和卸载七个阶段。其中验证，准备，解析三个部分统称为连接。接下来我们可以详细了解下类加载的各个过程。 classloader的整个加载过程还是非常复杂的，具体的细节可以参考《深入理解java虚拟机》进行深入了解。为了方便记忆，我们可以使用一句话来表达其加载的整个过程，“家宴准备了西式菜”，即家(加载)宴(验证)准备(准备)了西(解析)式(初始化)菜。保证你以后能够很快的想起来。虽然classloader的加载过程有复杂的5步，但事实上除了加载之外的四步，其它都是由JVM虚拟机控制的，我们除了适应它的规范进行开发外，能够干预的空间并不多。而加载则是我们控制classloader实现特殊目的最重要的手段了。也是接下来我们介绍的重点了。 classloader双亲委托机制classloader的双亲委托机制是指多个类加载器之间存在父子关系的时候，某个class类具体由哪个加载器进行加载的问题。其具体的过程表现为：当一个类加载的过程中，它首先不会去加载，而是委托给自己的父类去加载，父类又委托给自己的父类。因此所有的类加载都会委托给顶层的父类，即Bootstrap Classloader进行加载，然后父类自己无法完成这个加载请求，子加载器才会尝试自己去加载。使用双亲委派模型，Java类随着它的加载器一起具备了一种带有优先级的层次关系，通过这种层次模型，可以避免类的重复加载，也可以避免核心类被不同的类加载器加载到内存中造成冲突和混乱，从而保证了Java核心库的安全。 整个java虚拟机的类加载层次关系如上图所示，启动类加载器(Bootstrap Classloader)负责将/lib目录下并且被虚拟机识别的类库加载到虚拟机内存中。我们常用基础库，例如java.util.**，java.io.**，java.lang.**等等都是由根加载器加载。 扩展类加载器(Extention Classloader)负责加载JVM扩展类，比如swing系列、内置的js引擎、xml解析器等，这些类库以javax开头，它们的jar包位于/lib/ext目录中。 应用程序加载器(Application Classloader)也叫系统类加载器，它负责加载用户路径(ClassPath)上所指定的类库。我们自己编写的代码以及使用的第三方的jar包都是由它来加载的自定义加载器(Custom Classloader)通常是我们为了某些特殊目的实现的自定义加载器，后面我们得会详细介绍到它的作用以及使用场景。 双亲委托机制看起来比较复杂，但是其本身的核心代码逻辑却是非常的清晰简单，我们着重抽取了类加载的双亲委托的核心代码如下，不过二十行左右。 classloader的应用场景类加载器是java语言的一项创新，也是java语言流行的重要原因这一。通过灵活定义classloader的加载机制，我们可以完成很多事情，例如解决类冲突问题，实现热加载以及热部署，甚至可以实现jar包的加密保护。接下来，我们会针对这些特殊场景进行逐一介绍。 作者：阿里巴巴淘系技术链接：https://www.zhihu.com/question/46719811/answer/1739289578来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","link":"/2022/03/21/%E3%80%90Java%E3%80%91Java%E6%9C%89%E5%93%AA%E4%BA%9B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"},{"title":"【Spring】Spring源码分析（一）","text":"核心概念IOC与DI IOC 控制反转，一种思想。依赖注入，一种手段。 IOC是控制反转的意思，这是一种面向对象编程的设计思想。在不采用这种思想的情况下，我们需要自己维护对象与对象之间的依赖关系，很容易造成对象之间的耦合度过高，在一个大型的项目中这十分的不利于代码的维护。IoC则可以解决这种问题，它可以帮我们维护对象与对象之间的依赖关系，降低对象之间的耦合度。 DI是依赖注入的意思，它是IoC实现的实现方式，就是说IoC是通过DI来实现的。由于IoC这个词汇比较抽象而DI却更直观，所以很多时候我们就用DI来代替它，在很多时候我们简单地将IoC和DI划等号，这是一种习惯。而实现依赖注入的关键是IoC容器，它的本质就是一个工厂。 xml里配置bean 123456&lt;beans&gt;&lt;bean id=? class=? abstract init-method scope dependon...?&gt;&lt;property name=? value=?/&gt;&lt;property name=? value=?/&gt;&lt;/bean&gt;&lt;/beans&gt; Java里获取bean 123Application ac=new;ClassPathXmlApplicationContext(&quot;applicationContent.xml&quot;);XXX xxx=ac.getBean(XXX.class); 从xml配置到bean发生了什么？ LoadXml-&gt;ParseXml-&gt;封装BeanDefinition-&gt;实例化(使用反射而非new)-&gt;放入容器中-&gt;从容器中获取 不只xml可以配置bean,如properties groovy也可以配置bean 从配置文件到生成beanDefinition,解析器需要实现BeanDefinitionReader 接口。 1public interface BeanDefinitionReader 理解实例化的过程需要先了解反射，这里简单复习一下Java反射机制 反射获取类对象的几种方式 123Class.forName();对象.getClass();类名.class(); 一些示例代码 123456789101112131415161718192021222324public static void main(String[] args) throws Exception { Class clazz = Class.forName(&quot;TreeNode&quot;); Constructor[] constructors= clazz.getConstructors(); for (Constructor constructor : constructors) { System.out.println(constructor); } constructors=clazz.getDeclaredConstructors(); for (Constructor constructor : constructors) { System.out.println(constructor); } // 由于无参构造函数是私有的，而getConstructor只能获取公有的，所以会抛出异常 // Constructor con=clazz.getConstructor(null); // System.out.println(con); Constructor con=clazz.getConstructor(int.class); System.out.println(con); TreeNode root= (TreeNode) con.newInstance(1); Field field=clazz.getDeclaredField(&quot;val&quot;); field.set(root, 2); System.out.println(root.val); // 输出object mark word } 实例化的过程包括实例化和初始化 注意 实例化和初始化不能等同来看 实例化是给对象在堆中开辟一块空间，对象属性值都是默认值 而初始化是填充属性，设置Aware接口的属性，并执行init-method 关于Bean的生命周期Spring容器管理Bean，涉及对Bean的创建、初始化、调用、销毁等一系列的流程，这个流程就是Bean的生命周期。整个流程参考下图： 在Bean 先要调用构造器完成实例化。 接下来是初始化的过程 注意，这里的postProcessorAfterInitialization和postProcessorBeforeInitialization使用了AOP AOP实现的两种方法 DK动态代理：这是Java提供的动态代理技术，可以在运行时创建接口的代理实例。Spring AOP默认采用这种方式，在接口的代理实例中织入代码。 CGLib动态代理：采用底层的字节码技术，在运行时创建子类代理的实例。当目标对象不存在接口时，Spring AOP就会采用这种方式，在子类实例中织入代码。 Spring Aware 顾名思义，Spring Bean Aware 就是帮助bean感知Spring容器的存在。这会增加Bean与IOC容器的耦合。 常见的 Spring Aware 接口 Aware子接口 描述 BeanNameAware 获取容器中 Bean 的名称 BeanFactoryAware 获取当前 BeanFactory ，这样可以调用容器的服务 ApplicationContextAware 同上，在BeanFactory 和 ApplicationContext 的区别 中已明确说明 MessageSourceAware 获取 Message Source 相关文本信息 ApplicationEventPublisherAware 发布事件 ResourceLoaderAware 获取资源加载器，这样获取外部资源文件 来看类关系图： 当然不止以上这些 Aware， 通常使用 Spring Aware 的目的是为了让 Bean 获得 Spring 容器的服务。比如，通过Aware，可以通过当前对象，获取容器中其他所有对象。(有点反射那种思想) Spring中的观察者模式观察者模式的应用：监听器，监听事件，多播器 如监听Spring容器创建完成的观察者 12345678// Initialize event multicaster for this context.initApplicationEventMulticaster();// Initialize other special beans in specific context subclasses.onRefresh();// Check for listener beans and register them.registerListeners(); BeanFactory和FactoryBean的区别 都是用来创建对象的，当使用BeanFactory的时候必须要遵循完整的创建过程，这个过程是由spring来管理控制的。而使用FactoryBean只需要调用getObject就可以返回具体的对象，整个对象的创建过程是由用户自己来控制的，更加灵活。 PostProcessor BeanFactorPostProcessor BeanDefinition增强器接口，自定义的PostProcessor需要实现它 1234567public class myBeanFactoryPoProcessor implements BeanFactoryPostProcessor { @Override public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException { System.out.println(&quot;myBeanFactoryPoProcessor&quot;); }} BeanProcessorBean的增强器接口，自定义的PostProcessor需要实现它","link":"/2022/03/21/%E3%80%90Spring%E3%80%91Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/"},{"title":"【Leetcode刷题笔记】2039 网络空闲的时刻","text":"题目描述给你一个有 n 个服务器的计算机网络，服务器编号为 0 到 n - 1 。同时给你一个二维整数数组 edges ，其中 edges[i] = [ui, vi] 表示服务器 ui 和 vi 之间有一条信息线路，在 一秒 内它们之间可以传输 任意 数目的信息。再给你一个长度为 n 且下标从 0 开始的整数数组 patience 。 题目保证所有服务器都是 相通 的，也就是说一个信息从任意服务器出发，都可以通过这些信息线路直接或间接地到达任何其他服务器。 编号为 0 的服务器是 主 服务器，其他服务器为 数据 服务器。每个数据服务器都要向主服务器发送信息，并等待回复。信息在服务器之间按 最优 线路传输，也就是说每个信息都会以 最少时间 到达主服务器。主服务器会处理 所有 新到达的信息并 立即 按照每条信息来时的路线 反方向 发送回复信息。 在 0 秒的开始，所有数据服务器都会发送各自需要处理的信息。从第 1 秒开始，每 一秒最 开始 时，每个数据服务器都会检查它是否收到了主服务器的回复信息（包括新发出信息的回复信息）： 如果还没收到任何回复信息，那么该服务器会周期性 重发 信息。数据服务器 i 每 patience[i] 秒都会重发一条信息，也就是说，数据服务器 i 在上一次发送信息给主服务器后的 patience[i] 秒 后 会重发一条信息给主服务器。 否则，该数据服务器 不会重发 信息。 当没有任何信息在线路上传输或者到达某服务器时，该计算机网络变为 空闲 状态。 请返回计算机网络变为 空闲 状态的 最早秒数 。 示例 1： 123456789101112131415161718192021222324输入：edges = [[0,1],[1,2]], patience = [0,2,1]输出：8解释：0 秒最开始时，- 数据服务器 1 给主服务器发出信息（用 1A 表示）。- 数据服务器 2 给主服务器发出信息（用 2A 表示）。1 秒时，- 信息 1A 到达主服务器，主服务器立刻处理信息 1A 并发出 1A 的回复信息。- 数据服务器 1 还没收到任何回复。距离上次发出信息过去了 1 秒（1 &lt; patience[1] = 2），所以不会重发信息。- 数据服务器 2 还没收到任何回复。距离上次发出信息过去了 1 秒（1 == patience[2] = 1），所以它重发一条信息（用 2B 表示）。2 秒时，- 回复信息 1A 到达服务器 1 ，服务器 1 不会再重发信息。- 信息 2A 到达主服务器，主服务器立刻处理信息 2A 并发出 2A 的回复信息。- 服务器 2 重发一条信息（用 2C 表示）。...4 秒时，- 回复信息 2A 到达服务器 2 ，服务器 2 不会再重发信息。...7 秒时，回复信息 2D 到达服务器 2 。从第 8 秒开始，不再有任何信息在服务器之间传输，也不再有信息到达服务器。所以第 8 秒是网络变空闲的最早时刻。 示例 2： 1234输入：edges = [[0,1],[0,2],[1,2]], patience = [0,10,10]输出：3解释：数据服务器 1 和 2 第 2 秒初收到回复信息。从第 3 秒开始，网络变空闲。 提示： n == patience.length 2 &lt;= n &lt;= 105 patience[0] == 0 对于 1 &lt;= i &lt; n ，满足 1 &lt;= patience[i] &lt;= 105 1 &lt;= edges.length &lt;= min(105, n * (n - 1) / 2) edges[i].length == 2 0 &lt;= ui, vi &lt; n ui != vi 不会有重边。 每个服务器都直接或间接与别的服务器相连。 题解 刚看此题的时候，我寻思这才中等题？后来仔细一看，题中的情况其实非常简单 分析题干可知，一个主机的数据包到达服务器的事件是固定不变的，不受其他影响。 那我们假设主机到服务器的最短路径为x，那么从开始到收到确认包，就需要2x的时间。 那么确认一台主机多久会进入空闲状态只需要知道它最后一个数据包被确认的时间了。 我们已知在2x时刻，第一个数据包的ack到达主机，此时主机不会再重复发数据包，那么最后一个可能重复发数据包的时刻就是2x-1。 很容易可以推知$$ (2x-1)\\ mod\\ patience[i]==0$$时，该时刻需要发最后一个数据包。 那如果不等于0呢？那就是最后一个数据包的当前位置了。 我们把等于0的情况看做最后一个数据包位于发送方主机的位置。那么可以推知，此时最后一个数据包收到确认的时间为 $$2x-1-(2x-1)mod\\ patience[i]$$ 因而最后一个数据包到达的时间为$4x-1-(2x-1)mod\\ patience[i]+1$ 又因为到达的下一时刻才会进入空闲，那么进入空闲的时间为 $4x-(2x-1)mod\\ patience[i]$ 单源最短路径 那么现在只需要算出每个主机距离服务器的最短距离，然后遍历获取最大值即可。这里使用dijkstra算法完成。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.util.Arrays;import java.util.Comparator;import java.util.PriorityQueue;import java.util.Queue;class Solution { static class node { int index; int length; public node(int index, int length) { this.index = index; this.length = length; } } public int networkBecomesIdle(int[][] edges, int[] patience) { // 先用Dijkstra算法做一下 int n = patience.length; int[][] map = new int[n][n]; // 初始化map所有初始值为Inf for (int i = 0; i &lt; n; i++) { Arrays.fill(map[i], Integer.MAX_VALUE); map[i][i]=0; } for (int[] edge : edges) { map[edge[0]][edge[1]] = 1; } int[] dist = new int[n]; Arrays.fill(dist, Integer.MAX_VALUE); dist[0] = 0; Queue&lt;node&gt; queue = new PriorityQueue(); queue.add(new node(0, 0)); int count = 0; boolean[] vis=new boolean[n]; vis[0]=true; while (!queue.isEmpty()) { node cur = queue.poll(); count++; for (int i = 0; i &lt; n; i++) { if (map[cur.index][i] == 1 &amp;&amp; !vis[i]&amp;&amp; dist[i] &gt; dist[cur.index] + 1) { dist[i] = dist[cur.index] + 1; queue.add(new node(i, dist[i])); } } if (count == n - 1) break; } int max=0; // 到这里已经算出了最短路径 for (int i = 1; i &lt; n; i++) { int num=4*dist[i]-(2*dist[i]-1)%patience[i]; if(num&gt;max) max=num; } return max; } static Comparator&lt;node&gt; com = new Comparator&lt;node&gt;() { public int compare(node o1, node o2) { return o1.length - o2.length; } };} 复杂度 时间复杂度 最坏为O(n^2),最好为O(n) 空间复杂度O(n)","link":"/2022/03/22/%E3%80%90Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%912039-%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B2%E7%9A%84%E6%97%B6%E5%88%BB/"},{"title":"【并发编程】高并发秒杀系统架构设计","text":"以下内容为马士兵老师的Java并发编程中高并发秒杀系统架构实战的听课笔记 【马士兵教育】首次深入计算机底层原理透彻解析Java并发编程，JUC并发编程，多线程，高并发秒杀方案全套教程（合集）_哔哩哔哩_bilibili CAP定理CAP原则又称CAP定理，指的是在一个分布式系统中， Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可得兼。 一致性（C）：在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本） 可用性（A）：保证每个请求不管成功或者失败都有响应。 分区容忍性（P）：系统中任意信息的丢失或失败不会影响系统的继续运作。 关于分区容忍性的理解： 分区容忍性是指当系统发生故障时，是否可以继续正常运作。如，两台服务器之间的网线断开了，无法进行信息交换，如果这时系统能够容忍这样的故障发生并且继续运行，则叫分区容忍性。 为什么不能同时满足的通俗理解 满足C和A，那么P能不能满足呢？ 满足C需要所有的服务器的数据要一样，也就是说要实现数据的同步，那么同步要不要时间？肯定是要的，并且机器越多，同步的时间肯定越慢，这里问题就来了，我们同时也满足了A，也就是说，我要同步时间短才行。这样的话，机器就不能太多了，也就是说P是满足不了的 满足C和P，那么A能不能满足呢？ 满足P需要很多服务器，假设有1000台服务器，同时满足了C，也就是说要保证每台机器的数据都一样，那么同步的时间可就很大，在这种情况下，我们肯定是不能保证用户随时访问每台服务器获取到的数据都是最新的，想要获取最新的，可以，你就等吧，等全部同步完了，你就可以获取到了，但是我们的A要求短时间就可以拿到想要的数据啊，这不就是矛盾了，所以说这里A是满足不了了 满足A和P，那么C能不能满足呢？ 满足P的话，需要多台服务器，而满足C的话，只有一台服务器才可以满足，这和P矛盾。 12306的问题 强一致性带来的难题 - 递归循环锁 解决： 分布式一致性哈希环，防止一个节点存全量数据，只存和处理一部分数据。 降低一致性增强可用性 异步通讯，慢慢完成数据一致性。（前端一致，后端不一致） Base理论BASE理论是Basically Available(基本可用)，Soft State（软状态）和Eventually Consistent（最终一致性）三个短语的缩写。 核心思想： 既是无法做到强一致性（Strong consistency），但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）。 基本可用什么是基本可用呢？假设系统，出现了不可预知的故障，但还是能用，相比较正常的系统而言： 响应时间上的损失：正常情况下的搜索引擎0.5秒即返回给用户结果，而基本可用的搜索引擎可以在2秒作用返回结果。 功能上的损失：在一个电商网站上，正常情况下，用户可以顺利完成每一笔订单。但是到了大促期间，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面。3.2. 软状态 软状态什么是软状态呢？相对于原子性而言，要求多个节点的数据副本都是一致的，这是一种“硬状态”。 软状态指的是：允许系统中的数据存在中间状态，并认为该状态不影响系统的整体可用性，即允许系统在多个不同节点的数据副本存在数据延时。 最终一致性上面说软状态，然后不可能一直是软状态，必须有个时间期限。在期限过后，应当保证所有副本保持数据一致性，从而达到数据的最终一致性。这个时间期限取决于网络延时、系统负载、数据复制方案设计等等因素。 TPS和QPS区别TPSTPS：Transactions Per Second，意思是每秒事务数，具体事务的定义，都是人为的，可以一个接口、多个接口、一个业务流程等等。一个事务是指事务内第一个请求发送到接收到最后一个请求的响应的过程，以此来计算使用的时间和完成的事务个数。 以单接口定义为事务为例，每个事务包括了如下3个过程： a.向服务器发请求 b.服务器自己的内部处理（包含应用服务器、数据库服务器等） c.服务器返回结果给客户端 如果每秒能够完成N次这三个过程，tps就是N； 如果多个接口定义为一个事务，那么，会重复执行abc，完成一次这几个请求，算做一个tps。 QPSQPS：Queries Per Second，意思是每秒查询率，是一台服务器每秒能够响应的查询次数（数据库中的每秒执行查询sql的次数），显然，这个不够全面，不能描述增删改，所以，不建议用qps来作为系统性能指标。 qps包含tps","link":"/2022/03/21/%E3%80%90%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"},{"title":"【Java】Java并发编程","text":"操作系统补充缓存行（cache line) 缓存行一般是64字节大小，且在缓存中支持一致性协议。 Volite 关键字字节码层面 volite修饰的关键字，会在字节码里多出一个ACC_VOLITE标志 JVM层面 JVM层面会增加一个内存屏障，为了禁止指令乱序执行。 使用volite修饰的变量，线程不会从缓存读取它，而是从主存读它 关于缓存 CPU与主存之间往往由三级缓存，其中L1,L2在CPU内，L3在主板上 JVM要求所有的JVM实现以下屏障 Loadload/StoreLoad/StoreStore/storeLoad 屏障 因而volatile在JVM下有以下屏障来禁止指令乱序执行 123456789volatile int num=0;---- LoadLoad barrier------ // 前面一条写num操作执行完才能之下下面这条read(num)---- LoadStore barrier ----- // 这条写Num操作执行完才能进行下面的读操作----storestore barrier----read(num)----loadstore barrier---- CPU层面 sfence(storefence) lfence(loadfence) mfence(multi-fence全屏障) MESI 缓存行一致性协议 Lock 锁总线 线程和锁 go的协程很像java的线程池之间的关系 go和java都是事先分配一些内核线程来处理任务队列 java不能任务同步 但go可以 go通过模拟了cpu的执行。（cpu时钟周期） 重量级锁内置锁在Java中被抽象为监视器锁（monitor）。在JDK 1.6之前，监视器锁可以认为直接对应底层操作系统中的互斥量（mutex）。这种同步方式的成本非常高，包括系统调用引起的内核态与用户态切换、线程阻塞造成的线程切换等。因此，后来称这种锁为“重量级锁”。 自旋锁首先，内核态与用户态的切换上不容易优化。但通过自旋锁，可以减少线程阻塞造成的线程切换（包括挂起线程和恢复线程）。 如果锁的粒度小，那么锁的持有时间比较短（尽管具体的持有时间无法得知，但可以认为，通常有一部分锁能满足上述性质）。那么，对于竞争这些锁的而言，因为锁阻塞造成线程切换的时间与锁持有的时间相当，减少线程阻塞造成的线程切换，能得到较大的性能提升。具体如下： 当前线程竞争锁失败时，打算阻塞自己 不直接阻塞自己，而是自旋（空等待，比如一个空的有限for循环）一会 在自旋的同时重新竞争锁 如果自旋结束前获得了锁，那么锁获取成功；否则，自旋结束后阻塞自己 如果在自旋的时间内，锁就被旧owner释放了，那么当前线程就不需要阻塞自己（也不需要在未来锁释放时恢复），减少了一次线程切换。 “锁的持有时间比较短”这一条件可以放宽。实际上，只要锁竞争的时间比较短（比如线程1快释放锁的时候，线程2才会来竞争锁），就能够提高自旋获得锁的概率。这通常发生在锁持有时间长，但竞争不激烈的场景中。 缺点 单核处理器上，不存在实际的并行，当前线程不阻塞自己的话，旧owner就不能执行，锁永远不会释放，此时不管自旋多久都是浪费；进而，如果线程多而处理器少，自旋也会造成不少无谓的浪费。 自旋锁要占用CPU，如果是计算密集型任务，这一优化通常得不偿失，减少锁的使用是更好的选择。 如果锁竞争的时间比较长，那么自旋通常不能获得锁，白白浪费了自旋占用的CPU时间。这通常发生在锁持有时间长，且竞争激烈的场景中，此时应主动禁用自旋锁。 使用-XX:-UseSpinning参数关闭自旋锁优化；-XX:PreBlockSpin参数修改默认的自旋次数。 自适应自旋锁自适应意味着自旋的时间不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定： 如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长的时间，比如100个循环。 相反的，如果对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能减少自旋时间甚至省略自旋过程，以避免浪费处理器资源。 自适应自旋解决的是“锁竞争时间不确定”的问题。JVM很难感知到确切的锁竞争时间，而交给用户分析就违反了JVM的设计初衷。自适应自旋假定不同线程持有同一个锁对象的时间基本相当，竞争程度趋于稳定，因此，可以根据上一次自旋的时间与结果调整下一次自旋的时间。 缺点然而，自适应自旋也没能彻底解决该问题，如果默认的自旋次数设置不合理（过高或过低），那么自适应的过程将很难收敛到合适的值。 轻量级锁自旋锁的目标是降低线程切换的成本。如果锁竞争激烈，我们不得不依赖于重量级锁，让竞争失败的线程阻塞；如果完全没有实际的锁竞争，那么申请重量级锁都是浪费的。轻量级锁的目标是，减少无实际竞争情况下，使用重量级锁产生的性能消耗，包括系统调用引起的内核态与用户态切换、线程阻塞造成的线程切换等。 顾名思义，轻量级锁是相对于重量级锁而言的。使用轻量级锁时，不需要申请互斥量，仅仅将Mark Word中的部分字节CAS更新指向线程栈中的Lock Record，如果更新成功，则轻量级锁获取成功，记录锁状态为轻量级锁；否则，说明已经有线程获得了轻量级锁，目前发生了锁竞争（不适合继续使用轻量级锁），接下来膨胀为重量级锁。 Mark Word是对象头的一部分；每个线程都拥有自己的线程栈（虚拟机栈），记录线程和函数调用的基本信息。二者属于JVM的基础内容，此处不做介绍。 当然，由于轻量级锁天然瞄准不存在锁竞争的场景，如果存在锁竞争但不激烈，仍然可以用自旋锁优化，自旋失败后再膨胀为重量级锁。 缺点同自旋锁相似： 如果锁竞争激烈，那么轻量级将很快膨胀为重量级锁，那么维持轻量级锁的过程就成了浪费。 偏向锁在没有实际竞争的情况下，还能够针对部分场景继续优化。如果不仅仅没有实际竞争，自始至终，使用锁的线程都只有一个，那么，维护轻量级锁都是浪费的。偏向锁的目标是，减少无竞争且只有一个线程使用锁的情况下，使用轻量级锁产生的性能消耗。轻量级锁每次申请、释放锁都至少需要一次CAS，但偏向锁只有初始化时需要一次CAS。 “偏向”的意思是，偏向锁假定将来只有第一个申请锁的线程会使用锁（不会有任何线程再来申请锁），因此，只需要在Mark Word中CAS记录owner（本质上也是更新，但初始值为空），如果记录成功，则偏向锁获取成功，记录锁状态为偏向锁，以后当前线程等于owner就可以零成本的直接获得锁；否则，说明有其他线程竞争，膨胀为轻量级锁。 偏向锁无法使用自旋锁优化，因为一旦有其他线程申请锁，就破坏了偏向锁的假定。 缺点同样的，如果明显存在其他线程申请锁，那么偏向锁将很快膨胀为轻量级锁。 不过这个副作用已经小的多。 如果需要，使用参数-XX:-UseBiasedLocking禁止偏向锁优化（默认打开）。","link":"/2022/03/21/%E3%80%90Java%E3%80%91Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"title":"【Mysql】Mysql面试题整理","text":"InnoDB中的B+树怎么产生的page结构 InnoDB Page结构图 1、File Header结构，记录了page页的一些头信息，一共38字节 innodb存储页类型 2、page header，记录页的状态信息，共56字节 3、虚拟最大最小记录(Infimum and Supremum Records)最大记录是这个数据页中逻辑上最大的记录，所有用户的记录都小于它。最小记录是数据页上最小的记录，所有用户记录都大于它。他们在数据页被创建的时候创建，而且不能被删除。引入他们主要是方便页内操作。 4、用户记录用户所有插入的记录都存放在这里，默认情况下记录跟记录之间没有间隙，但是如果重用了已删除记录的空间，就会导致空间碎片。每个记录都有指向下一个记录的指针，但是没有指向上一个记录的指针。记录按照主键顺序排序。即，用户可以从数据页最小记录开始遍历，直到最大的记录，这包括了所有正常的记录和所有被delete-marked记录，但是不会访问到被删除的记录(PAGE_FREE)。 5、Free Space从PAGEHEAPTOP开始，到最后一个数据目录，这之间的空间就是空闲空间，都被重置为0，当用户需要插入记录时候，首先在被删除的记录的空间中查找，如果没有找到合适的空间，就从这里分配。空间分配给记录后，需要递增PAGENRECS和PAGENHEAP。 6、Page Directory用户的记录是从低地址向高地址扩展，而数据目录则相反。在数据页被初始化的时候，就会在数据页最后(当然在checksum之前)创建两个数据目录，分别指向最大和最小记录。之后插入新的数据的时候，需要维护这个目录，例如必要的时候增加目录的个数。每个数据目录占用两个字节，存储对应记录的页内偏移量。假设目录N，这个目录N管理目录N-1(不包括)和目录N之间的记录，我们称目录N own 这些记录。在目录N指向的记录中，会有字段记录own记录的数量。由此可见，目录own的记录不能太多，因为太多的话，即意味着目录太过稀疏，不能很好的提高查询效率，但同时也不能own太少，这会导致目录数量变多，占用过多的空间。在InnoDB的实现中，目录own的记录数量在4-8之间，包括4和8，平均是6个记录。如果超过这个数量，就需要重新均衡目录的数量。目录的增加和删除可能需要进行内存拷贝，但是由于目录占用的总体空间很小，开销可以忽略不计。 7、File Trailer这个部分处于数据页最后的位置，只有8个字节。低地址的四个字节存储checksum的值，高地址的四个字节存储FILPAGELSN的低位四字节。注意这里的checksum的值不一定与FILPAGESPACEORCHKSUM的相同，这个依赖不同的checksum计算方法。 找到一张比较不错的page结构图 高度为3的B+树能存多少数据？非叶子节点(4+6)=10b 1234{ int index; int*children;} 非叶子节点每页可以存16kb/10b=1638个节点 第二层可以有1638页，每页1638个节点 第三层为叶子节点，一页可以存16kb/1kb=16个 最终$1638163816$个 Innodb是如何支持范围查找能走索引的？举个例子 12index(a)select * from table where a&gt;6; 内部执行过程是：先执行a=6 找到6对应的值，然后返回后面的结果即可。 为什么要遵守最左前缀才能利用到索引？最左前缀原则指的是，如果查询的时候查询条件精确匹配索引的左边连续一列或几列，则此列就可以被用到 如User表的name和city加联合索引就是(name,city) 1234567select * from user where name=xx and city=xx ; ／／可以命中索引select * from user where name=xx ; // 可以命中索引select * from user where city=xx ; // 无法命中索引 select * from user where city=xx and name=xx ; ／／可以命中索引 explain select * from student where name is null;//可以命中索引，使用is not null 会失效 explain select * from student where name='zs' and address='beijing'; //name用到了索引 范围查找导致索引失效原理这种情况出现在辅助索引上。 考虑以下 12create index(b,c,d) on table1;select * from table1 where b&gt;1; 这时候执行explain语句会发现mysql走了全表扫描。 这是因为mysql的辅助索引存储的具体的索引字段信息，而叶子节点存储主键索引+数据，为了要找到b&gt;1的数据，需要先在非聚集索引中找到对应的主键，再根据主键索引，查找对应的行数据，等于走了两遍B+树进行搜索，如果数据量接近全表数据量的话，比全表扫描还低，这时mysql就会走全表扫描。 覆盖索引如果查询的字段，是已有的索引，且符合最左前缀原则，则可以直接走索引，这叫覆盖索引。 索引扫描底层原则123考虑如下create index(b) on table1;select b from table1; 这时候主键索引会扫描更多数据，就会走索引。 Order By导致索引失效12create index(b,c,d) on table1;select * from table1 order by (a,b,c); 此时如果数据量比较少的话，排序时间短，全表扫描快。如果数据量大，走索引会更快，虽然会回表，但比排序快。 Mysql 数据类型转换有哪些需要注意charset:字符集 collation:对应国家字符集的排序规则 mysql只把字符转成数字 对字符进行操作索引失效的原理123create index(e) on table1;// e为字符select e from where e=1; 这样会走全表扫描。因为mysql需要先把e字段所有数据转换成数字，然后比较。这样走全表扫描更方便。 Mysql有哪些存储引擎InnoDB默认存储引擎，事务型存储引擎。设计用来处理大量短期事务。 MyISAM5.1之前默认存储引擎，但不支持事务和行级锁，且崩溃后无法安全回复。 Memory存储引擎比MyISAM快一个数量级。数据文件存在内存中，表结构在重启后保留，数据会丢失。一般保存中间数据。 Archive引擎只支持INSERT和Select，会缓存所有的写并利用zlib对插入的行进行压缩。但每次SELECT都需要全表扫描。适合日志和数据采集。 CSV引擎可以将普通的CSV文件作为Mysql表处理，但不支持索引。常作为数据交换。 MyISAM和InnoDB区别（前innodb后myisam)一个支持事务，一个不支持事务 一个锁最小粒度是行锁，一个是表锁 innodb不保存具体行数，而myisam保存，所以进行全表查询，myisam更快。 一个是聚集索引，一个是非聚集索引。myisam主键索引和辅助索引独立，但innodb是在一起的。 innodb支持外键，myisam不支持。 字段优先级优先使用长度短，定长的数值型字段。避免使用ZEROFILL 整形&gt;date,time&gt;enum char&gt;varchar&gt;blob,text Varchar(M)最多存储多少数据最多存储65535字节(2^16-1)个字节 事务并发引发的问题脏读事务A读取到事务B未提交的数据 不可重复读事务A读了两次a，但两次读之间事务B修改了数据a，导致事务B在两次读取出来的数据不一致。 幻读与不可重复读类似，但第二次读到了事务A增加出来的新数据，而不是修改了的数据a 简单描述Mysql索引按字段 主键，唯一索引，普通，前缀索引 其中前缀索引是对二进制类型字段或者字符串类型的前几个字符简历索引。 三星索引 一个查询相关的索引行是相邻的或者至少相距足够靠近，则一星 如果索引中数据顺序和查找中排列顺序一直，则二星 如果索引中的列包含了查询需要的全部列则三星。 Mysql存放多少行2千多万行 提高Insert性能多条合并为一条 调大大批量插入的缓存大小 手动使用事务 默认一次提交一条，可以手动设置为1000条提交一次事务 全局锁、共享锁、排它锁全局锁，全局被锁，数据库只读 共享锁其他事务可并发读。如果事务多读锁进行修改，容易死锁 排它锁只能事务A读写数据，其他事务只能读。排它锁会阻塞所有排它锁和共享锁。 Mysql 读写分离主库写，从库读 关于主从库数据同步，依赖于binlog日志文件，只记录修改操作。 主从结构中，从库会复制一份binlog，然后写一份relay log（中继日志）。启动一个sql线程，执行binlog里的insert和update，这样主从库数据同步。 Mysql分库分表水平拆分 - hash原理 （uid%size)=hashcode 根据时间拆分 聚簇索引和非聚簇索引聚簇索引：数据和索引放一块儿，找到索引就找到数据，且数据的物理存放顺序和索引顺序一直 非聚簇索引：叶子节点不存储数据，存储的数据行的地址。","link":"/2022/03/22/%E3%80%90Mysql%E3%80%91Mysql%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/"},{"title":"【Spring】Spring源码分析（二）","text":"Spring启动流程 首先，对于一个web应用，其部署在web容器(tomcat)中，web容器提供其一个全局的上下文环境，这个上下文就是ServletContext，其为后面的spring IoC容器提供宿主环境； spring容器启动流程 定位在spring中，使用统一的资源表现方式Resource，定位到spring配置文件。 加载在加载这个过程中，主要工作是读取spring配置文件，解析配置文件中的内容，将这些信息转换成为Spring内容可以理解、使用的BeanDefinition。 注册加载过配置文件后，就将BeanDefinition信息注册到BeanDefinitionRegistry接口中，通常情况下Spring容器的实现类都实现这个接口。注册其实就是把beanName和beanDefinition作为键值对放到beanFactory对象的map。 其次，在web.xml中会提供有contextLoaderListener。在web容器启动时，会触发容器初始化事件，此时 contextLoaderListener会监听到这个事件，其contextInitialized方法会被调用，在这个方法中，spring会初始化一个启动上下文，这个上下文被称为根上下文，即WebApplicationContext，这是一个接口类，确切的说，其实际的实现类是 XmlWebApplicationContext：spring的IoC容器，（定位）其对应的Bean定义的配置由web.xml中的 context-param标签指定，（加载）读取并解析spring配置文件，将这些信息转换成为Spring内容可以理解、使用的BeanDefinition。在这个IoC容器初始化完毕后，spring以WebApplicationContext.ROOTWEBAPPLICATIONCONTEXTATTRIBUTE为属性Key，将其存储到ServletContext中，便于获取；（注册）加载过配置文件后，就将BeanDefinition信息注册到BeanDefinitionRegistry接口中，通常情况下Spring容器的实现类都实现这个接口。在加载完所有Bean Class后，开始有序的通过BeanDefinition实例化Bean。 再次，contextLoaderListener监听器初始化完毕后，开始初始化web.xml中配置的Servlet，这里是DispatcherServlet，这个servlet实际上是一个标准的前端控制器，用以转发、匹配、处理每个servlet请求。DispatcherServlet上下文在初始化的时候会建立自己的IoC上下文，用以持有spring mvc相关的bean。在建立DispatcherServlet自己的IoC上下文时，会利用WebApplicationContext.ROOTWEBAPPLICATIONCONTEXTATTRIBUTE 先从ServletContext中获取之前的根上下文(即WebApplicationContext)作为自己上下文的parent上下文。有了这个 parent上下文之后，再初始化自己持有的上下文。这个DispatcherServlet初始化自己上下文的工作在其initStrategies方法中可以看到，大概的工作就是 初始化处理器映射、视图解析等。这个servlet自己持有的上下文默认实现类也是 mlWebApplicationContext。初始化完毕后，spring以与servlet的名字相关(此处不是简单的以servlet名为 Key，而是通过一些转换，具体可自行查看源码)的属性为属性Key，也将其存到ServletContext中，以便后续使用。这样每个servlet 就持有自己的上下文，即拥有自己独立的bean空间，同时各个servlet共享相同的bean，即根上下文(第2步中初始化的上下文)定义的那些 bean。 (44条消息) 【Spring启动过程分析】（1）启动流程简介_程序员面试经验分享的博客-CSDN博客_spring启动流程 Refresh流程refresh源代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869@Overridepublic void refresh() throws BeansException, IllegalStateException { synchronized (this.startupShutdownMonitor) { StartupStep contextRefresh = this.applicationStartup.start(&quot;spring.context.refresh&quot;); // Prepare this context for refreshing. prepareRefresh(); // Tell the subclass to refresh the internal bean factory. ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // Prepare the bean factory for use in this context. prepareBeanFactory(beanFactory); try { // Allows post-processing of the bean factory in context subclasses. postProcessBeanFactory(beanFactory); StartupStep beanPostProcess = this.applicationStartup.start(&quot;spring.context.beans.post-process&quot;); // Invoke factory processors registered as beans in the context. invokeBeanFactoryPostProcessors(beanFactory); // Register bean processors that intercept bean creation. registerBeanPostProcessors(beanFactory); beanPostProcess.end(); // Initialize message source for this context. initMessageSource(); // Initialize event multicaster for this context. initApplicationEventMulticaster(); // Initialize other special beans in specific context subclasses. onRefresh(); // Check for listener beans and register them. registerListeners(); // Instantiate all remaining (non-lazy-init) singletons. finishBeanFactoryInitialization(beanFactory); // Last step: publish corresponding event. finishRefresh(); } catch (BeansException ex) { if (logger.isWarnEnabled()) { logger.warn(&quot;Exception encountered during context initialization - &quot; + &quot;cancelling refresh attempt: &quot; + ex); } // Destroy already created singletons to avoid dangling resources. destroyBeans(); // Reset 'active' flag. cancelRefresh(ex); // Propagate exception to caller. throw ex; } finally { // Reset common introspection caches in Spring's core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); contextRefresh.end(); } }} Spring MVC概念SpringMVC是Spring的后续产品，融合在Srping Web Flow里面。Spring 框架提供了构件Web应用程序的全功能MVC模块，使用Spring可插入的MVC架构，从而在使用Spring进行Web开发时，可以选择使用SpringMVC或者其他MVC框架进行开发。 SringMVC通过一套注解，让普通Java类称为Servlet controller,实现了控制层与Servlet的解耦。传统servlet需要一个请求对应一个Servlet对象。当有多种请求存在时，将会创建大量的servlet对象。而springmvc可以一个controller对应多个servlet请求 支持Rest风格的Url写法 采用松耦合 MVC设计理念 M- model 模型层 DAO封装(MyBatis,JPA) V- view 视图层 前端 C- controller 控制层 Servlet封装 原理 DispatcherServlet 用户请求到达前端控制器，是整个流程控制的中心，由它调用其他组件处理用户的请求，降低组件之间的耦合性。 HandlerMapping HandlerMapping负责根据用户请求找到Handler即对应的处理器。SpringMVC提供了不同映射器的实现不同的映射方式。例如配置文件，注解，实现接口等。 1234567891011121314AbstractDetectingUrlHandlerMappingAbstractHandlerMappingAbstractHandlerMethodMappingAbstractUrlHandlerMappingBeanNameUrlHandlerMappingMatchableHandlerMappingPathPatternMatchableHandlerMappingPathSettingHandlerMapping in HandlerMappingIntrospectorRequestMappingHandlerMappingRequestMappingInfoHandlerMappingRouterFunctionMappingSimpleUrlHandlerMappingWebMvcPropertySourcedRequestMappingHandlerMappingWelcomePageHandlerMapping HandlerAdapter 处理器适配器。通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器执行。 Handler 它就是我们开发中要编写的具体业务控制器。由DispatcherServlet把用户请求转发到Handler。 View Resolver 负责将处理结果生成View视图，View Resolver首先根据逻辑视图名解析成物理师徒名，即具体的页面地址，再生成view视图对象，最后对View进行渲染将处理结果通过页面展示返回给用户 View SpringMVC框架提供了很多View视图类型的支持。包括JstlView,freemakerView,pdfView,最常用jsp","link":"/2022/03/21/%E3%80%90Spring%E3%80%91Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/"},{"title":"【Leetcode刷题笔记】2038 如果相邻两个颜色均相同则删除当前颜色","text":"题目描述总共有 n 个颜色片段排成一列，每个颜色片段要么是 'A' 要么是 'B' 。给你一个长度为 n 的字符串 colors ，其中 colors[i] 表示第 i 个颜色片段的颜色。 Alice 和 Bob 在玩一个游戏，他们 轮流 从这个字符串中删除颜色。Alice 先手 。 如果一个颜色片段为 'A' 且 相邻两个颜色 都是颜色 'A' ，那么 Alice 可以删除该颜色片段。Alice 不可以 删除任何颜色 'B' 片段。 如果一个颜色片段为 'B' 且 相邻两个颜色 都是颜色 'B' ，那么 Bob 可以删除该颜色片段。Bob 不可以 删除任何颜色 'A' 片段。 Alice 和 Bob 不能 从字符串两端删除颜色片段。 如果其中一人无法继续操作，则该玩家 输 掉游戏且另一玩家 获胜 。 假设 Alice 和 Bob 都采用最优策略，如果 Alice 获胜，请返回 true，否则 Bob 获胜，返回 false。 示例 1： 12345678910输入：colors = &quot;AAABABB&quot;输出：true解释：AAABABB -&gt; AABABBAlice 先操作。她删除从左数第二个 'A' ，这也是唯一一个相邻颜色片段都是 'A' 的 'A' 。现在轮到 Bob 操作。Bob 无法执行任何操作，因为没有相邻位置都是 'B' 的颜色片段 'B' 。因此，Alice 获胜，返回 true 。 示例 2： 123456输入：colors = &quot;AA&quot;输出：false解释：Alice 先操作。只有 2 个 'A' 且它们都在字符串的两端，所以她无法执行任何操作。因此，Bob 获胜，返回 false 。 示例 3： 12345678910111213输入：colors = &quot;ABBBBBBBAAA&quot;输出：false解释：ABBBBBBBAAA -&gt; ABBBBBBBAAAlice 先操作。她唯一的选择是删除从右数起第二个 'A' 。ABBBBBBBAA -&gt; ABBBBBBAA接下来轮到 Bob 操作。他有许多选择，他可以选择任何一个 'B' 删除。然后轮到 Alice 操作，她无法删除任何片段。所以 Bob 获胜，返回 false 。 提示： 1 &lt;= colors.length &lt;= 105 colors 只包含字母 'A' 和 'B' Related Topics 贪心 数学 字符串 博弈 题解遍历字符串，找出Alice和Bob分别长度大于3的子串，计算操作数即可。 写这么长纯粹为了降低执行耗时。 12345678910111213141516171819202122232425262728293031323334353637class Solution { public boolean winnerOfGame(String colors) { int n = colors.length(); char[] array=colors.toCharArray(); int scoreA = 0;// Alice's score int scoreB = 0;// Bob's score int flag = array[0] == 'A' ? 0 : 1;// 0 - alice 1 - bob int tmpA=0;// accmulation of alice int tmpB=0;// accmulation of bob for (int i = 0; i &lt; n; i++) { if(array[i]=='A'){ if(flag==0){ tmpA++; }else{ tmpB=0; tmpA=1; flag=0; } }else{ if(flag==1){ tmpB++; }else{ tmpA=0; tmpB=1; flag=1; } } if(tmpA&gt;=3){ scoreA+=tmpA-2; } if(tmpB&gt;=3){ scoreB+=tmpB-2; } } return scoreA&gt;scoreB; }} 时间复杂度O(n) 空间复杂度O(1/n)","link":"/2022/03/22/%E3%80%90Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%912038-%E5%A6%82%E6%9E%9C%E7%9B%B8%E9%82%BB%E4%B8%A4%E4%B8%AA%E9%A2%9C%E8%89%B2%E5%9D%87%E7%9B%B8%E5%90%8C%E5%88%99%E5%88%A0%E9%99%A4%E5%BD%93%E5%89%8D%E9%A2%9C%E8%89%B2/"},{"title":"【Leetcode刷题笔记】2055 蜡烛之间的盘子","text":"题目描述 给你一个长桌子，桌子上盘子和蜡烛排成一列。给你一个下标从 0 开始的字符串 s ，它只包含字符 '*' 和 '|' ，其中 '*' 表示一个 盘子 ，'|' 表示一支 蜡烛 。 同时给你一个下标从 0 开始的二维整数数组 queries ，其中 queries[i] = [lefti, righti] 表示 子字符串 s[lefti...righti] （包含左右端点的字符）。对于每个查询，你需要找到 子字符串中 在 两支蜡烛之间 的盘子的 数目 。如果一个盘子在 子字符串中 左边和右边 都 至少有一支蜡烛，那么这个盘子满足在 两支蜡烛之间 。 比方说，s = &quot;||**||**|*&quot; ，查询 [3, 8] ，表示的是子字符串 &quot;*||***\\**\\***|&quot; 。子字符串中在两支蜡烛之间的盘子数目为 2 ，子字符串中右边两个盘子在它们左边和右边 都 至少有一支蜡烛。 请你返回一个整数数组 answer ，其中 answer[i] 是第 i 个查询的答案。 示例 1: 12345输入：s = &quot;**|**|***|&quot;, queries = [[2,5],[5,9]]输出：[2,3]解释：- queries[0] 有两个盘子在蜡烛之间。- queries[1] 有三个盘子在蜡烛之间。 示例 2: 12345输入：s = &quot;***|**|*****|**||**|*&quot;, queries = [[1,17],[4,5],[14,17],[5,11],[15,16]]输出：[9,0,0,0,0]解释：- queries[0] 有 9 个盘子在蜡烛之间。- 另一个查询没有盘子在蜡烛之间。 提示： 3 &lt;= s.length &lt;= 105 s 只包含字符 '*' 和 '|' 。 1 &lt;= queries.length &lt;= 105 queries[i].length == 2 0 &lt;= lefti &lt;= righti &lt; s.length 题解这道题是经典的前缀和问题。 根据题我们可以很容易得知只需找到左边第一个蜡烛left和右边第一个蜡烛right之间的蜡烛即可。我们可以用preSum[i]表示i之前的蜡烛数量，因而[left,right]之间的蜡烛数为preSum[right]-preSum[left] left数组通过从后往前遍历求得 right数组从前往后遍历即可。 代码12345678910111213141516171819202122232425262728293031323334353637class Solution { public int[] platesBetweenCandles(String s, int[][] queries) { char[] as = s.toCharArray(); int n = as.length; int[] preSum = new int[n]; int[] answer = new int[queries.length]; int[] left = new int[n]; int[] right = new int[n]; for (int i = 0, sum = 0; i &lt; n; i++) { if (as[i] == '*') { sum++; } preSum[i] = sum; } for (int i = n - 1, leftCandle = n - 1; i &gt;= 0; i--) { if (as[i] == '|') { leftCandle = i; } left[i] = leftCandle; } for (int i = 0, rightCandle = 0; i &lt; n; i++) { if (as[i] == '|') { rightCandle = i; } right[i] = rightCandle; } for (int i = 0; i &lt; queries.length; i++) { int ans = preSum[right[queries[i][1]]] - preSum[left[queries[i][0]]]; if (ans &gt;= 0) answer[i] = ans; else answer[i] = 0; } return answer; }} 复杂度 空间复杂度O(n+C) c为queries.length 时间复杂度O(n)","link":"/2022/03/08/%E3%80%90Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%912055%20%E8%9C%A1%E7%83%9B%E4%B9%8B%E9%97%B4%E7%9A%84%E7%9B%98%E5%AD%90%20-%20%E5%89%AF%E6%9C%AC/"},{"title":"【Leetcode刷题笔记】682 棒球比赛","text":"题目描述 你现在是一场采用特殊赛制棒球比赛的记录员。这场比赛由若干回合组成，过去几回合的得分可能会影响以后几回合的得分。 比赛开始时，记录是空白的。你会得到一个记录操作的字符串列表 ops，其中 ops[i] 是你需要记录的第 i 项操作，ops 遵循下述规则： 整数 x - 表示本回合新获得分数 x &quot;+&quot; - 表示本回合新获得的得分是前两次得分的总和。题目数据保证记录此操作时前面总是存在两个有效的分数。 &quot;D&quot; - 表示本回合新获得的得分是前一次得分的两倍。题目数据保证记录此操作时前面总是存在一个有效的分数。 &quot;C&quot; - 表示前一次得分无效，将其从记录中移除。题目数据保证记录此操作时前面总是存在一个有效的分数。 请你返回记录中所有得分的总和。 示例 1： 123456789输入：ops = [&quot;5&quot;,&quot;2&quot;,&quot;C&quot;,&quot;D&quot;,&quot;+&quot;]输出：30解释：&quot;5&quot; - 记录加 5 ，记录现在是 [5]&quot;2&quot; - 记录加 2 ，记录现在是 [5, 2]&quot;C&quot; - 使前一次得分的记录无效并将其移除，记录现在是 [5].&quot;D&quot; - 记录加 2 * 5 = 10 ，记录现在是 [5, 10].&quot;+&quot; - 记录加 5 + 10 = 15 ，记录现在是 [5, 10, 15].所有得分的总和 5 + 10 + 15 = 30 示例 2： 123456789101112输入：ops = [&quot;5&quot;,&quot;-2&quot;,&quot;4&quot;,&quot;C&quot;,&quot;D&quot;,&quot;9&quot;,&quot;+&quot;,&quot;+&quot;]输出：27解释：&quot;5&quot; - 记录加 5 ，记录现在是 [5]&quot;-2&quot; - 记录加 -2 ，记录现在是 [5, -2]&quot;4&quot; - 记录加 4 ，记录现在是 [5, -2, 4]&quot;C&quot; - 使前一次得分的记录无效并将其移除，记录现在是 [5, -2]&quot;D&quot; - 记录加 2 * -2 = -4 ，记录现在是 [5, -2, -4]&quot;9&quot; - 记录加 9 ，记录现在是 [5, -2, -4, 9]&quot;+&quot; - 记录加 -4 + 9 = 5 ，记录现在是 [5, -2, -4, 9, 5]&quot;+&quot; - 记录加 9 + 5 = 14 ，记录现在是 [5, -2, -4, 9, 5, 14]所有得分的总和 5 + -2 + -4 + 9 + 5 + 14 = 27 示例 3： 12输入：ops = [&quot;1&quot;]输出：1 提示： 1 &lt;= ops.length &lt;= 1000 ops[i] 为 &quot;C&quot;、&quot;D&quot;、&quot;+&quot;，或者一个表示整数的字符串。整数范围是 [-3 * 104, 3 * 104] 对于 &quot;+&quot; 操作，题目数据保证记录此操作时前面总是存在两个有效的分数 对于 &quot;C&quot; 和 &quot;D&quot; 操作，题目数据保证记录此操作时前面总是存在一个有效的分数 Related Topics 栈 数组 模拟 题解用栈模拟。 最近很忙，做了很多Leetcode的题，都没写题解。今天要出门，写个每日一题的题解把博客续上。之前的题解慢慢更。 代码12345678910111213141516171819202122232425class Solution { public int calPoints(String[] ops) { Stack&lt;Integer&gt; scoreStack= new Stack&lt;&gt;(); int n= ops.length; int score=0; for (int i = 0; i &lt; n; i++) { if(ops[i].equals(&quot;+&quot;)){ int score1=scoreStack.pop(); int score2=scoreStack.peek(); scoreStack.push(score1); scoreStack.push(score1+score2); }else if(ops[i].equals(&quot;D&quot;)){ scoreStack.push(scoreStack.peek()*2); }else if(ops[i].equals(&quot;C&quot;)){ scoreStack.pop(); }else{ scoreStack.push(Integer.parseInt(ops[i])); } } while(!scoreStack.isEmpty()){ score+=scoreStack.pop(); } return score; }} 复杂度 时间复杂度O(n) 空间复杂度O(n)","link":"/2022/03/26/%E3%80%90Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%91682%20%E6%A3%92%E7%90%83%E6%AF%94%E8%B5%9B/"}],"tags":[{"name":"刷题笔记","slug":"刷题笔记","link":"/tags/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"},{"name":"Anaconda","slug":"Anaconda","link":"/tags/Anaconda/"},{"name":"Pip","slug":"Pip","link":"/tags/Pip/"},{"name":"Java基础","slug":"Java基础","link":"/tags/Java%E5%9F%BA%E7%A1%80/"},{"name":"运维","slug":"运维","link":"/tags/%E8%BF%90%E7%BB%B4/"},{"name":"Docker","slug":"Docker","link":"/tags/Docker/"},{"name":"dfs","slug":"dfs","link":"/tags/dfs/"},{"name":"源码分析","slug":"源码分析","link":"/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"name":"实战","slug":"实战","link":"/tags/%E5%AE%9E%E6%88%98/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"}],"categories":[{"name":"LeetCode","slug":"LeetCode","link":"/categories/LeetCode/"},{"name":"杂记","slug":"杂记","link":"/categories/%E6%9D%82%E8%AE%B0/"},{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"服务器","slug":"服务器","link":"/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"Redis","slug":"Redis","link":"/categories/Redis/"},{"name":"Spring","slug":"Spring","link":"/categories/Spring/"},{"name":"实战","slug":"实战","link":"/categories/%E5%AE%9E%E6%88%98/"},{"name":"面试","slug":"面试","link":"/categories/%E9%9D%A2%E8%AF%95/"}]}