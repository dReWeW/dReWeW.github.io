{"pages":[],"posts":[{"title":"【Leetcode刷题笔记】1219 黄金矿工","text":"题目描述你要开发一座金矿，地质勘测学家已经探明了这座金矿中的资源分布，并用大小为 m * n 的网格 grid 进行了标注。每个单元格中的整数就表示这一单元格中的黄金数量；如果该单元格是空的，那么就是 0。 为了使收益最大化，矿工需要按以下规则来开采黄金： 每当矿工进入一个单元，就会收集该单元格中的所有黄金。 矿工每次可以从当前位置向上下左右四个方向走。 每个单元格只能被开采（进入）一次。 不得开采（进入）黄金数目为 0 的单元格。 矿工可以从网格中 任意一个 有黄金的单元格出发或者是停止。 示例 1： 1234567输入：grid = [[0,6,0],[5,8,7],[0,9,0]]输出：24解释：[[0,6,0], [5,8,7], [0,9,0]]一种收集最多黄金的路线是：9 -&gt; 8 -&gt; 7。 示例 2： 123456789输入：grid = [[1,0,7],[2,0,6],[3,4,5],[0,3,0],[9,0,20]]输出：28解释：[[1,0,7], [2,0,6], [3,4,5], [0,3,0], [9,0,20]]一种收集最多黄金的路线是：1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; 7。 提示： 1 &lt;= grid.length, grid[i].length &lt;= 15 0 &lt;= grid[i][j] &lt;= 100 最多 25 个单元格中有黄金。 题解这是一道典型的多源DFS题目。从每个不是0的单元格出发遍历每条可能的路径，记录最大挖矿值。 代码如下 12345678910111213141516171819202122232425262728293031323334353637class Solution { public static final int[][] dirs = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}}; int res = 0; int[][] grid; int m; int n; public int getMaximumGold(int[][] grid) { this.grid = grid; m = grid.length; n = grid[0].length; for (int i = 0; i &lt; m; i++) { for (int j = 0; j &lt; n; j++) { if (grid[i][j] != 0) { dfs(i, j, 0); } } } return res; } private void dfs(int x, int y, int gold) { gold += grid[x][y]; res = Math.max(res, gold); int rec = grid[x][y]; grid[x][y] = 0; for (int[] dir : dirs) { int nx = x + dir[0], ny = y + dir[1]; if (nx &lt; m &amp;&amp; nx &gt;= 0 &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; n &amp;&amp; grid[nx][ny] != 0) { dfs(nx, ny, gold); } } grid[x][y] = rec; }} 复杂度 空间复杂度O(1) 时间复杂度O(3^T)","link":"/2022/02/25/%E3%80%90Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%911219%20%E9%BB%84%E9%87%91%E7%9F%BF%E5%B7%A5/"},{"title":"【Leetcode刷题笔记】1601 最多可达成的换楼请求","text":"问题我们有 n 栋楼，编号从 0 到 n - 1 。每栋楼有若干员工。由于现在是换楼的季节，部分员工想要换一栋楼居住。 给你一个数组 requests ，其中 requests[i] = [fromi, toi] ，表示一个员工请求从编号为 fromi 的楼搬到编号为 toi 的楼。 一开始 所有楼都是满的，所以从请求列表中选出的若干个请求是可行的需要满足 每栋楼员工净变化为 0 。意思是每栋楼 离开 的员工数目 等于 该楼 搬入 的员工数数目。比方说 n = 3 且两个员工要离开楼 0 ，一个员工要离开楼 1 ，一个员工要离开楼 2 ，如果该请求列表可行，应该要有两个员工搬入楼 0 ，一个员工搬入楼 1 ，一个员工搬入楼 2 。 请你从原请求列表中选出若干个请求，使得它们是一个可行的请求列表，并返回所有可行列表中最大请求数目。 题解根据题目，n&lt;=20，所以可以用二进制枚举每一种可能。 代码Java代码，双指针 123456789101112131415161718192021222324252627282930class Solution { public int maximumRequests(int n, int[][] requests) { int[] delta = new int[n]; int ans = 0, m = requests.length; for (int mask = 0; mask &lt; (1 &lt;&lt; m); ++mask) { int cnt = Integer.bitCount(mask); if (cnt &lt;= ans) { continue; } Arrays.fill(delta, 0); for (int i = 0; i &lt; m; ++i) { if ((mask &amp; (1 &lt;&lt; i)) != 0) { ++delta[requests[i][0]]; --delta[requests[i][1]]; } } boolean flag = true; for (int x : delta) { if (x != 0) { flag = false; break; } } if (flag) { ans = cnt; } } return ans; }} 复杂度 时间复杂度O(2^m*n) 空间复杂度O(n)","link":"/2022/02/28/%E3%80%90Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%911601%20%E6%9C%80%E5%A4%9A%E5%8F%AF%E8%BE%BE%E6%88%90%E7%9A%84%E6%8D%A2%E6%A5%BC%E8%AF%B7%E6%B1%82/"},{"title":"【Leetcode刷题笔记】三数之和","text":"问题给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。 注意：答案中不可以包含重复的三元组。 1234567891011示例 1：输入：nums = [-1,0,1,2,-1,-4]输出：[[-1,-1,2],[-1,0,1]]示例 2：输入：nums = []输出：[]示例 3：输入：nums = [0]输出：[] 提示： 0 &lt;= nums.length &lt;= 3000-105 &lt;= nums[i] &lt;= 105 题解Leetcode第一题两数之和为我提供了思路，实际上稍微思考就可以将问题转换为N个两数之和的问题。 由于本人做两数之和的时间已经比较久远，忘记了其多种做法，这里列出两种思路 先排序，然后三层循环遍历求解。时间复杂度O(n3)，空间复杂度O(1)。 双指针 先排序 建立N个两数之和问题，即对数组中每个数做两数之和求解，只不过求和目标值不是0，而是’-nums[i]’。 ①如果nums[i]&gt;0，直接不用做两数之和的问题。因为数组已排序，说明后面的数都是&gt;0，因而可以直接返回结果 ②如果nums[i]&lt;=0，设置两个指针j=i+1,k=n-1. ​ 设置while条件(j&lt;k) ​ if(nums[j]+nums[k]&gt;tmp): k向前移动 if(*nums*[j]+*nums*[k]&lt;tmp): j向后移动 ​ if(nums[j]+nums[k]==tmp): 加入结果数组 ​ 去重操作 事件复杂度O(n2),O(1) 代码Java代码，双指针 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution { public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) { int n = nums.length; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); // return empty set if(n&lt;3){ return res; } Arrays.sort(nums); for(int i=0;i&lt;n-2;i++){ if(nums[i]&gt;0){ break; } int tmp=-nums[i]; int j=i+1,k=n-1; while(j&lt;k){ if(nums[j]+nums[k]&gt;tmp){ k--; }else if(nums[j]+nums[k]&lt;tmp){ j++; }else if(nums[j]+nums[k]==tmp){ res.add(new ArrayList&lt;Integer&gt;(Arrays.asList(nums[i],nums[j],nums[k]))); while(j&lt;n-1&amp;&amp;nums[j]==nums[j+1]){ j++; } while(k&gt;0&amp;&amp;nums[k]==nums[k-1]){ k--; } j++; k--; if(!(j&lt;k)){ break; } } } while(i&lt;n-2&amp;&amp;nums[i]==nums[i+1]){ i++; } } return res; }} 成绩","link":"/2022/02/17/%E3%80%90Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%9115%20%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"},{"title":"【Leetcode刷题笔记】18 四数之和","text":"题目描述给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）： 0 &lt;= a, b, c, d &lt; n a、b、c 和 d 互不相同 nums[a] + nums[b] + nums[c] + nums[d] == target 你可以按 任意顺序 返回答案 。 示例 1： 12输入：nums = [1,0,-1,0,-2,2], target = 0输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]] 示例 2： 12输入：nums = [2,2,2,2,2], target = 8输出：[[2,2,2,2]] 提示： 1 &lt;= nums.length &lt;= 200 -109 &lt;= nums[i] &lt;= 109 -109 &lt;= target &lt;= 109 Related Topics 数组 双指针 排序 题解参照 1 两数之和 以及 15 三数之和的方法，我们可以将其分解为$n^2$​个两数之和问题。对于任意nums[i]+nums[j]，我们需要在剩下的数组中寻找两数和为target-nums[i]-nums[j]。 需要注意，去重通过，每当完成一层遍历时，跳过该层遍历已经使用过的使用过的数即可。 代码12345678910111213141516171819202122232425262728293031323334353637class Solution { public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) { List&lt;List&lt;Integer&gt;&gt; lists = new ArrayList&lt;List&lt;Integer&gt;&gt;(); Arrays.sort(nums); int n = nums.length; for (int i = 0; i &lt; n; i++) { for (int j = i + 1; j &lt; n; j++) { int tar = target - nums[i] - nums[j]; int k = j + 1, l = n - 1; while (k &lt; l) { if (nums[k] + nums[l] &gt; tar) { l--; } else if (nums[k] + nums[l] &lt; tar) { k++; } else if (nums[k] + nums[l] == tar) { lists.add(Arrays.asList(nums[i],nums[j],nums[k],nums[l])); while (k + 1 &lt; n &amp;&amp; nums[k] == nums[k + 1] &amp;&amp; k &lt; l) { k++; } while (l - 1 &gt; j &amp;&amp; nums[l] == nums[l - 1] &amp;&amp; k &lt; l) { l--; } k++; l--; } } while(j+1&lt;n&amp;&amp;nums[j]==nums[j+1]){ j++; } } while (i+1&lt;n&amp;&amp;nums[i]==nums[i+1]){ i++; } } return lists; }} 复杂度分析 时间复杂度 O(n3+nlogn) 空间复杂度O(C)，其中C = 解的个数","link":"/2022/02/23/%E3%80%90Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%9118%20%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/"},{"title":"【Leetcode刷题笔记】1706 球会落何处","text":"题目描述用一个大小为 m x n 的二维网格 grid 表示一个箱子。你有 n 颗球。箱子的顶部和底部都是开着的。 箱子中的每个单元格都有一个对角线挡板，跨过单元格的两个角，可以将球导向左侧或者右侧。 将球导向右侧的挡板跨过左上角和右下角，在网格中用 1 表示。 将球导向左侧的挡板跨过右上角和左下角，在网格中用 -1 表示。 在箱子每一列的顶端各放一颗球。每颗球都可能卡在箱子里或从底部掉出来。如果球恰好卡在两块挡板之间的 “V” 形图案，或者被一块挡导向到箱子的任意一侧边上，就会卡住。 返回一个大小为 n 的数组 answer ，其中 answer[i] 是球放在顶部的第 i 列后从底部掉出来的那一列对应的下标，如果球卡在盒子里，则返回 -1 。 示例 1： 12345678输入：grid = [[1,1,1,-1,-1],[1,1,1,-1,-1],[-1,-1,-1,1,1],[1,1,1,1,-1],[-1,-1,-1,-1,-1]]输出：[1,-1,-1,-1,-1]解释：示例如图：b0 球开始放在第 0 列上，最终从箱子底部第 1 列掉出。b1 球开始放在第 1 列上，会卡在第 2、3 列和第 1 行之间的 &quot;V&quot; 形里。b2 球开始放在第 2 列上，会卡在第 2、3 列和第 0 行之间的 &quot;V&quot; 形里。b3 球开始放在第 3 列上，会卡在第 2、3 列和第 0 行之间的 &quot;V&quot; 形里。b4 球开始放在第 4 列上，会卡在第 2、3 列和第 1 行之间的 &quot;V&quot; 形里。 示例 2： 123输入：grid = [[-1]]输出：[-1]解释：球被卡在箱子左侧边上。 示例 3： 12输入：grid = [[1,1,1,1,1,1],[-1,-1,-1,-1,-1,-1],[1,1,1,1,1,1],[-1,-1,-1,-1,-1,-1]]输出：[0,1,2,3,4,-1] 提示： m == grid.length n == grid[i].length 1 &lt;= m, n &lt;= 100 grid[i][j] 为 1 或 -1 Related Topics 深度优先搜索 数组 动态规划 矩阵 模拟 题解由于此题每一层的出口都直接由上一层的导板方向所影响，所以只需要在向下遍历每一层的同时，维护当前层出口的dp数组即可。 123456789101112131415161718192021222324252627282930class Solution { public int[] findBall(int[][] grid) { // dp[n] // 状态转移方程如下 // if(grid[row][dp[col]]==1&amp;&amp;grid[row][dp[col]+1]==1 dp[col]+=1; // if(grid[row][dp[col]]==1&amp;&amp;grid[row][dp[col]+1]==-1 dp[col]=-1; // if(grid[row][dp[col]]==-1&amp;&amp;grid[row][dp[col]-1]==-1 dp[col]-=1; // if(grid[row][dp[col]]==-1&amp;&amp;grid[row][dp[col]-1]==1 dp[col]=-1; int m = grid.length; int n = grid[0].length; int[] dp = new int[n]; for (int i = 0; i &lt; n; i++) { dp[i] = i; } for (int row = 0; row &lt; m; row++) { for (int col = 0; col &lt; n; col++) { if (dp[col] != -1) { if (grid[row][dp[col]] == -1 &amp;&amp; dp[col] - 1 &gt;= 0 &amp;&amp; grid[row][dp[col] - 1] == -1) { dp[col] -= 1; } else if (grid[row][dp[col]] == 1 &amp;&amp; dp[col] + 1 &lt; n &amp;&amp; grid[row][dp[col] + 1] == 1) { dp[col] += 1; } else { dp[col] = -1; } } } } return dp; }} 复杂度分析 时间复杂度 O(mn+n) 空间复杂度O(n)","link":"/2022/02/24/%E3%80%90Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%911706%20%E7%90%83%E4%BC%9A%E8%90%BD%E4%BD%95%E5%A4%84/"},{"title":"【Leetcode刷题笔记】2044 统计按位或能得到最大值的子集数目","text":"题目描述 给你一个整数数组 nums ，请你找出 nums 子集 按位或 可能得到的 最大值 ，并返回按位或能得到最大值的 不同非空子集的数目 。 如果数组 a 可以由数组 b 删除一些元素（或不删除）得到，则认为数组 a 是数组 b 的一个 子集 。如果选中的元素下标位置不一样，则认为两个子集 不同 。 对数组 a 执行 按位或 ，结果等于 a[0] **OR** a[1] **OR** ... **OR** a[a.length - 1]（下标从 0 开始）。 示例 1： 12345输入：nums = [3,1]输出：2解释：子集按位或能得到的最大值是 3 。有 2 个子集按位或可以得到 3 ：- [3]- [3,1] 示例 2： 123输入：nums = [2,2,2]输出：7解释：[2,2,2] 的所有非空子集的按位或都可以得到 2 。总共有 23 - 1 = 7 个子集。 示例 3： 123456789输入：nums = [3,2,1,5]输出：6解释：子集按位或可能的最大值是 7 。有 6 个子集按位或可以得到 7 ：- [3,5]- [3,1,5]- [3,2,5]- [3,2,1,5]- [2,5]- [2,1,5] 提示： 1 &lt;= nums.length &lt;= 16 1 &lt;= nums[i] &lt;= 105 题解解决此题需要解决两个主要问题： 如何保证遍历到nums的所有子集 如何保证不重复 我们知道，对于一个集合的所有子集，当集合添加了新的元素，其新子集等于在原子集上增添新的元素。然后对新子集依次按位或，统计和更新最大值和个数即可。这样做的时间复杂度是$O(2^n*n)$，这是第一种暴力解法。 分析可以发现，新子集的按位或结果，是原子集按位或结果再与新元素按位或后的结果。这个操作是$O(1)$的复杂度，因而总的时间复杂度可以优化到$O(2^n)$，对应法二的回溯法 代码法一： 暴力 1234567891011121314151617181920212223242526272829303132333435363738394041import java.util.ArrayList;import java.util.Arrays;import java.util.List;import java.util.stream.Collectors;class Solution { int max; int res; public int countMaxOrSubsets(int[] nums) { // 生成nums的所有子集 List&lt;List&lt;Integer&gt;&gt; subsets = getSubsets(nums); return res; } private List&lt;List&lt;Integer&gt;&gt; getSubsets(int[] nums) { List&lt;List&lt;Integer&gt;&gt; allSubSets = new ArrayList&lt;&gt;(); // 空集 allSubSets.add(new ArrayList&lt;&gt;()); // 每个元素可以与现有子集组合，生成res.size()个新子集 for (int num : nums) { int size = allSubSets.size(); for (int i = 0; i &lt; size; i++) { List&lt;Integer&gt; subset = new ArrayList&lt;&gt;(allSubSets.get(i)); subset.add(num); int or = subset.stream().reduce(0, (a, b) -&gt; a | b); // 如果or大于max，则更新max，重置res // 如果or等于max，则res++ if (or &gt; max) { max = or; res = 1; } else if (or == max) { res++; } allSubSets.add(subset); } } return allSubSets; }} 法二：回溯 1234567891011121314151617181920212223242526272829303132333435import java.util.ArrayList;import java.util.Arrays;import java.util.List;import java.util.stream.Collectors;class Solution { int max; int res; int[] nums; public int countMaxOrSubsets(int[] nums) { // 生成nums的所有子集 this.nums=nums; backtrack(0,0); return res; } // 回溯 private void backtrack(int val,int index){ // 如果index等于nums.length时，则比较val与max的值 // 二叉树保证不会产生重复的结果，但必须要遍历到最后一个节点 if(nums.length==index){ if(val&gt;max){ max=val; res=1; }else if(val==max){ res++; } return; } backtrack(val|nums[index],index+1); backtrack(val,index+1); }}","link":"/2022/03/15/%E3%80%90Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%912044%20%E7%BB%9F%E8%AE%A1%E6%8C%89%E4%BD%8D%E6%88%96%E8%83%BD%E5%BE%97%E5%88%B0%E6%9C%80%E5%A4%A7%E5%80%BC%E7%9A%84%E5%AD%90%E9%9B%86%E6%95%B0%E7%9B%AE/"},{"title":"【Leetcode刷题笔记】1994 好子集数目","text":"题目描述 给你一个整数数组 nums 。如果 nums 的一个子集中，所有元素的乘积可以表示为一个或多个 互不相同的质数 的乘积，那么我们称它为 好子集 。 比方说，如果 1nums = [1, 2, 3, 4] [2, 3] ，[1, 2, 3] 和 [1, 3] 是 好 子集，乘积分别为 6 = 23 ，6 = 23 和 3 = 3 。 [1, 4] 和 [4] 不是 好 子集，因为乘积分别为 4 = 22 和 4 = 22 请你返回 nums 中不同的 好 子集的数目对 109 + 7 取余 的结果。 nums 中的 子集 是通过删除 nums 中一些（可能一个都不删除，也可能全部都删除）元素后剩余元素组成的数组。如果两个子集删除的下标不同，那么它们被视为不同的子集。 示例 1： 123456789输入：nums = [1,2,3,4]输出：6解释：好子集为：- [1,2]：乘积为 2 ，可以表示为质数 2 的乘积。- [1,2,3]：乘积为 6 ，可以表示为互不相同的质数 2 和 3 的乘积。- [1,3]：乘积为 3 ，可以表示为质数 3 的乘积。- [2]：乘积为 2 ，可以表示为质数 2 的乘积。- [2,3]：乘积为 6 ，可以表示为互不相同的质数 2 和 3 的乘积。- [3]：乘积为 3 ，可以表示为质数 3 的乘积。 示例 2： 12345678输入：nums = [4,2,3,15]输出：5解释：好子集为：- [2]：乘积为 2 ，可以表示为质数 2 的乘积。- [2,3]：乘积为 6 ，可以表示为互不相同质数 2 和 3 的乘积。- [2,15]：乘积为 30 ，可以表示为互不相同质数 2，3 和 5 的乘积。- [3]：乘积为 3 ，可以表示为质数 3 的乘积。- [15]：乘积为 15 ，可以表示为互不相同质数 3 和 5 的乘积。 提示： 1 &lt;= nums.length &lt;= 105 1 &lt;= nums[i] &lt;= 30 题解这道题因为数字范围在[1,30]之间，因而我们可以做以下分类 1 对于任何一个好子集，可以以任何个数存在，且依然是好子集。 4,8 ,9 ,12,16,18,20,24,25,27,28 因为存在平方因子，因而不能存在在好子集中。 2, 3, 5, 6, 7 ,10, 11, 13, 14, 17, 19, 21, 22, 23, 26 , 29, 30 不存在平方因子，因而可以出现在好子集中，且最多出现一次 注意到质数是2, 3, 5, 7, 11, 13, 17, 19, 23, 29，总共十 个。可以用十位二进制数来表示好子集的乘积用了哪些质因子。 后面是动态规划 （这道题背着官方的答案做的。 题解后面再完善完善） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution { public static int[] PRIMES = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29}; public static final int mod = 1000000007; public int numberOfGoodSubsets(int[] nums) { int[] cnt = new int[31]; int n = nums.length; int[] dp = new int[1 &lt;&lt; PRIMES.length]; for (int i = 0; i &lt; n; i++) { cnt[nums[i]]++; } dp[0] = 1; for (int i = 0; i &lt; cnt[1]; i++) { dp[0] = dp[0] * 2 % mod; } for (int i = 2; i &lt; 31; i++) { if (cnt[i] == 0) { continue; } boolean check = true; int subnet = 0; for (int j = 0; j &lt; PRIMES.length; j++) { if (i % (PRIMES[j] * PRIMES[j]) == 0) { check = false; break; } if (i % PRIMES[j] == 0) { subnet |= 1 &lt;&lt; j; } } if (!check) { continue; } for (int mask = (1 &lt;&lt; PRIMES.length) - 1; mask &gt;= subnet; mask--) { if ((mask &amp; subnet) == subnet) { dp[mask] = (int) ((dp[mask] + ((long) dp[mask ^ subnet]) * cnt[i]) % mod); } } } int res=0; for (int mask = 1, maskMax = (1 &lt;&lt; PRIMES.length); mask &lt; maskMax; ++mask) { res = (res + dp[mask]) % mod; } return res; }} 复杂度 空间复杂度O(2^10) 时间复杂度O(30*2^10)","link":"/2022/02/22/%E3%80%90Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%911994%20%E5%A5%BD%E5%AD%90%E9%9B%86%E6%95%B0%E7%9B%AE/"},{"title":"【Leetcode刷题笔记】2049 统计最高分的节点数目","text":"题目描述 给你一棵根节点为 0 的 二叉树 ，它总共有 n 个节点，节点编号为 0 到 n - 1 。同时给你一个下标从 0 开始的整数数组 parents 表示这棵树，其中 parents[i] 是节点 i 的父节点。由于节点 0 是根，所以 parents[0] == -1 。 一个子树的 大小 为这个子树内节点的数目。每个节点都有一个与之关联的 分数 。求出某个节点分数的方法是，将这个节点和与它相连的边全部 删除 ，剩余部分是若干个 非空 子树，这个节点的 分数 为所有这些子树 大小的乘积 。 请你返回有 最高得分 节点的 数目 。 题解得到一个点的分数需要三个部分。n1: 节点左子树节点数 n2:节点右子树节点数 n3:除开节点本身和其子树的剩下的子树的节点数。 $Point=n1n2n3$ $n3=N-n1-n2-1$ 综上可推出求出n1,n2即可求出Point 对于一个节点，dfs其子树，返回遍历到的节点数即可得到其子树的节点数。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution { int[] ans; int n; int[] children1; int[] children2; public int countHighestScoreNodes(int[] parents) { n = parents.length; ans = new int[n]; children1=new int[n]; children2=new int[n]; for (int i = 1; i &lt; n; i++) { if(children1[parents[i]]==0){ children1[parents[i]]=i; }else{ children2[parents[i]]=i; } } dfs( 0, parents); int max = 0; int res = 0; for (int i = 0; i &lt; n; i++) { if (ans[i] &gt; max) { max = ans[i]; res = 1; } else if (ans[i] == max) { res++; } } } private int dfs(int node, int[] parents) { List&lt;Integer&gt; subTreeNodes = new ArrayList&lt;&gt;(); int subNodes = 0; if (children1[node] != 0) { int tmp = dfs( children1[node], parents); subNodes += tmp; subTreeNodes.add(tmp); } if (children2[node] != 0) { int tmp = dfs( children2[node], parents); subNodes += tmp; subTreeNodes.add(tmp); } if (node != 0) subTreeNodes.add(n - subNodes - 1); ans[node] = 1; for (Integer nodes : subTreeNodes) { ans[node] *= nodes; } return subNodes + 1; }} 复杂度 空间复杂度O(n） 时间复杂度O(3*n)","link":"/2022/03/11/%E3%80%90Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%912049%20%E7%BB%9F%E8%AE%A1%E6%9C%80%E9%AB%98%E5%88%86%E7%9A%84%E8%8A%82%E7%82%B9%E6%95%B0%E7%9B%AE/"},{"title":"【Leetcode刷题笔记】21 合并两个有序链表","text":"题解将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例 1： 12输入：l1 = [1,2,4], l2 = [1,3,4]输出：[1,1,2,3,4,4] 示例 2： 12输入：l1 = [], l2 = []输出：[] 示例 3： 12输入：l1 = [], l2 = [0]输出：[0] 提示： 两个链表的节点数目范围是 [0, 50] -100 &lt;= Node.val &lt;= 100 l1 和 l2 均按 非递减顺序 排列 题解注意到题中给出节点数目可以为0，因而需要单独处理数目为0的情况。 由于链表已经有序，因而只需要采用双指针，依次遍历两个链表，将一个链表 s1 合并到另一个链表s2 中即可。 当s1.val&lt;=s2.val&lt;=s1.next.val || s1.next==null 时，s2加入到s1后面。更新s1和s2的值 否则s1=s1.next 代码123456789101112131415161718192021222324252627282930class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { ListNode head1, head2, res; if(list1==null){ return list2; }else if(list2==null){ return list1; } if (list1.val &lt;= list2.val) { head1 = list1; head2 = list2; res = list1; } else { head1 = list2; head2 = list1; res = list2; } while (head2 != null) { if ((head2.val &gt;= head1.val &amp;&amp; head1.next != null &amp;&amp; head2.val &lt;= head1.next.val)||head1.next==null) { ListNode tmp = new ListNode(head2.val, head1.next); head1.next = tmp; head1 = head1.next; head2 = head2.next; } else if(head1.next!=null){ head1 = head1.next; } } return res; }}","link":"/2022/02/23/%E3%80%90Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%9121%20%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"},{"title":"【Leetcode刷题笔记】2055 蜡烛之间的盘子","text":"题目描述 给你一个长桌子，桌子上盘子和蜡烛排成一列。给你一个下标从 0 开始的字符串 s ，它只包含字符 '*' 和 '|' ，其中 '*' 表示一个 盘子 ，'|' 表示一支 蜡烛 。 同时给你一个下标从 0 开始的二维整数数组 queries ，其中 queries[i] = [lefti, righti] 表示 子字符串 s[lefti...righti] （包含左右端点的字符）。对于每个查询，你需要找到 子字符串中 在 两支蜡烛之间 的盘子的 数目 。如果一个盘子在 子字符串中 左边和右边 都 至少有一支蜡烛，那么这个盘子满足在 两支蜡烛之间 。 比方说，s = &quot;||**||**|*&quot; ，查询 [3, 8] ，表示的是子字符串 &quot;*||***\\**\\***|&quot; 。子字符串中在两支蜡烛之间的盘子数目为 2 ，子字符串中右边两个盘子在它们左边和右边 都 至少有一支蜡烛。 请你返回一个整数数组 answer ，其中 answer[i] 是第 i 个查询的答案。 示例 1: 12345输入：s = &quot;**|**|***|&quot;, queries = [[2,5],[5,9]]输出：[2,3]解释：- queries[0] 有两个盘子在蜡烛之间。- queries[1] 有三个盘子在蜡烛之间。 示例 2: 12345输入：s = &quot;***|**|*****|**||**|*&quot;, queries = [[1,17],[4,5],[14,17],[5,11],[15,16]]输出：[9,0,0,0,0]解释：- queries[0] 有 9 个盘子在蜡烛之间。- 另一个查询没有盘子在蜡烛之间。 提示： 3 &lt;= s.length &lt;= 105 s 只包含字符 '*' 和 '|' 。 1 &lt;= queries.length &lt;= 105 queries[i].length == 2 0 &lt;= lefti &lt;= righti &lt; s.length 题解这道题是经典的前缀和问题。 根据题我们可以很容易得知只需找到左边第一个蜡烛left和右边第一个蜡烛right之间的蜡烛即可。我们可以用preSum[i]表示i之前的蜡烛数量，因而[left,right]之间的蜡烛数为preSum[right]-preSum[left] left数组通过从后往前遍历求得 right数组从前往后遍历即可。 代码12345678910111213141516171819202122232425262728293031323334353637class Solution { public int[] platesBetweenCandles(String s, int[][] queries) { char[] as = s.toCharArray(); int n = as.length; int[] preSum = new int[n]; int[] answer = new int[queries.length]; int[] left = new int[n]; int[] right = new int[n]; for (int i = 0, sum = 0; i &lt; n; i++) { if (as[i] == '*') { sum++; } preSum[i] = sum; } for (int i = n - 1, leftCandle = n - 1; i &gt;= 0; i--) { if (as[i] == '|') { leftCandle = i; } left[i] = leftCandle; } for (int i = 0, rightCandle = 0; i &lt; n; i++) { if (as[i] == '|') { rightCandle = i; } right[i] = rightCandle; } for (int i = 0; i &lt; queries.length; i++) { int ans = preSum[right[queries[i][1]]] - preSum[left[queries[i][0]]]; if (ans &gt;= 0) answer[i] = ans; else answer[i] = 0; } return answer; }} 复杂度 空间复杂度O(n+C) c为queries.length 时间复杂度O(n)","link":"/2022/03/08/%E3%80%90Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%912055%20%E8%9C%A1%E7%83%9B%E4%B9%8B%E9%97%B4%E7%9A%84%E7%9B%98%E5%AD%90/"},{"title":"【Leetcode刷题笔记】23 合并K个升序链表","text":"题目描述 给你一个链表数组，每个链表都已经按升序排列。 请你将所有链表合并到一个升序链表中，返回合并后的链表。 示例 1： 12345678910输入：lists = [[1,4,5],[1,3,4],[2,6]]输出：[1,1,2,3,4,4,5,6]解释：链表数组如下：[ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6]将它们合并到一个有序链表中得到。1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6 示例 2： 12输入：lists = []输出：[] 示例 3： 12输入：lists = [[]]输出：[] 提示： k == lists.length 0 &lt;= k &lt;= 10^4 0 &lt;= lists[i].length &lt;= 500 -10^4 &lt;= lists[i][j] &lt;= 10^4 lists[i] 按 升序 排列 lists[i].length 的总和不超过 10^4 题解顺序合并两个链表 代码12345678910111213141516171819202122232425262728293031323334353637class Solution { public ListNode mergeKLists(ListNode[] lists) { ListNode ans=null; int n = lists.length; if(n==0){ return ans; } if(n==1){ return lists[0]; } ans=merge(lists[0],lists[1]); for (int i = 2; i &lt; n; i++) { ans=merge(ans,lists[i]); } return ans; } private ListNode merge(ListNode a, ListNode b) { if (a == null || b == null) { return a != null ? a : b; } ListNode head = new ListNode(0); ListNode tail = head, aPtr = a, bPtr = b; while (aPtr != null &amp;&amp; bPtr != null) { if (aPtr.val &lt; bPtr.val) { tail.next = aPtr; aPtr = aPtr.next; } else { tail.next = bPtr; bPtr = bPtr.next; } tail = tail.next; } tail.next = (aPtr != null ? aPtr : bPtr); return head.next; }} 复杂度 时间复杂度O($k^2n$) 空间复杂度O(1)","link":"/2022/03/11/%E3%80%90Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%9123%20%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/"},{"title":"【Leetcode刷题笔记】393 UTF-8 编码验证","text":"题目描述 给定一个表示数据的整数数组 data ，返回它是否为有效的 UTF-8 编码。 UTF-8 中的一个字符可能的长度为 1 到 4 字节，遵循以下的规则： 对于 1 字节 的字符，字节的第一位设为 0 ，后面 7 位为这个符号的 unicode 码。 对于 n 字节 的字符 (n &gt; 1)，第一个字节的前 n 位都设为1，第 n+1 位设为 0 ，后面字节的前两位一律设为 10 。剩下的没有提及的二进制位，全部为这个符号的 unicode 码。 这是 UTF-8 编码的工作方式： 1234567Char. number range | UTF-8 octet sequence (hexadecimal) | (binary)--------------------+---------------------------------------------0000 0000-0000 007F | 0xxxxxxx0000 0080-0000 07FF | 110xxxxx 10xxxxxx0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 注意：输入是整数数组。只有每个整数的 最低 8 个有效位 用来存储数据。这意味着每个整数只表示 1 字节的数据。 示例 1： 1234输入：data = [197,130,1]输出：true解释：数据表示字节序列:11000101 10000010 00000001。这是有效的 utf-8 编码，为一个 2 字节字符，跟着一个 1 字节字符。 示例 2： 123456输入：data = [235,140,4]输出：false解释：数据表示 8 位的序列: 11101011 10001100 00000100.前 3 位都是 1 ，第 4 位为 0 表示它是一个 3 字节字符。下一个字节是开头为 10 的延续字节，这是正确的。但第二个延续字节不以 10 开头，所以是不符合规则的。 提示: 1 &lt;= data.length &lt;= 2 * 104 0 &lt;= data[i] &lt;= 255 题解位运算 判断编码是否有效，需要解决两个问题： 当前字节是否是单字节字符。 多字节字符有多少位，是否符合格式。 对于问题1，我们准备MASK1(1&lt;&lt;7)来判断 对于问题2，我们依次从高位到低位判断有n个1（n的个数小于等于4个），随后判断后面的n个字节是否以10开头即可。 当不满足以上任一条件时，编码无效。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution { public static final int MASK1=1&lt;&lt;7;// 判断1字节还是n字节 public static final int MASK2=(1&lt;&lt;7)+(1&lt;&lt;6); // 判断编码第一字节还是其他字节 public boolean validUtf8(int[] data) { int n=data.length; int i=0; while (i&lt;n){ if((data[i]&amp;MASK1)==0){ i++; }else{ int nums=6; int maskBytes=1&lt;&lt;nums; int bytes=1; while(nums&gt;0){ if((maskBytes&amp;data[i])==maskBytes){ bytes++; nums--; maskBytes=1&lt;&lt;nums; }else{ break; } } if(nums&lt;3||bytes&lt;2){ return false; } for (int j = 1; j &lt; bytes; j++) { i++; if(i&gt;=n){ return false; } if((data[i]&amp;MASK2)!=MASK1){ return false; } } i++; } } return true; }} 复杂度 空间复杂度O(n） 时间复杂度O(1)","link":"/2022/03/01/%E3%80%90Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%91393%20UTF-8%20%E7%BC%96%E7%A0%81%E9%AA%8C%E8%AF%81/"},{"title":"【Leetcode刷题笔记】504 7进制数","text":"【Leetcode刷题笔记】504 七进制数题目描述 给定一个整数 num，将其转化为 7 进制，并以字符串形式输出。 示例 1: 12输入: num = 100输出: &quot;202&quot; 示例 2: 12输入: num = -7输出: &quot;-10&quot; 提示： -107 &lt;= num &lt;= 107 Related Topics 数学 题解连除即可。 由于需要转换成字符串，需要注意数字的正负。 12345678910111213141516171819class Solution { public String convertToBase7(int num) { int tmp=num; if(num==0){ return &quot;0&quot;; } num=Math.abs(num); StringBuffer res=new StringBuffer(); while (num!=0){ res.append(num%7); num/=7; } if(tmp&lt;0){ res.append('-'); } return res.reverse().toString(); }} 复杂度 空间复杂度O(C) C为除尽num的次数。 时间复杂度O(1)","link":"/2022/03/07/%E3%80%90Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%91504%20%E4%B8%83%E8%BF%9B%E5%88%B6%E6%95%B0/"},{"title":"【Leetcode刷题笔记】589 N叉树的前序遍历","text":"题目描述 给定一个 n 叉树的根节点 root ，返回 其节点值的 前序遍历 。 n 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 null 分隔（请参见示例）。 示例 1： 12输入：root = [1,null,3,2,4,null,5,6]输出：[1,3,5,6,2,4] 示例 2： 12输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]输出：[1,2,3,6,7,11,14,4,8,12,5,9,13,10] 提示： 节点总数在范围 [0, 104]内 0 &lt;= Node.val &lt;= 104 n 叉树的高度小于或等于 1000 题解递归法很简单，搞清楚前序遍历的原理即可。 遍历可使用栈实现，但效率不如递归法。用栈存储每个杰点子节点的迭代器，如果Iterator.hasNext()为真，则把iterator.next()入栈，否则出栈。 代码递归法 12345678910111213141516171819class Solution { List&lt;Integer&gt; res; public List&lt;Integer&gt; preorder(Node root) { res = new ArrayList&lt;&gt;(); preOrderTraverse(root); return res; }private void preOrderTraverse(Node root) { if (root == null) { return; } this.res.add(root.val); Iterator&lt;Node&gt; it = root.children.iterator(); while (it.hasNext()) { preOrderTraverse(it.next()); } }} 遍历法 1234567891011121314151617181920212223242526class Solution { List&lt;Integer&gt; res; public List&lt;Integer&gt; preorder(Node root) { res = new ArrayList&lt;&gt;(); if(root==null){ return res; } res.add(root.val); Stack&lt;Iterator&lt;Node&gt;&gt; stack=new Stack&lt;&gt;(); stack.push(root.children.iterator()); while(!stack.isEmpty()){ Iterator&lt;Node&gt; it=stack.peek(); if(!it.hasNext()){ stack.pop(); }else { Node node=it.next(); res.add(node.val); stack.add(node.children.iterator()); } } return res;// preOrderTraverse(root);// return res; }} 复杂度 时间复杂度O(n)","link":"/2022/03/10/%E3%80%90Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%91589%20N%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/"},{"title":"【Leetcode刷题笔记】6 Z字形变换","text":"题目描述 将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。 比如输入字符串为 &quot;PAYPALISHIRING&quot; 行数为 3 时，排列如下： 123P A H NA P L S I I GY I R 之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：&quot;PAHNAPLSIIGYIR&quot;。 请你实现这个将字符串进行指定行数变换的函数： 1string convert(string s, int numRows); 示例 1： 12输入：s = &quot;PAYPALISHIRING&quot;, numRows = 3输出：&quot;PAHNAPLSIIGYIR&quot; 示例 2： 1234567输入：s = &quot;PAYPALISHIRING&quot;, numRows = 4输出：&quot;PINALSIGYAHRPI&quot;解释：P I NA L S I GY A H RP I 示例 3： 12输入：s = &quot;A&quot;, numRows = 1输出：&quot;A&quot; 提示： 1 &lt;= s.length &lt;= 1000 s 由英文字母（小写和大写）、',' 和 '.' 组成 1 &lt;= numRows &lt;= 1000 题解思路就是，创建一个二维字符数组来存放Z字形字符，然后遍历原字符串，计算出每个字符相应位置。然后遍历二维字符数组一次即可。 123456789101112131415161718192021222324252627class Solution { public String convert(String s, int numRows) { if (numRows==1){ return s; } int n = s.length(); char[] ss = s.toCharArray(); int T = numRows * 2 - 2; int numT = n / T + 1; char[][] res = new char[numRows][numT*(numRows-1)]; for (int i = 0; i &lt; n; i++) { int row = i % T &gt; T / 2 ? T - i % T : i % T; int col = i / T * (T - numRows + 1) + (i % T &gt; T / 2 ? i % T - T / 2 : 0); res[row][col]=ss[i]; } StringBuffer ans=new StringBuffer(); for (int i = 0; i &lt; numRows; i++) { for (int j = 0; j &lt; numT * (numRows - 1); j++) { if (res[i][j]!='\\0'){ ans.append(res[i][j]); } } } return ans.toString(); }} 复杂度 空间复杂度O(n+numrows * (n/(numrows*2-2)) 时间复杂度O(numrows * (n/(numrows*2-2))","link":"/2022/03/01/%E3%80%90Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%916%20Z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/"},{"title":"【Leetcode刷题笔记】599 两个列表最小索引总和","text":"题目描述 假设 Andy 和 Doris 想在晚餐时选择一家餐厅，并且他们都有一个表示最喜爱餐厅的列表，每个餐厅的名字用字符串表示。 你需要帮助他们用最少的索引和找出他们共同喜爱的餐厅。 如果答案不止一个，则输出所有答案并且不考虑顺序。 你可以假设答案总是存在。 示例 1: 123输入: list1 = [&quot;Shogun&quot;, &quot;Tapioca Express&quot;, &quot;Burger King&quot;, &quot;KFC&quot;]，list2 = [&quot;Piatti&quot;, &quot;The Grill at Torrey Pines&quot;, &quot;Hungry Hunter Steakhouse&quot;, &quot;Shogun&quot;]输出: [&quot;Shogun&quot;]解释: 他们唯一共同喜爱的餐厅是“Shogun”。 示例 2: 123输入:list1 = [&quot;Shogun&quot;, &quot;Tapioca Express&quot;, &quot;Burger King&quot;, &quot;KFC&quot;]，list2 = [&quot;KFC&quot;, &quot;Shogun&quot;, &quot;Burger King&quot;]输出: [&quot;Shogun&quot;]解释: 他们共同喜爱且具有最小索引和的餐厅是“Shogun”，它有最小的索引和1(0+1)。 提示: 1 &lt;= list1.length, list2.length &lt;= 1000 1 &lt;= list1[i].length, list2[i].length &lt;= 30 list1[i] 和 list2[i] 由空格 ' ' 和英文字母组成。 list1 的所有字符串都是 唯一 的。 list2 中的所有字符串都是 唯一 的。 题解哈希表 遍历任意一个字符串数组，建立hash表。随后遍历另一个字符串数组，如果hashMap中Key存在分为两种情况： 索引和与当前最小索引和相等，则入栈 索引和比当前最小索引和小，则清空栈再入栈 这里我用长度较小的字符串数组建立HashMap，节省了一些空间开销。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution { class Pair{ public String name; public int sum; public Pair(String name, int sum) { this.name = name; this.sum = sum; } } public String[] findRestaurant(String[] list1, String[] list2) { int n1 = list1.length; int n2 = list2.length; String[] mapString = n1 &lt; n2 ? list2 : list1; String[] cmpString = n1 &lt; n2 ? list1 : list2; Map&lt;String, Integer&gt; nameMap = new HashMap&lt;&gt;(); List&lt;String&gt; res=new ArrayList&lt;&gt;(); Stack&lt;Pair&gt; stack=new Stack&lt;&gt;(); for (int j = 0; j &lt; mapString.length; j++) { nameMap.putIfAbsent(mapString[j], j); } for (int i = 0; i &lt; cmpString.length; i++) { int index=nameMap.getOrDefault(cmpString[i],-1); if (index != -1) { if(!stack.isEmpty()){ if(stack.peek().sum&gt;index+i){ stack.clear(); stack.push(new Pair(cmpString[i],index+i)); }else if(stack.peek().sum==index+i){ stack.push(new Pair(cmpString[i],index+i)); } }else{ stack.push(new Pair(cmpString[i],index+i)); } } } Iterator&lt;Pair&gt; iter=stack.iterator(); while(iter.hasNext()){ res.add(iter.next().name); } return res.toArray(new String[0]); }} 复杂度 空间复杂度O(min(n1,n2)) 时间复杂度O(n1+n2)","link":"/2022/03/14/%E3%80%90Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%91599%20%E4%B8%A4%E4%B8%AA%E5%88%97%E8%A1%A8%E6%9C%80%E5%B0%8F%E7%B4%A2%E5%BC%95%E6%80%BB%E5%92%8C/"},{"title":"【Leetcode刷题笔记】720 词典中最长的单词","text":"题目描述 给出一个字符串数组 words 组成的一本英语词典。返回 words 中最长的一个单词，该单词是由 words 词典中其他单词逐步添加一个字母组成。 若其中有多个可行的答案，则返回答案中字典序最小的单词。若无答案，则返回空字符串。 示例 1： 123输入：words = [&quot;w&quot;,&quot;wo&quot;,&quot;wor&quot;,&quot;worl&quot;, &quot;world&quot;]输出：&quot;world&quot;解释： 单词&quot;world&quot;可由&quot;w&quot;, &quot;wo&quot;, &quot;wor&quot;, 和 &quot;worl&quot;逐步添加一个字母组成。 示例 2： 123输入：words = [&quot;a&quot;, &quot;banana&quot;, &quot;app&quot;, &quot;appl&quot;, &quot;ap&quot;, &quot;apply&quot;, &quot;apple&quot;]输出：&quot;apple&quot;解释：&quot;apply&quot; 和 &quot;apple&quot; 都能由词典中的单词组成。但是 &quot;apple&quot; 的字典序小于 &quot;apply&quot; 提示： 1 &lt;= words.length &lt;= 1000 1 &lt;= words[i].length &lt;= 30 所有输入的字符串 words[i] 都只包含小写字母。 Related Topics 字典树 数组 哈希表 字符串 排序 题解前缀树 前缀树：以空串为根节点，出现新的前缀则增加新的子节点。本题因为是针对单词，因而可以把children设置为长度为26的字符数组。更复杂的情况可能需要使用HashMap来处理。 注意题中要求，如果一个单词不是在已有前缀上增添一个新字母而产生的，则无效。因而我们在节点中增加一个新的值word，来代表是否有单词的终点为此节点。 这样做的好处是在搜索时，如果发现搜索的子节点的word属性为Null，说明该单词不是从已有的派生出来的，此时搜索可以直接返回false。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution { String res; TrieNode root; public String longestWord(String[] words) { root = new TrieNode(); root.word=&quot;&quot;; res=new String(&quot;&quot;); for (String word : words) { TrieNode node = root; for (char c : word.toCharArray()) { if (node.children[c - 'a'] == null) { node.children[c - 'a'] = new TrieNode(); } node = node.children[c - 'a']; } node.word=word; } for(String word:words){ if(search(word)){ if(word.length()&gt;res.length()||(word.length()==res.length())&amp;&amp;word.compareTo(res)&lt;0){ res=word; } } } return res; } private boolean search(String prefix) { TrieNode node=root; for(char c:prefix.toCharArray()){ if(node.children[c-'a'].word==null){ return false; } node=node.children[c-'a']; } return true; } class TrieNode { TrieNode[] children = new TrieNode[26]; String word; }} 复杂度 空间复杂度O(n) 时间复杂度O($\\sum_{0}^{n-1}len(words[i]) $)","link":"/2022/03/17/%E3%80%90Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%91720%20%E8%AF%8D%E5%85%B8%E4%B8%AD%E6%9C%80%E9%95%BF%E7%9A%84%E5%8D%95%E8%AF%8D/"},{"title":"【Leetcode刷题笔记】74 搜索矩阵","text":"题目描述编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性： 每行中的整数从左到右按升序排列。 每行的第一个整数大于前一行的最后一个整数。 示例 1： 12输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3输出：true 示例 2： 12输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13输出：false 提示： m == matrix.length n == matrix[i].length 1 &lt;= m, n &lt;= 100 -104 &lt;= matrix[i][j], target &lt;= 104 题解从矩阵右上角为根，发现根的左节点都小于根值，根的下节点都大于根值，这可以抽象成一棵BST java代码如下 1234567891011121314151617class Solution { public boolean searchMatrix(int[][] matrix, int target) { int height = matrix.length; int row = 0, col = matrix[0].length - 1; while (row != height &amp;&amp; col != -1) { if (matrix[row][col] == target) { return true; } else if (target &gt; matrix[row][col]) { row++; } else if (target &lt; matrix[row][col]) { col--; } } return false; }} 复杂度 空间复杂度 O(1) 时间复杂度O (logmn)","link":"/2022/02/20/%E3%80%90Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%9174%20%E6%90%9C%E7%B4%A2%E7%9F%A9%E9%98%B5/"},{"title":"【Leetcode刷题笔记】917 仅仅反转字母","text":"题目描述难度 hard 给你一个字符串 s ，根据下述规则反转字符串： 所有非英文字母保留在原有位置。 所有英文字母（小写或大写）位置反转。 返回反转后的 s 。 示例 1： 12输入：s = &quot;ab-cd&quot;输出：&quot;dc-ba&quot; 示例 2： 12输入：s = &quot;a-bC-dEf-ghIj&quot;输出：&quot;j-Ih-gfE-dCba&quot; 示例 3： 12输入：s = &quot;Test1ng-Leet=code-Q!&quot;输出：&quot;Qedo1ct-eeLg=ntse-T!&quot; 提示 1 &lt;= s.length &lt;= 100 s 仅由 ASCII 值在范围 [33, 122] 的字符组成 s 不含 '\\&quot;' 或 '\\\\' 题解我们知道翻转字符串的代码往往采用双指针这样写 123456int i=0,j=n-1;while(i&lt;j){ swap(i,j,s); i++; j--;} 这道题要求只对字母进行翻转，因而在指针遇到非字母字符直接跳过即可，遇到字母时直接翻转即可。 代码1234567891011121314151617181920212223class Solution { public String reverseOnlyLetters(String s) { char[] sa = s.toCharArray(); int n = sa.length; int i = 0, j = n - 1; while (i &lt; j) { while (!((sa[i] &gt;= 'a' &amp;&amp; sa[i] &lt;= 'z') || (sa[i] &gt;= 'A' &amp;&amp; sa[i] &lt;= 'Z')) &amp;&amp; i &lt; j) { i++; } while (!((sa[j] &gt;= 'a' &amp;&amp; sa[j] &lt;= 'z') || (sa[j] &gt;= 'A' &amp;&amp; sa[j] &lt;= 'Z')) &amp;&amp; i &lt; j) { j--; } if (i &lt; j) { char tmp = sa[i]; sa[i] = sa[j]; sa[j] = tmp; i++; j--; } } return new String(sa); }}","link":"/2022/02/23/%E3%80%90Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%91917%20%E4%BB%85%E4%BB%85%E5%8F%8D%E8%BD%AC%E5%AD%97%E6%AF%8D/"},{"title":"【Leetcode刷题笔记】 537 复数乘法","text":"题目描述复数 可以用字符串表示，遵循 &quot;**实部**+**虚部**i&quot; 的形式，并满足下述条件： 实部 是一个整数，取值范围是 [-100, 100] 虚部 也是一个整数，取值范围是 [-100, 100] i2 == -1 给你两个字符串表示的复数 num1 和 num2 ，请你遵循复数表示形式，返回表示它们乘积的字符串。 示例 1： 123输入：num1 = &quot;1+1i&quot;, num2 = &quot;1+1i&quot;输出：&quot;0+2i&quot;解释：(1 + i) * (1 + i) = 1 + i2 + 2 * i = 2i ，你需要将它转换为 0+2i 的形式。 示例 2： 123输入：num1 = &quot;1+-1i&quot;, num2 = &quot;1+-1i&quot;输出：&quot;0+-2i&quot;解释：(1 - i) * (1 - i) = 1 + i2 - 2 * i = -2i ，你需要将它转换为 0+-2i 的形式。 提示： num1 和 num2 都是有效的复数表示。 Related Topics 数学 字符串 模拟 题解这道题没什么好说的，直接模拟即可，很简单。 显然此题需要用到分割字符串来获得实数和虚数的数值，我们很容易想到String.split()方法，这里复习一下split()方法的用法： String.split()public String[] split(String regex) Splits this string around matches of the given regular expression. This method works as if by invoking the two-argument split method with the given expression and a limit argument of zero. Trailing empty strings are therefore not included in the resulting array. The string &quot;boo:and:foo&quot;, for example, yields the following results with these expressions: Regex Result : { &quot;boo&quot;, &quot;and&quot;, &quot;foo&quot; } o { &quot;b&quot;, &quot;&quot;, &quot;:and:f&quot; } Parameters: regex - the delimiting regular expression Returns: the array of strings computed by splitting this string around matches of the given regular expression Throws: PatternSyntaxException - if the regular expression’s syntax is invalid Since: 1.4 See Also: Pattern 代码123456789101112131415class Solution { public String complexNumberMultiply(String num1, String num2) { String[] complex1=num1.split(&quot;\\\\+|i&quot;); String[] complex2=num2.split(&quot;\\\\+|i&quot;); int real1=Integer.parseInt(complex1[0]); int imag1=Integer.parseInt(complex1[1]); int real2=Integer.parseInt(complex2[0]); int imag2=Integer.parseInt(complex2[1]); int real=real1*real2-imag1*imag2; int imag=real1*imag2+real2*imag1; String res=String.format(&quot;%d+%di&quot;,real,imag); return res; }} 复杂度 时间空间皆为O(1)","link":"/2022/02/25/%E3%80%90Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%91537%20%E5%A4%8D%E6%95%B0%E4%B9%98%E6%B3%95/"},{"title":"关于使用Anaconda的Pip出现SSL错误","text":"重装anaconda后，使用pip安装包出现以下错误 1ValueError: check_hostname requires server_hostname 以下是stackoverflow上查询到的解决方案 复制以下文件C:\\Users\\MyUser\\Miniconda3\\Library\\bin to C:\\Users\\MyUser\\Miniconda3\\DLLs: libcrypto-1_1-x64.dll libcrypto-1_1-x64.pdb libssl-1_1-x64.dll libssl-1_1-x64.pdb 成功解决问题。 这里贴出问题链接，这个问题里还有很多关于此问题的不同解决办法：pip is configured with locations that require TLS/SSL, however the ssl module in Python is not available - Stack Overflow 解决问题后，再使用pip install时依然出现了问题 12 raise ValueError(&quot;check_hostname requires server_hostname&quot;)ValueError: check_hostname requires server_hostname 问题是因为打开了vpn。注意，类似的问题在使用conda install时也会出现。在安装依赖时请关闭你的vp。","link":"/2021/09/16/%E3%80%90%E6%9D%82%E8%AE%B0%E3%80%91%E5%85%B3%E4%BA%8E%E4%BD%BF%E7%94%A8Anaconda%E7%9A%84Pip%E5%87%BA%E7%8E%B0SSL%E9%94%99%E8%AF%AF/"},{"title":"【JAVA】匿名内部类","text":"匿名内部类是局部内部类的更深入一步。 假如只创建某类的一个对象时，就不必将该类进行命名。 匿名内部类的前提是存在一个类或者接口，且匿名内部类是写在方法中的。 只针对重写一个方法时使用，需要重写多个方法时不建议使用 既然是匿名类，所以你无法在别的地方使用这个类（实例化，调用它的静态方法之类的） 特点的话，除了只能使用一次，其实还有其他用处（在看spring-boot源码时发现的） 当你想使用一个类的protected 方法时，但是又不和这个类在同一个包下，你是没办法调用的。 这时候匿名类就派上用场了，你可以声明一个匿名类继承该类，并定义一个方法，在这个方法内使用super调用你想调用的那个方法（其实你也可以写个类继承这个类，就能调用父类的protected方法了，但是匿名类更简洁，因为你只想调用这个方法而已） 举个栗子： 这个类有一个protected方法test，如果你在其他包下想调用这个protected方法是不行的，可以发现没有提示test方法 这时候你可以使用匿名类继承这个类，定义一个方法callParentTest()，在这个方法体内调用super.test()，最后调用这个callParentTest()即可。 在spring-boot中的HttpMessageConverts里也有用到这种方法 想复用WebMvcConfigurationSupport的getMessageConverter方法，但是定义为protected方法，所以使用匿名类来调用","link":"/2022/03/01/%E3%80%90Java%E3%80%91%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB/"},{"title":"【服务器】服务器配置记录","text":"服务器配置记录Ubuntu安装Docker1curl -sSL https://get.daocloud.io/docker | sh 在 /etc/docker下建立 daemon.json 文件，添加以下内容 123{ &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;]} 重启docker 1systemctl restart docker.service 测试安装成功 1sudo docker run hello-world 安装Redis1234567# 拉取Redis镜像docker pull redis# 查看本地Redis镜像docker images#运行redisdocker run --name myredis -p 6379:6379 -d redis redis-server --appendonly yes docker run - 运行docker name myredis - 名字 -p 6379:6379 - 把服务器的6379端口映射到docker的6379端口，这样可以通过服务器的端口访问docker的端口 -d 表示以后台形式运行redis redis redis-server –appendonly yes 表示开启持久化缓存模式，可以存到硬盘","link":"/2021/10/29/%E3%80%90%E6%9C%8D%E5%8A%A1%E5%99%A8%E3%80%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/"},{"title":"【算法】数独编程","text":"【算法】数独编程思路使用回溯法求解，从左到右从上到下依次求解。当出现错误方案，就回溯到上一层求解中继续判断下一个值的可行性。 时间复杂度最优为O(n²) 最坏为O(n²logn)，空间复杂度为O(n) 输入12345678910int[][] grid = new int[][] { { 0, 0, 5, 3, 0, 0, 0, 0, 0 }, { 8, 0, 0, 0, 0, 0, 0, 2, 0 }, { 0, 7, 0, 0, 1, 0, 5, 0, 0 }, { 4, 0, 0, 0, 0, 5, 3, 0, 0 }, { 0, 1, 0, 0, 7, 0, 0, 0, 6 }, { 0, 0, 3, 2, 0, 0, 0, 8, 0 }, { 0, 6, 0, 5, 0, 0, 0, 0, 9 }, { 0, 0, 4, 0, 0, 0, 0, 3, 0 }, { 0, 0, 0, 0, 0, 9, 7, 0, 0 } }; 输出123456789[1, 4, 5, 3, 2, 7, 6, 9, 8][8, 3, 9, 6, 5, 4, 1, 2, 7][6, 7, 2, 9, 1, 8, 5, 4, 3][4, 9, 6, 1, 8, 5, 3, 7, 2][2, 1, 8, 4, 7, 3, 9, 5, 6][7, 5, 3, 2, 9, 6, 4, 8, 1][3, 6, 7, 5, 4, 2, 8, 1, 9][9, 8, 4, 7, 6, 1, 2, 3, 5][5, 2, 1, 8, 3, 9, 7, 6, 4] 源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687import java.util.Arrays;public class Sudoku { int[][] grid = new int[][] { { 0, 0, 5, 3, 0, 0, 0, 0, 0 }, { 8, 0, 0, 0, 0, 0, 0, 2, 0 }, { 0, 7, 0, 0, 1, 0, 5, 0, 0 }, { 4, 0, 0, 0, 0, 5, 3, 0, 0 }, { 0, 1, 0, 0, 7, 0, 0, 0, 6 }, { 0, 0, 3, 2, 0, 0, 0, 8, 0 }, { 0, 6, 0, 5, 0, 0, 0, 0, 9 }, { 0, 0, 4, 0, 0, 0, 0, 3, 0 }, { 0, 0, 0, 0, 0, 9, 7, 0, 0 } }; int ROWS = 9; int COLS = 9; public static void main(String[] args) { Sudoku sudoku = new Sudoku(); sudoku.BackTrack(0); } /** * @description: (x,y)处是否允许放置num * @param {*} * @return {*} */ Boolean PlaceAllowed(int num, int x, int y) { // 获取x,y所在3*3box的左上角起点位置 int boxStartRow = x / 3 * 3; int boxStartCol = y / 3 * 3; // 行判断 for (int i = 0; i &lt; COLS; i++) { if (y != i &amp;&amp; grid[x][i] == num) { return false; } } // 列判断 for (int i = 0; i &lt; ROWS; i++) { if (x != i &amp;&amp; grid[i][y] == num) { return false; } } // box判断 for (int i = boxStartRow; i &lt; boxStartRow + 3; i++) { for (int j = boxStartCol; j &lt; boxStartCol + 3; j++) { if ((x != i || y != j) &amp;&amp; grid[i][j] == num) { return false; } } } // 上述三种情况都成立，则该位置可以放置num return true; } /** * @description:回溯法 * @param {solvedNums}:当前已解决的数独个数 * @return */ void BackTrack(int solvedNums) { // 如果填满，则求得解，输出结果 if (solvedNums == 81) { for (int i = 0; i &lt; ROWS; i++) { System.out.println(Arrays.toString(grid[i])); } } else { // 获取当前回溯位置的x,y坐标 int x = solvedNums / 9; int y = solvedNums % 9; // 如果当前x,y坐标已经被填充（预置数），则直接开启下一次回溯 if (grid[x][y] != 0) { BackTrack(solvedNums + 1); } else { for (int i = 1; i &lt; 10; i++) { if (PlaceAllowed(i, x, y)) { grid[x][y] = i; BackTrack(solvedNums + 1); } // 如果backtrack函数的 solvedNums 参数未到达81就返回，当前t的填充方案是错误的，需要重置grid[x][y] grid[x][y] = 0; } } } }}","link":"/2021/10/11/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%95%B0%E7%8B%AC%E7%BC%96%E7%A8%8B/"},{"title":"【Redis】源码分析（一）主数据结构分析","text":"Redis String底层数据结构分析Redis的String的数据类型可谓包罗万象，它既可以是一个简单的String，也可以是一个int型，还可以是float型，还可以是一张很大的图片，一首歌曲等。事实上所有的key都会在redis内部转换成一串不定长的字符串。当然，如果单纯用一串字符串来保存String那是不是效率太低了呢？试想一下，我有一个key长度为5，而另一个String长度为100000，那这两个String我应该怎么去分配他的空间呢？如果都用一个很大的空间去存储一个String，那效率就太低了。实际上，redis定义了一个名为sds的数据结构作为key的类型，先来看看他的源码： 1234567891011121314151617181920212223242526272829303132typedef char *sds;/* Note: sdshdr5 is never used, we just access the flags byte directly. * However is here to document the layout of type 5 SDS strings. */struct __attribute__ ((__packed__)) sdshdr5 { unsigned char flags; /* 3 lsb of type, and 5 msb of string length */ char buf[];};struct __attribute__ ((__packed__)) sdshdr8 { uint8_t len; /* used */ uint8_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[];};struct __attribute__ ((__packed__)) sdshdr16 { uint16_t len; /* used */ uint16_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[];};struct __attribute__ ((__packed__)) sdshdr32 { uint32_t len; /* used */ uint32_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[];};struct __attribute__ ((__packed__)) sdshdr64 { uint64_t len; /* used */ uint64_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[];}; 先从sdshdr5开始分析，sdshdr5中有两个变量，一个是flags，一个是buf。从注解中我们很容易可以看出，redis使用一个字节长度的unsigned char存储key的类型和长度，其中前三位为key的类型，即该key的数据结构是属于sdshdr中的哪一种，后五位为key的长度。而buf就是存储key的区域。 我们可以很容易推导出，sdshdr5可以存储$2^5-1=31$位的数据。 当然，31位的长度显然是不够的，因而redis的设计者还设计了sdshdr8,sdshdr16,sdshdr32,sdshdr64这四种更长的sds类型。 与sdshdr5不同的是，在后续的sds类型中，flag只表示类型（后5位不再使用）,而是使用一个符合长度需求的len来表示。 以下是sds中各个变量含义 变量名 解释 len sdshdr8以上使用len表示buf的长度 alloc 剩余可分配的buf长度 flag sdshdr5使用flag来表示类型和长度，sdshdr8以上只表示类型 buf 实际存储key ps:flag前五位的类型判断 1234567891011121314151617181920212223#define SDS_TYPE_5 0#define SDS_TYPE_8 1#define SDS_TYPE_16 2#define SDS_TYPE_32 3#define SDS_TYPE_64 4#define SDS_TYPE_MASK 7static inline size_t sdslen(const sds s) { unsigned char flags = s[-1]; switch(flags&amp;SDS_TYPE_MASK) { case SDS_TYPE_5: return SDS_TYPE_5_LEN(flags); case SDS_TYPE_8: return SDS_HDR(8,s)-&gt;len; case SDS_TYPE_16: return SDS_HDR(16,s)-&gt;len; case SDS_TYPE_32: return SDS_HDR(32,s)-&gt;len; case SDS_TYPE_64: return SDS_HDR(64,s)-&gt;len; } return 0;} Redis作者为了节省空间和提高性能所采取的办法和思想非常值得学习！ Redis 数据库源码分析数据库数据结构分析 图片原作者：爱写代码的大曾（B站） Redis String int 编码底层原理要分析Redis String和int的编码，需要把存储value的对象拿出来分析。以下是redis中存储value的对象-redisObject的源代码。 123456789typedef struct redisObject { unsigned type:4; // 数据类型 string,list,set,zset,hash... unsigned encoding:4; // 编码类型 unsigned lru:LRU_BITS; /* LRU time (relative to global lru_clock) or * LFU data (least significant 8 bits frequency * and most significant 16 bits access time). */ int refcount; // 引用计数 void *ptr;// 指向存储value的指针} robj; 注意看源代码中的encoding变量，本节的主要任务就是分析它的作用。 首先来看redis中决定value编码的源代码 12345678910111213141516171819202122232425262728293031323334353637383940robj *tryObjectEncoding(robj *o) { ... /* Check if we can represent this string as a long integer. * Note that we are sure that a string larger than 20 chars is not * representable as a 32 nor 64 bit integer. */ len = sdslen(s); // 如果value长度小于等于20以内，则有可能转换为整型值 if (len &lt;= 20 &amp;&amp; string2l(s,len,&amp;value)) { /* This object is encodable as a long. Try to use a shared object. * Note that we avoid using shared integers when maxmemory is used * because every object needs to have a private LRU field for the LRU * algorithm to work well. */ if ((server.maxmemory == 0 || !(server.maxmemory_policy &amp; MAXMEMORY_FLAG_NO_SHARED_INTEGERS)) &amp;&amp; value &gt;= 0 &amp;&amp; value &lt; OBJ_SHARED_INTEGERS) { decrRefCount(o); incrRefCount(shared.integers[value]); return shared.integers[value]; } else { if (o-&gt;encoding == OBJ_ENCODING_RAW) { sdsfree(o-&gt;ptr); o-&gt;encoding = OBJ_ENCODING_INT; // 将值本身赋给指针。 o-&gt;ptr = (void*) value; return o; } else if (o-&gt;encoding == OBJ_ENCODING_EMBSTR) { decrRefCount(o); return createStringObjectFromLongLongForValue(value); } } } .... return o;} 可以看到，redis对于String和int的处理是，如果String小于20，则可能可以用一个long类型来表示这个String。因而这时可以直接把指针的值作为value。因而我们在读这种数据时，直接读指针的值即可，不用再做一次IO去读取指针所指向的值。这样就又节省了空间和时间，提高了性能。 妙！ Redis EmdString在了解 EmdStr之前，我们需要先了解redisObject的大小。 从前面贴出的源代码可知，一个redisObject的大小为16bytes，然而CPU从内存中取数据一次最少要取64bytes，那我取一个redisObject的话，相当于剩下的48byte都没用。这就产生了浪费。 redis作者为了把这一部分字节用起来，又设置了一种数据类型叫emdstr。顾名思义，这种string类型是嵌入到redisObject里面的。 接下来我们来看这段决定编码是不是EmdStr的代码。 1234567891011121314#define OBJ_ENCODING_EMBSTR_SIZE_LIMIT 44/* If the string is small and is still RAW encoded, * try the EMBSTR encoding which is more efficient. * In this representation the object and the SDS string are allocated * in the same chunk of memory to save space and cache misses. */if (len &lt;= OBJ_ENCODING_EMBSTR_SIZE_LIMIT) { robj *emb; if (o-&gt;encoding == OBJ_ENCODING_EMBSTR) return o; emb = createEmbeddedStringObject(s,sdslen(s)); decrRefCount(o); return emb;} 可以看到，当len&lt;=44的时候，就采用emdstr去编码这个value。那为什么是44呢。因为这个时候value的数据结构是sdshdr5或者sdshdr8。而sdshdr5或者8的最大大小是4byte。那么除去者4byte，只剩下44byte了。这也就是为什么是44的原因。","link":"/2022/03/18/%E3%80%90Redis%E3%80%91%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%E4%B8%BB%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/"},{"title":"【Redis】源码分析（二） 数据类型源码分析","text":"Redis Rehashing过程分析过程请看注释 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657int dictRehash(dict *d, int n) { // 空访问阈值 int empty_visits = n*10; /* Max number of empty buckets to visit. */ // 如果 rehashidx==-1 则没有在rehash，那就停止rehash if (!dictIsRehashing(d)) return 0; // 如果rehash个数达到或者table[0]已经rehash完就结束while循环 while(n-- &amp;&amp; d-&gt;ht_used[0] != 0) { dictEntry *de, *nextde; /* Note that rehashidx can't overflow as we are sure there are more * elements because ht[0].used != 0 */ assert(DICTHT_SIZE(d-&gt;ht_size_exp[0]) &gt; (unsigned long)d-&gt;rehashidx); // 跳过空的dictEntry，如果空的个数达到阈值，则放弃rehashing while(d-&gt;ht_table[0][d-&gt;rehashidx] == NULL) { d-&gt;rehashidx++; if (--empty_visits == 0) return 1; } // 从非空rehash开始 de = d-&gt;ht_table[0][d-&gt;rehashidx]; /* Move all the keys in this bucket from the old to the new hash HT */ // 如果de非空 while(de) { uint64_t h; nextde = de-&gt;next; /* Get the index in the new hash table */ // 计算新的hashkey h = dictHashKey(d, de-&gt;key) &amp; DICTHT_SIZE_MASK(d-&gt;ht_size_exp[1]); // de转移到新的table[1]上 de-&gt;next = d-&gt;ht_table[1][h]; d-&gt;ht_table[1][h] = de; // 旧表已用减少 d-&gt;ht_used[0]--; // 新表医用增多 d-&gt;ht_used[1]++; de = nextde; } d-&gt;ht_table[0][d-&gt;rehashidx] = NULL; d-&gt;rehashidx++; } /* Check if we already rehashed the whole table... */ // 如果已经rehash完所有，则释放table[0]的空间，并将table[1]移到tabke[0] if (d-&gt;ht_used[0] == 0) { zfree(d-&gt;ht_table[0]); /* Copy the new ht onto the old one */ d-&gt;ht_table[0] = d-&gt;ht_table[1]; d-&gt;ht_used[0] = d-&gt;ht_used[1]; d-&gt;ht_size_exp[0] = d-&gt;ht_size_exp[1]; _dictReset(d, 1); d-&gt;rehashidx = -1; return 0; } /* More to rehash... */ return 1;} List底层实现原理分析List是一个有序的数据结构（按加入时序），Redis采用quicklist(双端链表)和ziplist(压缩列表)作为list的底层实现。其中ziplist作为节点存储在quicklist上，因而list的encoding是quicklist 可以通过设置每个Ziplist的最大容量，quickList(双端链表)的数据压缩范围，提升数据存储效率。 图片原作者：爱写代码的大曾（B站） quickListquickList是一个ziplist组成的双向链表。每个节点使用ziplist来保存数据。本质上来说，quicklist里面保存着一个一个小的ziplist。 结构 源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445typedef struct quicklistNode { struct quicklistNode *prev; //上一个node节点 struct quicklistNode *next; //下一个node unsigned char *zl; //保存的数据 压缩前ziplist 压缩后压缩的数据 unsigned int sz; /* ziplist size in bytes */ unsigned int count : 16; /* count of items in ziplist */ unsigned int encoding : 2; /* RAW==1 or LZF==2 */ unsigned int container : 2; /* NONE==1 or ZIPLIST==2 */ unsigned int recompress : 1; /* was this node previous compressed? */ unsigned int attempted_compress : 1; /* node can't compress; too small */ unsigned int extra : 10; /* more bits to steal for future usage */} quicklistNode; quickList就是一个标准的双向链表的配置，有head 有tail; 每一个节点是一个quicklistNode，包含prev和next指针。 每一个quicklistNode 包含 一个ziplist，*zp 压缩链表里存储键值。 所以quicklist是对ziplist进行一次封装，使用小块的ziplist来既保证了少使用内存，也保证了性能。 为什么不全部使用 ziplist呢？ 因为：ziplist存储在一段连续的内存上，所以存储效率很高。但是，它不利于修改操作，插入和删除操作需要频繁的申请和释放内存。特别是当ziplist长度很长的时候，一次realloc可能会导致大批量的数据拷贝。 ziplist压缩列表 ziplist 是为 Redis 节约内存而开发的。ziplist 是由一系列特殊编码的内存块构成的列表(像内存连续的数组，但每个元素长度不同)， 一个 ziplist 可以包含多个节点（entry）。ziplist 将表中每一项存放在前后连续的地址空间内，每一项因占用的空间不同，而采用变长编码。 ziplist的主要优点是节省内存，但它上面的查找操作只能按顺序查找（可以是从前往后、也可以从后往前）。ziplist将数据按照一定规则编码在一块连续的内存区域，目的是节省内存，这种结构并不擅长做修改操作。一旦数据发生改动，就会引发内存realloc，可能导致内存拷贝。 ziplist 是一个特殊的双向链表特殊之处在于：没有维护双向指针:prev next；而是存储上一个 entry的长度和 当前entry的长度，通过长度推算下一个元素在什么地方。牺牲读取的性能，获得高效的存储空间，因为(简短字符串的情况)存储指针比存储entry长度 更费内存。这是典型的“时间换空间”。 ziplist使用局限性字段、值比较小，才会用ziplist。 源码 12345678910111213141516171819202122232425typedef struct zlentry { // 压缩列表节点 unsigned int prevrawlensize, prevrawlen; // prevrawlen是前一个节点的长度，prevrawlensize是指prevrawlen的大小，有1字节和5字节两种 unsigned int lensize, len; // len为当前节点长度 lensize为编码len所需的字节大小 unsigned int headersize; // 当前节点的header大小 unsigned char encoding; // 节点的编码方式 unsigned char *p; // 指向节点的指针} zlentry; 如何通过一个节点向前跳转到另一个节点？用指向当前节点的指针 e ， 减去 前一个 entry的长度， 得出的结果就是指向前一个节点的地址 p 。 ziplist连锁更新问题 因为在ziplist中，每个zlentry都存储着前一个节点所占的字节数，而这个数值又是变长编码的。假设存在一个压缩列表，其包含e1、e2、e3、e4…..，e1节点的大小为253字节，那么e2.prevrawlen的大小为1字节，如果此时在e2与e1之间插入了一个新节点e_new，e_new编码后的整体长度（包含e1的长度）为254字节，此时e2.prevrawlen就需要扩充为5字节；如果e2的整体长度变化又引起了e3.prevrawlen的存储长度变化，那么e3也需要扩…….如此递归直到表尾节点或者某一个节点的prevrawlen本身长度可以容纳前一个节点的变化。其中每一次扩充都需要进行空间再分配操作。删除节点亦是如此，只要引起了操作节点之后的节点的prevrawlen的变化，都可能引起连锁更新。 连锁更新在最坏情况下需要进行N次空间再分配，而每次空间再分配的最坏时间复杂度为O(N)，因此连锁更新的总体时间复杂度是O(N^2)。即使涉及连锁更新的时间复杂度这么高，但它能引起的性能问题的概率是极低的：需要列表中存在大量的节点长度接近254的zlentry。","link":"/2022/03/18/%E3%80%90Redis%E3%80%91%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"}],"tags":[{"name":"刷题笔记","slug":"刷题笔记","link":"/tags/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"},{"name":"Anaconda","slug":"Anaconda","link":"/tags/Anaconda/"},{"name":"Pip","slug":"Pip","link":"/tags/Pip/"},{"name":"Java基础","slug":"Java基础","link":"/tags/Java%E5%9F%BA%E7%A1%80/"},{"name":"运维","slug":"运维","link":"/tags/%E8%BF%90%E7%BB%B4/"},{"name":"Docker","slug":"Docker","link":"/tags/Docker/"},{"name":"dfs","slug":"dfs","link":"/tags/dfs/"},{"name":"源码分析","slug":"源码分析","link":"/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"}],"categories":[{"name":"LeetCode","slug":"LeetCode","link":"/categories/LeetCode/"},{"name":"杂记","slug":"杂记","link":"/categories/%E6%9D%82%E8%AE%B0/"},{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"服务器","slug":"服务器","link":"/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"Redis","slug":"Redis","link":"/categories/Redis/"}]}